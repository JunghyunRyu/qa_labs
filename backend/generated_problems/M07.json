{
  "title": "비결정적 코드의 결정적 테스트 작성",
  "function_signature": "def generate_random_coupon(\n    prefix: str,\n    length: int = 8,\n    expiry_days: int = 30,\n    random_fn: Callable[[int, int], int] | None = None,\n    now_fn: Callable[[], datetime] | None = None\n) -> dict:",
  "golden_code": "from datetime import datetime, timedelta\nfrom typing import Callable\nimport random\n\n\ndef generate_random_coupon(\n    prefix: str,\n    length: int = 8,\n    expiry_days: int = 30,\n    random_fn: Callable[[int, int], int] | None = None,\n    now_fn: Callable[[], datetime] | None = None\n) -> dict:\n    '''\n    랜덤 쿠폰 코드를 생성한다.\n\n    Parameters:\n    - prefix: 쿠폰 코드 접두사 (예: \"SUMMER\")\n    - length: 랜덤 부분 길이 (기본값 8)\n    - expiry_days: 만료일까지 일수 (기본값 30). 0이면 당일 자정까지.\n    - random_fn: 랜덤 정수 생성 함수 (a, b) -> a~b 범위의 정수. None이면 random.randint 사용.\n    - now_fn: 현재 시간 반환 함수. None이면 datetime.now() 사용.\n\n    Returns:\n    {\n        \"code\": str,         # prefix + 랜덤 영숫자 (예: \"SUMMER-A1B2C3D4\")\n        \"created_at\": str,   # ISO 형식 생성 시간\n        \"expires_at\": str    # ISO 형식 만료 시간\n    }\n\n    쿠폰 코드 형식: {prefix}-{random_chars}\n    랜덤 문자: 0-9, A-Z (총 36자)\n    만료 시간: now + expiry_days (자정 기준)\n    '''\n    if random_fn is None:\n        random_fn = random.randint\n    if now_fn is None:\n        now_fn = datetime.now\n\n    # 랜덤 문자 생성 (0-9, A-Z)\n    chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"  # 36자\n    random_part = \"\"\n    for _ in range(length):\n        idx = random_fn(0, len(chars) - 1)  # 0~35\n        random_part += chars[idx]\n\n    code = f\"{prefix}-{random_part}\"\n\n    # 시간 계산\n    now = now_fn()\n    created_at = now\n\n    # 만료일: 오늘 + expiry_days 의 자정\n    expiry_date = (now + timedelta(days=expiry_days)).replace(\n        hour=23, minute=59, second=59, microsecond=0\n    )\n\n    return {\n        \"code\": code,\n        \"created_at\": created_at.isoformat(),\n        \"expires_at\": expiry_date.isoformat()\n    }",
  "buggy_implementations": [
    {
      "bug_description": "랜덤 인덱스 범위가 잘못되어 마지막 문자(Z)가 생성되지 않는다.",
      "buggy_code": "from datetime import datetime, timedelta\nfrom typing import Callable\nimport random\n\n\ndef generate_random_coupon(\n    prefix: str,\n    length: int = 8,\n    expiry_days: int = 30,\n    random_fn: Callable[[int, int], int] | None = None,\n    now_fn: Callable[[], datetime] | None = None\n) -> dict:\n    '''\n    랜덤 쿠폰 코드를 생성한다.\n    '''\n    if random_fn is None:\n        random_fn = random.randint\n    if now_fn is None:\n        now_fn = datetime.now\n\n    chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    random_part = \"\"\n    for _ in range(length):\n        # BUG: len(chars) - 1 대신 len(chars) - 2 사용 (마지막 문자 제외)\n        idx = random_fn(0, len(chars) - 2)  # 0~34 (Z 제외)\n        random_part += chars[idx]\n\n    code = f\"{prefix}-{random_part}\"\n\n    now = now_fn()\n    created_at = now\n    expiry_date = (now + timedelta(days=expiry_days)).replace(\n        hour=23, minute=59, second=59, microsecond=0\n    )\n\n    return {\n        \"code\": code,\n        \"created_at\": created_at.isoformat(),\n        \"expires_at\": expiry_date.isoformat()\n    }",
      "weight": 4
    },
    {
      "bug_description": "now 대신 utcnow를 사용하여 시간대가 일치하지 않는다.",
      "buggy_code": "from datetime import datetime, timedelta\nfrom typing import Callable\nimport random\n\n\ndef generate_random_coupon(\n    prefix: str,\n    length: int = 8,\n    expiry_days: int = 30,\n    random_fn: Callable[[int, int], int] | None = None,\n    now_fn: Callable[[], datetime] | None = None\n) -> dict:\n    '''\n    랜덤 쿠폰 코드를 생성한다.\n    '''\n    if random_fn is None:\n        random_fn = random.randint\n    if now_fn is None:\n        # BUG: datetime.now 대신 datetime.utcnow 사용\n        now_fn = datetime.utcnow\n\n    chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    random_part = \"\"\n    for _ in range(length):\n        idx = random_fn(0, len(chars) - 1)\n        random_part += chars[idx]\n\n    code = f\"{prefix}-{random_part}\"\n\n    now = now_fn()\n    created_at = now\n    expiry_date = (now + timedelta(days=expiry_days)).replace(\n        hour=23, minute=59, second=59, microsecond=0\n    )\n\n    return {\n        \"code\": code,\n        \"created_at\": created_at.isoformat(),\n        \"expires_at\": expiry_date.isoformat()\n    }",
      "weight": 3
    },
    {
      "bug_description": "expiry_days=0일 때 당일이 아닌 1일 후로 만료일이 설정된다.",
      "buggy_code": "from datetime import datetime, timedelta\nfrom typing import Callable\nimport random\n\n\ndef generate_random_coupon(\n    prefix: str,\n    length: int = 8,\n    expiry_days: int = 30,\n    random_fn: Callable[[int, int], int] | None = None,\n    now_fn: Callable[[], datetime] | None = None\n) -> dict:\n    '''\n    랜덤 쿠폰 코드를 생성한다.\n    '''\n    if random_fn is None:\n        random_fn = random.randint\n    if now_fn is None:\n        now_fn = datetime.now\n\n    chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    random_part = \"\"\n    for _ in range(length):\n        idx = random_fn(0, len(chars) - 1)\n        random_part += chars[idx]\n\n    code = f\"{prefix}-{random_part}\"\n\n    now = now_fn()\n    created_at = now\n    # BUG: expiry_days가 0이어도 최소 1일 추가 (off-by-one)\n    effective_days = max(1, expiry_days)\n    expiry_date = (now + timedelta(days=effective_days)).replace(\n        hour=23, minute=59, second=59, microsecond=0\n    )\n\n    return {\n        \"code\": code,\n        \"created_at\": created_at.isoformat(),\n        \"expires_at\": expiry_date.isoformat()\n    }",
      "weight": 4
    },
    {
      "bug_description": "주입된 random_fn과 now_fn을 무시하고 항상 내장 함수를 사용한다.",
      "buggy_code": "from datetime import datetime, timedelta\nfrom typing import Callable\nimport random\n\n\ndef generate_random_coupon(\n    prefix: str,\n    length: int = 8,\n    expiry_days: int = 30,\n    random_fn: Callable[[int, int], int] | None = None,\n    now_fn: Callable[[], datetime] | None = None\n) -> dict:\n    '''\n    랜덤 쿠폰 코드를 생성한다.\n    '''\n    # BUG: 주입된 함수를 무시하고 항상 내장 함수 사용\n    # if random_fn is None:\n    #     random_fn = random.randint\n    # if now_fn is None:\n    #     now_fn = datetime.now\n\n    chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    random_part = \"\"\n    for _ in range(length):\n        idx = random.randint(0, len(chars) - 1)  # 항상 random.randint 사용\n        random_part += chars[idx]\n\n    code = f\"{prefix}-{random_part}\"\n\n    now = datetime.now()  # 항상 datetime.now 사용\n    created_at = now\n    expiry_date = (now + timedelta(days=expiry_days)).replace(\n        hour=23, minute=59, second=59, microsecond=0\n    )\n\n    return {\n        \"code\": code,\n        \"created_at\": created_at.isoformat(),\n        \"expires_at\": expiry_date.isoformat()\n    }",
      "weight": 5
    }
  ],
  "description_md": "## 문제 설명\n\n실무에서 **비결정적(non-deterministic) 코드**를 테스트하는 것은 어려운 과제입니다. 랜덤 값 생성, 현재 시간 조회 등은 매 실행마다 다른 결과를 만들어 테스트를 **불안정(flaky)**하게 만듭니다.\n\n이 문제에서는 의존성 주입(Dependency Injection)을 통해 비결정적 코드를 **결정적으로 테스트**하는 방법을 학습합니다.\n\n### 함수 시그니처\n\n```python\ndef generate_random_coupon(\n    prefix: str,\n    length: int = 8,\n    expiry_days: int = 30,\n    random_fn: Callable[[int, int], int] | None = None,\n    now_fn: Callable[[], datetime] | None = None\n) -> dict:\n```\n\n### 동작 규칙\n\n1. **쿠폰 코드 형식**: `{prefix}-{random_chars}`\n   - 예: `\"SUMMER-A1B2C3D4\"`\n   - 랜덤 문자: 0-9, A-Z (총 36자 중 선택)\n\n2. **만료 시간**: `now + expiry_days`의 자정(23:59:59)\n   - `expiry_days=0`: 당일 자정까지\n   - `expiry_days=30`: 30일 후 자정까지\n\n3. **의존성 주입**:\n   - `random_fn(a, b)`: a~b 범위의 랜덤 정수 반환 (None이면 `random.randint`)\n   - `now_fn()`: 현재 시간 반환 (None이면 `datetime.now()`)\n\n### 반환값\n\n```python\n{\n    \"code\": \"PREFIX-XXXXXXXX\",\n    \"created_at\": \"2024-01-15T10:30:00\",  # ISO 형식\n    \"expires_at\": \"2024-02-14T23:59:59\"   # ISO 형식\n}\n```\n\n### 예시\n\n```python\nfrom datetime import datetime\n\n# 결정적 테스트를 위한 모킹\ndef mock_random(a, b):\n    return a  # 항상 첫 번째 문자 선택 (0 또는 A)\n\ndef mock_now():\n    return datetime(2024, 1, 15, 10, 30, 0)\n\nresult = generate_random_coupon(\n    prefix=\"TEST\",\n    length=4,\n    expiry_days=7,\n    random_fn=mock_random,\n    now_fn=mock_now\n)\n# result[\"code\"] == \"TEST-0000\" (항상 첫 번째 문자)\n# result[\"created_at\"] == \"2024-01-15T10:30:00\"\n# result[\"expires_at\"] == \"2024-01-22T23:59:59\"\n```\n\n### 테스트 작성 시 고려사항\n\n1. **결정적 테스트**: `random_fn`과 `now_fn`을 주입하여 항상 같은 결과가 나오도록 하세요.\n2. **의존성 주입 검증**: 함수가 주입된 함수를 실제로 사용하는지 확인하세요.\n3. **인덱스 범위**: 모든 문자(0-9, A-Z)가 생성될 수 있는지 테스트하세요.\n4. **만료일 계산**: `expiry_days=0`, `expiry_days=1` 등 경계값을 테스트하세요.\n5. **시간 일관성**: `created_at`과 `expires_at`의 관계가 올바른지 검증하세요.\n\n### Flaky 테스트 방지 패턴\n\n- **BAD**: `assert \"A\" in result[\"code\"]` (랜덤에 의존)\n- **GOOD**: 의존성 주입으로 결정적 결과 검증\n\n### 여러분의 과제\n\n`generate_random_coupon` 함수의 여러 구현이 준비되어 있으며, 일부에는 의도적인 버그가 있습니다.\n\npytest를 사용해 테스트 케이스를 작성하여:\n\n- 올바른 구현은 모든 테스트를 통과하고,\n- 버그가 있는 구현들은 하나 이상 테스트에서 실패하도록\n\n테스트 스위트를 설계해 보세요. **모든 테스트는 Flaky하지 않아야 합니다.** 이 문제는 의존성 주입, 결정적 테스트 작성, Flaky 테스트 방지 능력을 평가합니다.\n",
  "initial_test_template": "import pytest\nfrom datetime import datetime\nfrom target import generate_random_coupon\n\n\n# 결정적 테스트 헬퍼\n\ndef make_deterministic_random(sequence):\n    '''주어진 시퀀스를 순서대로 반환하는 랜덤 함수 생성'''\n    iterator = iter(sequence)\n    def mock_random(a, b):\n        return next(iterator)\n    return mock_random\n\n\ndef make_fixed_now(fixed_time):\n    '''고정된 시간을 반환하는 now 함수 생성'''\n    def mock_now():\n        return fixed_time\n    return mock_now\n\n\n# 기본 동작 테스트\n\ndef test_code_format():\n    # TODO: 쿠폰 코드가 \"{prefix}-{random}\" 형식인지 확인\n    # 힌트: 의존성 주입으로 결정적 결과 테스트\n    pass\n\n\ndef test_code_length():\n    # TODO: 랜덤 부분이 지정된 길이인지 확인\n    pass\n\n\n# 의존성 주입 테스트\n\ndef test_uses_injected_random_fn():\n    # TODO: random_fn이 실제로 호출되는지 확인\n    # 힌트: 특정 값을 반환하는 mock을 주입하고 결과 검증\n    pass\n\n\ndef test_uses_injected_now_fn():\n    # TODO: now_fn이 실제로 호출되는지 확인\n    pass\n\n\n# 랜덤 범위 테스트\n\ndef test_random_index_includes_last_char():\n    # TODO: 마지막 문자(Z)도 생성될 수 있는지 확인\n    # 힌트: 인덱스 35(Z)를 반환하는 random_fn 주입\n    pass\n\n\n# 만료일 테스트\n\ndef test_expiry_days_zero():\n    # TODO: expiry_days=0일 때 당일 자정까지인지 확인\n    pass\n\n\ndef test_expiry_days_calculation():\n    # TODO: expiry_days=30일 때 정확히 30일 후 자정인지 확인\n    pass\n\n\n# Flaky 방지 테스트\n\ndef test_deterministic_output():\n    # TODO: 같은 입력(주입 포함)에 대해 항상 같은 결과\n    pass\n",
  "tags": [
    "medium",
    "python",
    "pytest",
    "unit-test",
    "dependency-injection",
    "deterministic-test",
    "flaky-test",
    "random",
    "datetime",
    "testability"
  ],
  "difficulty": "Medium"
}
