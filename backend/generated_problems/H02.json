{
  "title": "CSV 고객 데이터 변환 파이프라인 테스트",
  "function_signature": "def parse_customer_csv(csv_text: str) -> list[dict]:",
  "golden_code": "from __future__ import annotations\n\n\ndef parse_customer_csv(csv_text: str) -> list[dict]:\n    \"\"\"Parse and normalize a customer CSV string into a list of dictionaries.\n\n    The CSV describes customer records with the following columns:\n        id,name,email,age,signup_date,is_active\n\n    Rules / behavior:\n    - The first non-empty, non-whitespace line is treated as the header.\n    - Column order must match exactly the expected header names\n      (id,name,email,age,signup_date,is_active) but case-insensitive.\n    - Lines that are empty or contain only whitespace are ignored.\n    - Each non-empty data row must have the same number of columns as the header;\n      otherwise a ValueError is raised.\n    - Whitespace around values is stripped during parsing.\n\n    Normalization / types:\n    - id: required, must be a positive integer (>= 1). Parsed to int.\n    - name: required, non-empty string after trimming. Returned as str.\n    - email: required, must contain a single '@' and at least one '.' after '@'.\n             Case is preserved. Returned as str.\n    - age: optional; if empty -> None, else must be an integer between 0 and 120 inclusive.\n           Returned as int or None.\n    - signup_date: required, must be in ISO format 'YYYY-MM-DD'. No timezone.\n                   Returned as the original string (no datetime object).\n    - is_active: required; accepted truthy strings (case-insensitive):\n                 'true', '1', 'yes', 'y'; falsy: 'false', '0', 'no', 'n'.\n                 Returned as bool.\n\n    Validation:\n    - If the header is missing required columns or is in the wrong order, raise ValueError.\n    - If any required field is missing/empty in a data row, raise ValueError.\n    - If any field fails to parse or validate according to the rules above,\n      raise ValueError with a helpful message.\n\n    Returns:\n        A list of dictionaries, one per row, with keys:\n        ['id', 'name', 'email', 'age', 'signup_date', 'is_active'].\n    \"\"\"\n\n    import re\n\n    if not isinstance(csv_text, str):\n        raise TypeError(\"csv_text must be a string\")\n\n    # Split into lines and strip trailing newlines/spaces\n    lines = [line for line in csv_text.splitlines()]\n\n    # Filter out completely empty / whitespace-only lines to find header\n    non_empty_indices = [i for i, line in enumerate(lines) if line.strip() != \"\"]\n    if not non_empty_indices:\n        return []  # no data at all\n\n    header_index = non_empty_indices[0]\n    header_line = lines[header_index].strip()\n    header_parts = [h.strip() for h in header_line.split(\",\")]\n\n    expected_header = [\"id\", \"name\", \"email\", \"age\", \"signup_date\", \"is_active\"]\n\n    # Case-insensitive header comparison but require exact order and length\n    if len(header_parts) != len(expected_header):\n        raise ValueError(\"CSV header must contain exactly: \" + \",\".join(expected_header))\n\n    normalized_header = [h.lower() for h in header_parts]\n    if normalized_header != expected_header:\n        raise ValueError(\"CSV header must be in order: \" + \",\".join(expected_header))\n\n    result: list[dict] = []\n\n    # Start processing from the line after the header\n    for raw_line in lines[header_index + 1:]:\n        if raw_line.strip() == \"\":\n            continue  # skip empty lines\n\n        parts = [p.strip() for p in raw_line.split(\",\")]\n        if len(parts) != len(expected_header):\n            raise ValueError(f\"Row has {len(parts)} columns, expected {len(expected_header)}\")\n\n        row_dict: dict = {}\n        row = dict(zip(expected_header, parts))\n\n        # id: positive integer\n        raw_id = row[\"id\"].strip()\n        if raw_id == \"\":\n            raise ValueError(\"id is required\")\n        try:\n            id_value = int(raw_id)\n        except ValueError as exc:\n            raise ValueError(f\"id must be an integer: {raw_id!r}\") from exc\n        if id_value < 1:\n            raise ValueError(\"id must be >= 1\")\n        row_dict[\"id\"] = id_value\n\n        # name: required non-empty string\n        name_value = row[\"name\"].strip()\n        if name_value == \"\":\n            raise ValueError(\"name is required\")\n        row_dict[\"name\"] = name_value\n\n        # email: very light validation\n        email_value = row[\"email\"].strip()\n        if email_value == \"\":\n            raise ValueError(\"email is required\")\n        if email_value.count(\"@\") != 1:\n            raise ValueError(f\"invalid email: {email_value!r}\")\n        local, domain = email_value.split(\"@\", 1)\n        if \".\" not in domain:\n            raise ValueError(f\"invalid email domain: {email_value!r}\")\n        row_dict[\"email\"] = email_value\n\n        # age: optional integer 0-120\n        raw_age = row[\"age\"].strip()\n        if raw_age == \"\":\n            age_value = None\n        else:\n            try:\n                age_value = int(raw_age)\n            except ValueError as exc:\n                raise ValueError(f\"age must be an integer or empty: {raw_age!r}\") from exc\n            if age_value < 0 or age_value > 120:\n                raise ValueError(\"age must be between 0 and 120 inclusive\")\n        row_dict[\"age\"] = age_value\n\n        # signup_date: simple ISO date pattern YYYY-MM-DD\n        raw_date = row[\"signup_date\"].strip()\n        if raw_date == \"\":\n            raise ValueError(\"signup_date is required\")\n        if not re.fullmatch(r\"\\d{4}-\\d{2}-\\d{2}\", raw_date):\n            raise ValueError(f\"signup_date must be in YYYY-MM-DD format: {raw_date!r}\")\n        row_dict[\"signup_date\"] = raw_date\n\n        # is_active: boolean mapping\n        raw_active = row[\"is_active\"].strip().lower()\n        if raw_active == \"\":\n            raise ValueError(\"is_active is required\")\n        truthy = {\"true\", \"1\", \"yes\", \"y\"}\n        falsy = {\"false\", \"0\", \"no\", \"n\"}\n        if raw_active in truthy:\n            is_active_value = True\n        elif raw_active in falsy:\n            is_active_value = False\n        else:\n            raise ValueError(\n                \"is_active must be one of true/false,1/0,yes/no,y/n (case-insensitive)\"\n            )\n        row_dict[\"is_active\"] = is_active_value\n\n        result.append(row_dict)\n\n    return result\n",
  "buggy_implementations": [
    {
      "bug_description": "헤더 순서/대소문자를 제대로 검증하지 않아, 컬럼 순서가 섞인 헤더나 추가 컬럼이 있어도 통과됨. 파이프라인 전체에서 잘못된 키 매핑으로 이어지는 데이터 변환 오류를 유발.",
      "buggy_code": "from __future__ import annotations\n\n\ndef parse_customer_csv(csv_text: str) -> list[dict]:\n    import re\n\n    if not isinstance(csv_text, str):\n        raise TypeError(\"csv_text must be a string\")\n\n    lines = [line for line in csv_text.splitlines()]\n    non_empty_indices = [i for i, line in enumerate(lines) if line.strip() != \"\"]\n    if not non_empty_indices:\n        return []\n\n    header_index = non_empty_indices[0]\n    header_line = lines[header_index].strip()\n    header_parts = [h.strip() for h in header_line.split(\",\")]\n\n    # BUG: only check that expected columns are present as a subset, ignore order and extra columns\n    expected_header = [\"id\", \"name\", \"email\", \"age\", \"signup_date\", \"is_active\"]\n    normalized_header = [h.lower() for h in header_parts]\n    for col in expected_header:\n        if col not in normalized_header:\n            raise ValueError(\"CSV header missing required column: \" + col)\n    # do not enforce same length or order\n\n    result: list[dict] = []\n\n    # Use the actual header names as keys\n    keys = [h.lower() for h in header_parts]\n\n    for raw_line in lines[header_index + 1:]:\n        if raw_line.strip() == \"\":\n            continue\n\n        parts = [p.strip() for p in raw_line.split(\",\")]\n        # BUG: allow shorter/longer rows; missing values padded with '' silently\n        if len(parts) < len(keys):\n            parts = parts + [\"\"] * (len(keys) - len(parts))\n        elif len(parts) > len(keys):\n            parts = parts[: len(keys)]\n\n        row_raw = dict(zip(keys, parts))\n        row_dict: dict = {}\n\n        # id\n        raw_id = row_raw.get(\"id\", \"\").strip()\n        if raw_id == \"\":\n            raise ValueError(\"id is required\")\n        try:\n            id_value = int(raw_id)\n        except ValueError as exc:\n            raise ValueError(f\"id must be an integer: {raw_id!r}\") from exc\n        if id_value < 1:\n            raise ValueError(\"id must be >= 1\")\n        row_dict[\"id\"] = id_value\n\n        # name\n        name_value = row_raw.get(\"name\", \"\").strip()\n        if name_value == \"\":\n            raise ValueError(\"name is required\")\n        row_dict[\"name\"] = name_value\n\n        # email\n        email_value = row_raw.get(\"email\", \"\").strip()\n        if email_value == \"\":\n            raise ValueError(\"email is required\")\n        if email_value.count(\"@\") != 1:\n            raise ValueError(f\"invalid email: {email_value!r}\")\n        local, domain = email_value.split(\"@\", 1)\n        if \".\" not in domain:\n            raise ValueError(f\"invalid email domain: {email_value!r}\")\n        row_dict[\"email\"] = email_value\n\n        # age\n        raw_age = row_raw.get(\"age\", \"\").strip()\n        if raw_age == \"\":\n            age_value = None\n        else:\n            try:\n                age_value = int(raw_age)\n            except ValueError as exc:\n                raise ValueError(f\"age must be an integer or empty: {raw_age!r}\") from exc\n            if age_value < 0 or age_value > 120:\n                raise ValueError(\"age must be between 0 and 120 inclusive\")\n        row_dict[\"age\"] = age_value\n\n        # signup_date\n        raw_date = row_raw.get(\"signup_date\", \"\").strip()\n        if raw_date == \"\":\n            raise ValueError(\"signup_date is required\")\n        if not re.fullmatch(r\"\\d{4}-\\d{2}-\\d{2}\", raw_date):\n            raise ValueError(f\"signup_date must be in YYYY-MM-DD format: {raw_date!r}\")\n        row_dict[\"signup_date\"] = raw_date\n\n        # is_active\n        raw_active = row_raw.get(\"is_active\", \"\").strip().lower()\n        if raw_active == \"\":\n            raise ValueError(\"is_active is required\")\n        truthy = {\"true\", \"1\", \"yes\", \"y\"}\n        falsy = {\"false\", \"0\", \"no\", \"n\"}\n        if raw_active in truthy:\n            is_active_value = True\n        elif raw_active in falsy:\n            is_active_value = False\n        else:\n            raise ValueError(\n                \"is_active must be one of true/false,1/0,yes/no,y/n (case-insensitive)\"\n            )\n        row_dict[\"is_active\"] = is_active_value\n\n        result.append(row_dict)\n\n    return result\n",
      "weight": 5
    },
    {
      "bug_description": "age 컬럼을 항상 int로 파싱해 None 값을 허용하지 않고, 범위 검증(0~120)도 누락. 파이프라인 중간 단계의 optional 필드 처리와 타입 정규화가 잘못되어 빈 age나 경계값에서 실패하지 않음.",
      "buggy_code": "from __future__ import annotations\n\n\ndef parse_customer_csv(csv_text: str) -> list[dict]:\n    import re\n\n    if not isinstance(csv_text, str):\n        raise TypeError(\"csv_text must be a string\")\n\n    lines = [line for line in csv_text.splitlines()]\n    non_empty_indices = [i for i, line in enumerate(lines) if line.strip() != \"\"]\n    if not non_empty_indices:\n        return []\n\n    header_index = non_empty_indices[0]\n    header_line = lines[header_index].strip()\n    header_parts = [h.strip() for h in header_line.split(\",\")]\n\n    expected_header = [\"id\", \"name\", \"email\", \"age\", \"signup_date\", \"is_active\"]\n    if len(header_parts) != len(expected_header):\n        raise ValueError(\"CSV header must contain exactly: \" + \",\".join(expected_header))\n    normalized_header = [h.lower() for h in header_parts]\n    if normalized_header != expected_header:\n        raise ValueError(\"CSV header must be in order: \" + \",\".join(expected_header))\n\n    result: list[dict] = []\n\n    for raw_line in lines[header_index + 1:]:\n        if raw_line.strip() == \"\":\n            continue\n\n        parts = [p.strip() for p in raw_line.split(\",\")]\n        if len(parts) != len(expected_header):\n            raise ValueError(f\"Row has {len(parts)} columns, expected {len(expected_header)}\")\n\n        row_raw = dict(zip(expected_header, parts))\n        row_dict: dict = {}\n\n        # id\n        raw_id = row_raw[\"id\"].strip()\n        if raw_id == \"\":\n            raise ValueError(\"id is required\")\n        try:\n            id_value = int(raw_id)\n        except ValueError as exc:\n            raise ValueError(f\"id must be an integer: {raw_id!r}\") from exc\n        if id_value < 1:\n            raise ValueError(\"id must be >= 1\")\n        row_dict[\"id\"] = id_value\n\n        # name\n        name_value = row_raw[\"name\"].strip()\n        if name_value == \"\":\n            raise ValueError(\"name is required\")\n        row_dict[\"name\"] = name_value\n\n        # email\n        email_value = row_raw[\"email\"].strip()\n        if email_value == \"\":\n            raise ValueError(\"email is required\")\n        if email_value.count(\"@\") != 1:\n            raise ValueError(f\"invalid email: {email_value!r}\")\n        local, domain = email_value.split(\"@\", 1)\n        if \".\" not in domain:\n            raise ValueError(f\"invalid email domain: {email_value!r}\")\n        row_dict[\"email\"] = email_value\n\n        # age (BUG: treat empty as 0, and no range validation)\n        raw_age = row_raw[\"age\"].strip()\n        if raw_age == \"\":\n            raw_age = \"0\"  # BUG: should be None, not 0\n        try:\n            age_value = int(raw_age)\n        except ValueError as exc:\n            raise ValueError(f\"age must be an integer or empty: {raw_age!r}\") from exc\n        # BUG: no range check 0-120\n        row_dict[\"age\"] = age_value\n\n        # signup_date\n        raw_date = row_raw[\"signup_date\"].strip()\n        if raw_date == \"\":\n            raise ValueError(\"signup_date is required\")\n        if not re.fullmatch(r\"\\d{4}-\\d{2}-\\d{2}\", raw_date):\n            raise ValueError(f\"signup_date must be in YYYY-MM-DD format: {raw_date!r}\")\n        row_dict[\"signup_date\"] = raw_date\n\n        # is_active\n        raw_active = row_raw[\"is_active\"].strip().lower()\n        if raw_active == \"\":\n            raise ValueError(\"is_active is required\")\n        truthy = {\"true\", \"1\", \"yes\", \"y\"}\n        falsy = {\"false\", \"0\", \"no\", \"n\"}\n        if raw_active in truthy:\n            is_active_value = True\n        elif raw_active in falsy:\n            is_active_value = False\n        else:\n            raise ValueError(\n                \"is_active must be one of true/false,1/0,yes/no,y/n (case-insensitive)\"\n            )\n        row_dict[\"is_active\"] = is_active_value\n\n        result.append(row_dict)\n\n    return result\n",
      "weight": 4
    },
    {
      "bug_description": "is_active 컬럼을 문자열로 그대로 반환하거나 truthy/falsy 집합을 제한적으로 처리하여, 다양한 표현(예: 'Y', '0', 'No')에서 bool 정규화가 틀리거나 실패하지 않음. 파이프라인 마지막 단계의 불리언 변환 문제가 있음.",
      "buggy_code": "from __future__ import annotations\n\n\ndef parse_customer_csv(csv_text: str) -> list[dict]:\n    import re\n\n    if not isinstance(csv_text, str):\n        raise TypeError(\"csv_text must be a string\")\n\n    lines = [line for line in csv_text.splitlines()]\n    non_empty_indices = [i for i, line in enumerate(lines) if line.strip() != \"\"]\n    if not non_empty_indices:\n        return []\n\n    header_index = non_empty_indices[0]\n    header_line = lines[header_index].strip()\n    header_parts = [h.strip() for h in header_line.split(\",\")]\n\n    expected_header = [\"id\", \"name\", \"email\", \"age\", \"signup_date\", \"is_active\"]\n    if len(header_parts) != len(expected_header):\n        raise ValueError(\"CSV header must contain exactly: \" + \",\".join(expected_header))\n    normalized_header = [h.lower() for h in header_parts]\n    if normalized_header != expected_header:\n        raise ValueError(\"CSV header must be in order: \" + \",\".join(expected_header))\n\n    result: list[dict] = []\n\n    for raw_line in lines[header_index + 1:]:\n        if raw_line.strip() == \"\":\n            continue\n\n        parts = [p.strip() for p in raw_line.split(\",\")]\n        if len(parts) != len(expected_header):\n            raise ValueError(f\"Row has {len(parts)} columns, expected {len(expected_header)}\")\n\n        row_raw = dict(zip(expected_header, parts))\n        row_dict: dict = {}\n\n        # id\n        raw_id = row_raw[\"id\"].strip()\n        if raw_id == \"\":\n            raise ValueError(\"id is required\")\n        try:\n            id_value = int(raw_id)\n        except ValueError as exc:\n            raise ValueError(f\"id must be an integer: {raw_id!r}\") from exc\n        if id_value < 1:\n            raise ValueError(\"id must be >= 1\")\n        row_dict[\"id\"] = id_value\n\n        # name\n        name_value = row_raw[\"name\"].strip()\n        if name_value == \"\":\n            raise ValueError(\"name is required\")\n        row_dict[\"name\"] = name_value\n\n        # email\n        email_value = row_raw[\"email\"].strip()\n        if email_value == \"\":\n            raise ValueError(\"email is required\")\n        if email_value.count(\"@\") != 1:\n            raise ValueError(f\"invalid email: {email_value!r}\")\n        local, domain = email_value.split(\"@\", 1)\n        if \".\" not in domain:\n            raise ValueError(f\"invalid email domain: {email_value!r}\")\n        row_dict[\"email\"] = email_value\n\n        # age (correct here)\n        raw_age = row_raw[\"age\"].strip()\n        if raw_age == \"\":\n            age_value = None\n        else:\n            try:\n                age_value = int(raw_age)\n            except ValueError as exc:\n                raise ValueError(f\"age must be an integer or empty: {raw_age!r}\") from exc\n            if age_value < 0 or age_value > 120:\n                raise ValueError(\"age must be between 0 and 120 inclusive\")\n        row_dict[\"age\"] = age_value\n\n        # signup_date\n        raw_date = row_raw[\"signup_date\"].strip()\n        if raw_date == \"\":\n            raise ValueError(\"signup_date is required\")\n        if not re.fullmatch(r\"\\d{4}-\\d{2}-\\d{2}\", raw_date):\n            raise ValueError(f\"signup_date must be in YYYY-MM-DD format: {raw_date!r}\")\n        row_dict[\"signup_date\"] = raw_date\n\n        # is_active (BUG: only 'true' and 'false', no numeric/yes/no; returns original string)\n        raw_active = row_raw[\"is_active\"].strip()\n        if raw_active == \"\":\n            raise ValueError(\"is_active is required\")\n        low = raw_active.lower()\n        if low == \"true\":\n            is_active_value = True\n        elif low == \"false\":\n            is_active_value = False\n        else:\n            # BUG: don't raise, just store the raw string\n            is_active_value = raw_active\n        row_dict[\"is_active\"] = is_active_value\n\n        result.append(row_dict)\n\n    return result\n",
      "weight": 3
    },
    {
      "bug_description": "빈/공백 줄 처리 및 전체 빈 입력 처리에서 파이프라인의 초기 단계가 잘못되어, 헤더 앞뒤에 공백 줄이 있는 경우 ValueError를 던지거나, 완전히 빈 문자열에서 예외가 발생. 멀티 스텝 처리의 시작 상태 처리 문제.",
      "buggy_code": "from __future__ import annotations\n\n\ndef parse_customer_csv(csv_text: str) -> list[dict]:\n    import re\n\n    if not isinstance(csv_text, str):\n        raise TypeError(\"csv_text must be a string\")\n\n    # BUG: don't handle completely empty input gracefully\n    if csv_text == \"\":\n        raise ValueError(\"csv_text must not be empty\")\n\n    lines = [line for line in csv_text.splitlines()]\n\n    # BUG: assume first line is always header, even if it's blank/whitespace\n    if not lines:\n        raise ValueError(\"no lines found\")\n\n    header_line = lines[0].strip()\n    if header_line == \"\":\n        # BUG: treat blank header as error instead of skipping to first non-empty\n        raise ValueError(\"header line is empty\")\n\n    header_parts = [h.strip() for h in header_line.split(\",\")]\n\n    expected_header = [\"id\", \"name\", \"email\", \"age\", \"signup_date\", \"is_active\"]\n    if len(header_parts) != len(expected_header):\n        raise ValueError(\"CSV header must contain exactly: \" + \",\".join(expected_header))\n    normalized_header = [h.lower() for h in header_parts]\n    if normalized_header != expected_header:\n        raise ValueError(\"CSV header must be in order: \" + \",\".join(expected_header))\n\n    result: list[dict] = []\n\n    for raw_line in lines[1:]:\n        # BUG: treat whitespace-only lines as data rows with a single empty column\n        if raw_line == \"\":\n            continue\n\n        parts = [p.strip() for p in raw_line.split(\",\")]\n        if len(parts) != len(expected_header):\n            raise ValueError(f\"Row has {len(parts)} columns, expected {len(expected_header)}\")\n\n        row_raw = dict(zip(expected_header, parts))\n        row_dict: dict = {}\n\n        # id\n        raw_id = row_raw[\"id\"].strip()\n        if raw_id == \"\":\n            raise ValueError(\"id is required\")\n        try:\n            id_value = int(raw_id)\n        except ValueError as exc:\n            raise ValueError(f\"id must be an integer: {raw_id!r}\") from exc\n        if id_value < 1:\n            raise ValueError(\"id must be >= 1\")\n        row_dict[\"id\"] = id_value\n\n        # name\n        name_value = row_raw[\"name\"].strip()\n        if name_value == \"\":\n            raise ValueError(\"name is required\")\n        row_dict[\"name\"] = name_value\n\n        # email\n        email_value = row_raw[\"email\"].strip()\n        if email_value == \"\":\n            raise ValueError(\"email is required\")\n        if email_value.count(\"@\") != 1:\n            raise ValueError(f\"invalid email: {email_value!r}\")\n        local, domain = email_value.split(\"@\", 1)\n        if \".\" not in domain:\n            raise ValueError(f\"invalid email domain: {email_value!r}\")\n        row_dict[\"email\"] = email_value\n\n        # age\n        raw_age = row_raw[\"age\"].strip()\n        if raw_age == \"\":\n            age_value = None\n        else:\n            try:\n                age_value = int(raw_age)\n            except ValueError as exc:\n                raise ValueError(f\"age must be an integer or empty: {raw_age!r}\") from exc\n            if age_value < 0 or age_value > 120:\n                raise ValueError(\"age must be between 0 and 120 inclusive\")\n        row_dict[\"age\"] = age_value\n\n        # signup_date\n        raw_date = row_raw[\"signup_date\"].strip()\n        if raw_date == \"\":\n            raise ValueError(\"signup_date is required\")\n        if not re.fullmatch(r\"\\d{4}-\\d{2}-\\d{2}\", raw_date):\n            raise ValueError(f\"signup_date must be in YYYY-MM-DD format: {raw_date!r}\")\n        row_dict[\"signup_date\"] = raw_date\n\n        # is_active\n        raw_active = row_raw[\"is_active\"].strip().lower()\n        if raw_active == \"\":\n            raise ValueError(\"is_active is required\")\n        truthy = {\"true\", \"1\", \"yes\", \"y\"}\n        falsy = {\"false\", \"0\", \"no\", \"n\"}\n        if raw_active in truthy:\n            is_active_value = True\n        elif raw_active in falsy:\n            is_active_value = False\n        else:\n            raise ValueError(\n                \"is_active must be one of true/false,1/0,yes/no,y/n (case-insensitive)\"\n            )\n        row_dict[\"is_active\"] = is_active_value\n\n        result.append(row_dict)\n\n    return result\n",
      "weight": 3
    },
    {
      "bug_description": "row 컬럼 개수 불일치에 대한 에러를 무시하고, 짧은 row는 비어 있는 값으로 패딩, 긴 row는 잘라내어 사용. 파이프라인 중간 단계의 구조 검증이 빠져 있어서 컬럼 누락/추가가 있는 입력이 조용히 통과됨.",
      "buggy_code": "from __future__ import annotations\n\n\ndef parse_customer_csv(csv_text: str) -> list[dict]:\n    import re\n\n    if not isinstance(csv_text, str):\n        raise TypeError(\"csv_text must be a string\")\n\n    lines = [line for line in csv_text.splitlines()]\n    non_empty_indices = [i for i, line in enumerate(lines) if line.strip() != \"\"]\n    if not non_empty_indices:\n        return []\n\n    header_index = non_empty_indices[0]\n    header_line = lines[header_index].strip()\n    header_parts = [h.strip() for h in header_line.split(\",\")]\n\n    expected_header = [\"id\", \"name\", \"email\", \"age\", \"signup_date\", \"is_active\"]\n    if len(header_parts) != len(expected_header):\n        raise ValueError(\"CSV header must contain exactly: \" + \",\".join(expected_header))\n    normalized_header = [h.lower() for h in header_parts]\n    if normalized_header != expected_header:\n        raise ValueError(\"CSV header must be in order: \" + \",\".join(expected_header))\n\n    result: list[dict] = []\n\n    for raw_line in lines[header_index + 1:]:\n        if raw_line.strip() == \"\":\n            continue\n\n        parts = [p.strip() for p in raw_line.split(\",\")]\n        # BUG: silently pad or truncate instead of raising\n        if len(parts) < len(expected_header):\n            parts = parts + [\"\"] * (len(expected_header) - len(parts))\n        elif len(parts) > len(expected_header):\n            parts = parts[: len(expected_header)]\n\n        row_raw = dict(zip(expected_header, parts))\n        row_dict: dict = {}\n\n        # id\n        raw_id = row_raw[\"id\"].strip()\n        if raw_id == \"\":\n            raise ValueError(\"id is required\")\n        try:\n            id_value = int(raw_id)\n        except ValueError as exc:\n            raise ValueError(f\"id must be an integer: {raw_id!r}\") from exc\n        if id_value < 1:\n            raise ValueError(\"id must be >= 1\")\n        row_dict[\"id\"] = id_value\n\n        # name\n        name_value = row_raw[\"name\"].strip()\n        if name_value == \"\":\n            raise ValueError(\"name is required\")\n        row_dict[\"name\"] = name_value\n\n        # email\n        email_value = row_raw[\"email\"].strip()\n        if email_value == \"\":\n            raise ValueError(\"email is required\")\n        if email_value.count(\"@\") != 1:\n            raise ValueError(f\"invalid email: {email_value!r}\")\n        local, domain = email_value.split(\"@\", 1)\n        if \".\" not in domain:\n            raise ValueError(f\"invalid email domain: {email_value!r}\")\n        row_dict[\"email\"] = email_value\n\n        # age\n        raw_age = row_raw[\"age\"].strip()\n        if raw_age == \"\":\n            age_value = None\n        else:\n            try:\n                age_value = int(raw_age)\n            except ValueError as exc:\n                raise ValueError(f\"age must be an integer or empty: {raw_age!r}\") from exc\n            if age_value < 0 or age_value > 120:\n                raise ValueError(\"age must be between 0 and 120 inclusive\")\n        row_dict[\"age\"] = age_value\n\n        # signup_date\n        raw_date = row_raw[\"signup_date\"].strip()\n        if raw_date == \"\":\n            raise ValueError(\"signup_date is required\")\n        if not re.fullmatch(r\"\\d{4}-\\d{2}-\\d{2}\", raw_date):\n            raise ValueError(f\"signup_date must be in YYYY-MM-DD format: {raw_date!r}\")\n        row_dict[\"signup_date\"] = raw_date\n\n        # is_active\n        raw_active = row_raw[\"is_active\"].strip().lower()\n        if raw_active == \"\":\n            raise ValueError(\"is_active is required\")\n        truthy = {\"true\", \"1\", \"yes\", \"y\"}\n        falsy = {\"false\", \"0\", \"no\", \"n\"}\n        if raw_active in truthy:\n            is_active_value = True\n        elif raw_active in falsy:\n            is_active_value = False\n        else:\n            raise ValueError(\n                \"is_active must be one of true/false,1/0,yes/no,y/n (case-insensitive)\"\n            )\n        row_dict[\"is_active\"] = is_active_value\n\n        result.append(row_dict)\n\n    return result\n",
      "weight": 4
    }
  ],
  "description_md": "## 문제 설명\n\n한 마케팅 서비스에서는 외부 파트너로부터 고객 정보를 CSV 파일로 주기적으로 전달받습니다. 이 CSV를 내부 시스템에서 바로 사용할 수 있도록 **파싱 → 필드 검증 → 정규화 → 딕셔너리 리스트 변환**까지 수행하는 데이터 변환 파이프라인 함수가 필요합니다.\n\n당신이 테스트해야 할 함수는 다음 시그니처를 가집니다:\n\n`parse_customer_csv(csv_text: str) -> list[dict]`\n\n### 함수 역할\n- `csv_text`로 전달된 **CSV 형식 문자열**을 읽어들입니다.\n- 첫 번째 의미 있는 줄을 헤더로 사용하여, 이후 각 데이터를 레코드로 파싱합니다.\n- 각 컬럼은 다음과 같이 처리됩니다.\n  - `id`: 필수, 양의 정수(int, >=1)\n  - `name`: 필수, 공백 제거 후 비어 있으면 안 됨\n  - `email`: 필수, 간단한 형식 검증(`@` 1개, `@` 뒤에 `.` 포함)\n  - `age`: 선택, 비어 있으면 `None`, 값이 있으면 0~120 범위의 int\n  - `signup_date`: 필수, `YYYY-MM-DD` 문자열 형식 (문자열 그대로 유지)\n  - `is_active`: 필수, 다양한 문자열 표현(`true/false`, `1/0`, `yes/no`, `y/n` 등, 대소문자 무시)을 bool로 매핑\n- 각 데이터 행을 위 규칙에 따라 **정규화된 dict**로 변환한 리스트를 반환합니다.\n- 헤더 형식/순서 오류, 컬럼 개수 불일치, 각 필드의 형식/범위 위반 등은 `ValueError`를 발생시켜야 합니다.\n\n### 입력/출력 예시\n\n#### 예시 1: 정상 입력\n```text\nid,name,email,age,signup_date,is_active\n1, Alice ,alice@example.com,30,2023-01-02,yes\n2,Bob,bob@example.org,,2022-12-31,false\n```\n\n반환 값 (개략적인 형태):\n```python\n[\n  {\n    \"id\": 1,\n    \"name\": \"Alice\",\n    \"email\": \"alice@example.com\",\n    \"age\": 30,\n    \"signup_date\": \"2023-01-02\",\n    \"is_active\": True,\n  },\n  {\n    \"id\": 2,\n    \"name\": \"Bob\",\n    \"email\": \"bob@example.org\",\n    \"age\": None,\n    \"signup_date\": \"2022-12-31\",\n    \"is_active\": False,\n  },\n]\n```\n\n#### 예시 2: 빈/공백 줄 포함 입력\n```text\n\n  id,name,email,age,signup_date,is_active\n\n3,Charlie,charlie@example.com,25,2024-03-01,1\n\n```\n\n위와 같이 헤더 앞뒤에 공백 줄이 있어도, 정상적으로 1개의 레코드가 파싱되어야 합니다.\n\n### 테스트 아이디어 힌트\n이 함수는 단순한 파서가 아니라 **다단계 파이프라인**입니다. 테스트를 설계할 때 다음과 같은 관점에서 생각해 보세요.\n\n- **파이프라인 단계 검증**\n  - 파싱 → 구조 검증(헤더/컬럼 수) → 필드별 타입/값 검증 → 최종 dict 변환이 올바른 순서와 규칙으로 동작하는지.\n- **데이터 변환 (정규화) 테스트**\n  - `age`가 빈 문자열일 때 `None`으로 변환되는지, 경계값(0, 120, 121 등)을 어떻게 처리하는지.\n  - `is_active`가 다양한 문자열 표현(`\"true\"`, `\"False\"`, `\"1\"`, `\"0\"`, `\"YES\"`, `\"n\"` 등)에서 올바른 bool로 변환되는지.\n- **헤더/구조 검증**\n  - 헤더의 **순서**, **대소문자**, **누락/추가 컬럼**이 있을 때 적절히 실패하는지.\n  - 데이터 행의 컬럼 개수가 헤더와 다를 때 예외가 발생하는지.\n- **멀티 스텝 처리 시나리오**\n  - 전체 입력이 비어 있는 경우, 헤더만 있고 데이터가 없는 경우, 중간에 공백 줄이 섞인 경우 등 다양한 시나리오에서 파이프라인이 일관되게 동작하는지.\n\n이 문제에는 여러 개의 버그 구현이 준비되어 있으며, 각각은 **데이터 변환**, **파이프라인 단계별 검증**, **multi-step processing에서의 경계/에러 처리**를 의도적으로 잘못 구현하고 있습니다.\n\n### 수험자가 해야 할 일\n- 제공된 `parse_customer_csv` 함수(실제 채점 시에는 buggy 구현들이 랜덤으로 선택됨)에 대해\n  **pytest 기반 단위 테스트 코드**를 작성하세요.\n- 다양한 입력 케이스를 설계하여, 가능한 한 많은 버그 구현을 실패시키고\n  정답 구현(`golden_code`)에서는 모두 통과하도록 해야 합니다.\n- 단일 happy path만이 아니라, 잘 설계된 **에러 케이스, 경계값, 구조적 깨짐(corrupted rows/headers)** 등을 포함해야 합니다.\n\n테스트 코드는 `pytest` 명령으로 실행 가능한 형태여야 하며, 이 문제는 **Hard 난이도**이므로\n파이프라인 전체 플로우를 고려한 복합적인 테스트 설계를 기대합니다.\n",
  "initial_test_template": "import pytest\n\nfrom target import parse_customer_csv\n\n\n# 기본 성공 시나리오: 정상적인 한두 개의 레코드가 올바르게 변환되는지 확인\n# - 모든 필드가 유효한 값일 때 타입/값이 기대와 일치하는지\n# - age, is_active의 정규화 결과를 포함해 검증하도록 설계\n\ndef test_basic_valid_records():\n    # TODO: 간단한 정상 CSV를 준비하고, 반환된 리스트 길이와 각 필드 타입/값을 검증하세요.\n    pass\n\n\n# 파이프라인 전체 플로우 테스트: 헤더, 공백 라인, 여러 행, 선택 필드(age) 등을 섞어서 검증\n# - 헤더 앞뒤 공백/빈 줄\n# - age가 빈 문자열인 경우 None으로 변환되는지\n# - 다양한 is_active 표현(yes/no/1/0/y/n, 대소문자 혼합)을 bool로 변환하는지\n\ndef test_pipeline_with_whitespace_and_optional_fields():\n    # TODO: 공백 줄과 선택 필드가 포함된 CSV를 구성하고, 변환 결과가 golden 구현과 일치하도록 검증하세요.\n    pass\n\n\n# 구조/검증 실패 시나리오: 파이프라인 중간 단계에서 올바르게 ValueError를 발생시키는지 확인\n# - 헤더 컬럼 순서 변경, 누락/추가 컬럼\n# - 데이터 행의 컬럼 수 불일치\n# - age, email, signup_date, is_active에 대한 잘못된 값들\n\ndef test_invalid_structure_and_field_values():\n    # TODO: 다양한 잘못된 CSV들을 준비하고, 각각 ValueError가 발생하는지 assert 하세요.\n    pass\n\n\n# 다단계 처리 관점 테스트: 여러 유형의 행을 한 번에 주고, 특정 행에서만 실패하는 상황 등도 고려\n# - 각 버그 구현이 어느 단계에서 잘못 동작하는지 드러날 수 있도록 케이스를 분리/조합\n\ndef test_mixed_valid_and_invalid_rows():\n    # TODO: 일부 행은 유효, 일부 행은 잘못된 데이터를 가지는 CSV를 구성하고, 전체 파이프라인의 동작을 검증하세요.\n    pass\n",
  "tags": [
    "hard",
    "qa",
    "testing",
    "unit-test",
    "data transformation",
    "pipeline testing",
    "multi-step processing",
    "csv",
    "string",
    "validation"
  ],
  "difficulty": "Hard"
}