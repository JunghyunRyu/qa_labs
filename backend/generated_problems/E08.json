{
  "title": "파일 경로 검증 함수 테스트",
  "function_signature": "def validate_file_path(path: Optional[str]) -> str:",
  "golden_code": "from typing import Optional\n\n\ndef validate_file_path(path: Optional[str]) -> str:\n    '''Validate and normalize a user-supplied relative file path.\n\n    Rules:\n    - path may be a string or None.\n    - None or an empty/whitespace-only string is rejected with ValueError.\n    - Absolute paths (starting with '/' or '\\\\' or a drive-letter like 'C:') are rejected.\n    - Paths containing '..' segments are rejected (to avoid directory traversal).\n    - Paths containing a NUL byte ('\\0') or control characters are rejected.\n    - Backslashes are normalized to forward slashes in the returned value.\n    - Leading and trailing whitespace around the whole path is ignored.\n\n    The function only validates format; it does not touch the filesystem.\n    On success, returns the normalized relative path using forward slashes.\n    '''\n    if path is None:\n        raise ValueError('path must not be None')\n\n    if not isinstance(path, str):\n        # Defensive check for callers who pass non-strings.\n        raise TypeError('path must be a string or None')\n\n    raw = path.strip()\n    if raw == '':\n        raise ValueError('path must not be empty')\n\n    # Reject NUL and other non-printable control characters (except tab).\n    for ch in raw:\n        if ch == '\\0' or (ord(ch) < 32 and ch not in ('\\t',)):\n            raise ValueError('path contains invalid characters')\n\n    # Normalize separators to '/' for validation.\n    normalized = raw.replace('\\\\', '/')\n\n    # Reject absolute or drive-letter paths.\n    if normalized.startswith('/'):\n        raise ValueError('absolute paths are not allowed')\n    if ':' in normalized.split('/')[0]:\n        # 'C:folder' or 'C:/folder'\n        raise ValueError('drive-letter paths are not allowed')\n\n    # Reject directory-traversal '..' segments.\n    parts = [p for p in normalized.split('/') if p not in ('', '.')]\n    if any(p == '..' for p in parts):\n        raise ValueError('parent-directory segments are not allowed')\n\n    # Reconstruct normalized relative path.\n    safe_path = '/'.join(parts)\n    if safe_path == '':\n        # This happens when user passes '.' or './'\n        raise ValueError('path must not resolve to the current directory only')\n\n    return safe_path",
  "buggy_implementations": [
    {
      "bug_description": "None 입력에 대해 strip()을 호출하여 AttributeError가 발생하고, 요구사항인 ValueError가 발생하지 않는다.",
      "buggy_code": "from typing import Optional\n\n\ndef validate_file_path(path: Optional[str]) -> str:\n    '''Validate and normalize a user-supplied relative file path.\n\n    BUG: Does not handle None explicitly; calling strip() on None\n    will raise AttributeError instead of a clean ValueError.\n    '''\n    if not isinstance(path, str):\n        # Defensive check for callers who pass non-strings.\n        raise TypeError('path must be a string or None')\n\n    # BUG: no explicit None check before strip().\n    raw = path.strip()\n    if raw == '':\n        raise ValueError('path must not be empty')\n\n    # Reject NUL and other non-printable control characters (except tab).\n    for ch in raw:\n        if ch == '\\0' or (ord(ch) < 32 and ch not in ('\\t',)):\n            raise ValueError('path contains invalid characters')\n\n    # Normalize separators to '/' for validation.\n    normalized = raw.replace('\\\\', '/')\n\n    # Reject absolute or drive-letter paths.\n    if normalized.startswith('/'):\n        raise ValueError('absolute paths are not allowed')\n    if ':' in normalized.split('/')[0]:\n        raise ValueError('drive-letter paths are not allowed')\n\n    parts = [p for p in normalized.split('/') if p not in ('', '.')]\n    if any(p == '..' for p in parts):\n        raise ValueError('parent-directory segments are not allowed')\n\n    safe_path = '/'.join(parts)\n    if safe_path == '':\n        raise ValueError('path must not resolve to the current directory only')\n\n    return safe_path",
      "weight": 4
    },
    {
      "bug_description": "빈 문자열, 공백-only 문자열, '.' 또는 './' 등이 들어와도 예외를 발생시키지 않고 빈 문자열을 그대로 반환하여 입력 검증 규칙을 위반한다.",
      "buggy_code": "from typing import Optional\n\n\ndef validate_file_path(path: Optional[str]) -> str:\n    '''Validate and normalize a user-supplied relative file path.\n\n    BUG: Allows empty, whitespace-only, or current-directory-only paths.\n    '''\n    if path is None:\n        raise ValueError('path must not be None')\n\n    if not isinstance(path, str):\n        raise TypeError('path must be a string or None')\n\n    raw = path.strip()\n    # BUG: missing check for empty raw value.\n\n    # Reject NUL and other non-printable control characters (except tab).\n    for ch in raw:\n        if ch == '\\0' or (ord(ch) < 32 and ch not in ('\\t',)):\n            raise ValueError('path contains invalid characters')\n\n    normalized = raw.replace('\\\\', '/')\n\n    if normalized.startswith('/'):\n        raise ValueError('absolute paths are not allowed')\n    if ':' in normalized.split('/')[0]:\n        raise ValueError('drive-letter paths are not allowed')\n\n    parts = [p for p in normalized.split('/') if p not in ('', '.')]\n    if any(p == '..' for p in parts):\n        raise ValueError('parent-directory segments are not allowed')\n\n    # BUG: does not reject paths that normalize to the current directory.\n    safe_path = '/'.join(parts)\n    return safe_path",
      "weight": 3
    },
    {
      "bug_description": "백슬래시를 슬래시로 정규화하지 않아 Windows 스타일 경로에서 '..' 검사가 누락되거나 반환값에 여전히 백슬래시가 포함된다.",
      "buggy_code": "from typing import Optional\n\n\ndef validate_file_path(path: Optional[str]) -> str:\n    '''Validate and normalize a user-supplied relative file path.\n\n    BUG: Does not normalize backslashes before validation.\n    This means Windows-style paths may bypass some checks and are\n    returned with backslashes instead of forward slashes.\n    '''\n    if path is None:\n        raise ValueError('path must not be None')\n\n    if not isinstance(path, str):\n        raise TypeError('path must be a string or None')\n\n    raw = path.strip()\n    if raw == '':\n        raise ValueError('path must not be empty')\n\n    for ch in raw:\n        if ch == '\\0' or (ord(ch) < 32 and ch not in ('\\t',)):\n            raise ValueError('path contains invalid characters')\n\n    # BUG: no normalization; operate directly on raw.\n    normalized = raw  # should replace backslashes with '/'\n\n    if normalized.startswith('/'):\n        raise ValueError('absolute paths are not allowed')\n    if ':' in normalized.split('/')[0]:\n        raise ValueError('drive-letter paths are not allowed')\n\n    # Here '..' only blocks segments separated by '/' but not by backslashes.\n    parts = [p for p in normalized.split('/') if p not in ('', '.')]\n    if any(p == '..' for p in parts):\n        raise ValueError('parent-directory segments are not allowed')\n\n    safe_path = '/'.join(parts) if parts else ''\n    if safe_path == '':\n        raise ValueError('path must not resolve to the current directory only')\n\n    # BUG: If original raw used backslashes, they will still appear in safe_path,\n    # breaking the normalization contract.\n    return safe_path",
      "weight": 3
    },
    {
      "bug_description": "NUL/제어 문자가 포함된 경로에서 ValueError 대신 일반 Exception을 발생시켜 잘못된 예외 타입을 사용한다.",
      "buggy_code": "from typing import Optional\n\n\ndef validate_file_path(path: Optional[str]) -> str:\n    '''Validate and normalize a user-supplied relative file path.\n\n    BUG: Raises a generic Exception instead of ValueError for invalid characters.\n    '''\n    if path is None:\n        raise ValueError('path must not be None')\n\n    if not isinstance(path, str):\n        raise TypeError('path must be a string or None')\n\n    raw = path.strip()\n    if raw == '':\n        raise ValueError('path must not be empty')\n\n    # Reject NUL and other non-printable control characters (except tab).\n    for ch in raw:\n        if ch == '\\0' or (ord(ch) < 32 and ch not in ('\\t',)):\n            # BUG: wrong exception type.\n            raise Exception('path contains invalid characters')\n\n    normalized = raw.replace('\\\\', '/')\n\n    if normalized.startswith('/'):\n        raise ValueError('absolute paths are not allowed')\n    if ':' in normalized.split('/')[0]:\n        raise ValueError('drive-letter paths are not allowed')\n\n    parts = [p for p in normalized.split('/') if p not in ('', '.')]\n    if any(p == '..' for p in parts):\n        raise ValueError('parent-directory segments are not allowed')\n\n    safe_path = '/'.join(parts)\n    if safe_path == '':\n        raise ValueError('path must not resolve to the current directory only')\n\n    return safe_path",
      "weight": 2
    }
  ],
  "description_md": "## 문제 설명\n\n사내 문서 관리 서비스에서는 API 요청으로 파일 경로 문자열을 받아, 특정 루트 디렉터리 아래에서만 파일을 읽도록 제한하고자 합니다. 이때, 실제 파일 시스템을 접근하기 전에 **경로 문자열이 안전한 형식인지**를 검증하는 함수가 필요합니다.\n\n이번 과제의 대상은 `validate_file_path` 라는 함수입니다. 이 함수는 사용자로부터 전달된 경로를 검사하고, 문제가 없으면 정규화된(relative) 경로 문자열을 반환합니다. 문제가 있는 입력일 경우에는 적절한 예외를 발생시켜 호출자에게 알립니다.\n\n### 함수 시그니처\n\n- `def validate_file_path(path: Optional[str]) -> str:`\n  - `path`: 검증할 파일 경로. `str` 또는 `None` 이 올 수 있습니다.\n  - 반환값: 유효한 경우, `/` 로 구분된 상대 경로 문자열을 반환합니다.\n  - 예외:\n    - 잘못된 입력 값에 대해서는 주로 `ValueError` 를 사용합니다.\n    - `str` 또는 `None` 이 아닌 타입에 대해서는 `TypeError` 를 사용할 수 있습니다.\n\n### 동작 규칙 (요약)\n\n아래는 함수가 만족해야 할 주요 규칙들입니다.\n\n- `None`, 빈 문자열, 공백만 있는 문자열은 허용되지 않습니다.\n- 현재 디렉터리를 가리키는 경로(예: `'.'`, `'./'`)만 들어오는 경우도 허용되지 않습니다.\n- 절대 경로(예: `'/var/log/syslog'`, `'C:...'` 로 시작하는 경로)는 허용되지 않습니다.\n- `..` 경로 조각을 사용하여 상위 디렉터리로 이동하려는 시도는 모두 거부해야 합니다.\n- 경로에 NUL 문자, 제어 문자 등 비정상 문자가 포함되어 있으면 예외를 발생시켜야 합니다.\n- 백슬래시(`\\`)는 슬래시(`/`)로 정규화된 형태로 반환되어야 합니다.\n- 이 함수는 파일의 존재 여부를 검사하지 않고, 오직 문자열 형식만을 검증합니다.\n\n### 예시\n\n- `validate_file_path(' reports/2023/summary.txt ')` → `'reports/2023/summary.txt'`\n- `validate_file_path('../secret.txt')` → `ValueError` 발생\n- `validate_file_path(None)` → `ValueError` 발생\n\n### 테스트에서 고려해야 할 사항\n\npytest 기반 테스트를 작성할 때, 특히 다음과 같은 상황들을 꼼꼼히 검증해 보세요.\n\n- `None`, 빈 문자열, 공백만 있는 문자열, `'.'`, `'./'` 등의 경계 입력 처리\n- 절대 경로(`'/tmp/file.txt'`, `'C:folder/file.txt'` 등)와 `..` 를 포함한 상대 경로 거부 여부\n- 유효하지 않은 문자(예: NUL, 제어 문자)를 포함하는 경로에 대해 올바른 예외 타입이 발생하는지\n- 정상적인 상대 경로에 대해, 백슬래시가 슬래시로 정규화되어 반환되는지\n- 예외가 발생해야 하는 상황에서 어떤 타입의 예외가 발생하는지 (`ValueError` vs 기타 예외)\n\n### 수험자가 할 일\n\n제공된 여러 버그 버전 구현들에 대해, `pytest` 를 사용하여 가능한 한 많은 버그를 검출하는 테스트 코드를 작성하세요.\n\n- 동일한 테스트 코드가 여러 구현 중 어떤 것은 통과하고, 어떤 것은 실패하도록 만드는 것이 목표입니다.\n- 특히 `error handling`과 `input validation` 관점에서 다양한 잘못된 입력 케이스를 설계해 보세요.\n",
  "initial_test_template": "import pytest\n\nfrom target import validate_file_path\n\n\ndef test_none_raises_value_error():\n    # TODO: When path is None, ValueError should be raised (error handling).\n    pass\n\n\ndef test_empty_and_whitespace_are_rejected():\n    # TODO: Validate that empty string and whitespace-only strings are rejected.\n    pass\n\n\ndef test_reject_absolute_and_parent_directory_paths():\n    # TODO: Absolute paths (starting with '/' or a drive letter like 'C:') and paths with '..' should be rejected.\n    pass\n\n\ndef test_normalizes_separators_on_valid_path():\n    # TODO: Valid relative paths using backslashes should be normalized to forward slashes.\n    pass\n",
  "tags": [
    "easy",
    "qa",
    "testing",
    "unit-test",
    "pytest",
    "error handling",
    "input validation",
    "path",
    "filesystem",
    "string"
  ],
  "difficulty": "Easy"
}