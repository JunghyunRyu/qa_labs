{
  "title": "섭씨·화씨 변환 함수 정밀도 및 경계값 테스트",
  "function_signature": "def convert_temperature(value: float, unit: str) -> float:",
  "golden_code": "def convert_temperature(value: float, unit: str) -> float:\n    \"\"\"Convert temperature between Celsius and Fahrenheit with fixed precision.\n\n    This function converts a temperature reading between Celsius (\"C\") and\n    Fahrenheit (\"F\"). It is intended for use in a monitoring/alerting service\n    where consistent rounding and numeric accuracy are critical.\n\n    Rules:\n    - unit must be either \"C\" or \"F\" (case-insensitive). Any other value\n      raises a ValueError.\n    - If unit == \"C\": `value` is interpreted as Celsius and converted to\n      Fahrenheit.\n      Formula: F = value * 9/5 + 32\n    - If unit == \"F\": `value` is interpreted as Fahrenheit and converted to\n      Celsius.\n      Formula: C = (value - 32) * 5/9\n    - The result is rounded to **two decimal places** using Python's built-in\n      round() semantics (banker's rounding).\n\n    Special/edge cases to be aware of:\n    - Exact physical reference points like:\n      * -40.0 C == -40.0 F\n      * 0.0 C == 32.0 F\n      * 100.0 C == 212.0 F\n    - Very large magnitude temperatures (stress for floating point range),\n      but still within typical float range, e.g. +/- 1e6.\n    - Very small fractional values where representation and rounding matter,\n      e.g. 0.1, 0.2, 0.05, 0.005.\n\n    Parameters\n    ----------\n    value : float\n        Temperature value to convert.\n    unit : str\n        The unit of the input value. \"C\" for Celsius, \"F\" for Fahrenheit.\n\n    Returns\n    -------\n    float\n        Converted temperature rounded to two decimal places.\n\n    Raises\n    ------\n    ValueError\n        If `unit` is not \"C\" or \"F\" (case-insensitive).\n    \"\"\"\n\n    if not isinstance(unit, str):\n        raise ValueError(\"unit must be 'C' or 'F'\")\n\n    normalized = unit.upper()\n    if normalized == \"C\":\n        # C -> F\n        result = value * 9.0 / 5.0 + 32.0\n    elif normalized == \"F\":\n        # F -> C\n        result = (value - 32.0) * 5.0 / 9.0\n    else:\n        raise ValueError(\"unit must be 'C' or 'F'\")\n\n    # Fixed precision to 2 decimal places; this is part of the contract.\n    return round(result, 2)\n",
  "buggy_implementations": [
    {
      "bug_description": "C->F 변환 시 9/5 대신 5/9를 사용하여 결과가 0도 주변과 큰 값에서 모두 잘못됨. 특히 0°C, 100°C 같은 기준점이 틀어지며, F->C는 정상이라 단위별 경계 테스트 필요.",
      "buggy_code": "def convert_temperature(value: float, unit: str) -> float:\n    \"\"\"Buggy: uses wrong factor for C->F conversion (5/9 instead of 9/5).\"\"\"\n\n    if not isinstance(unit, str):\n        raise ValueError(\"unit must be 'C' or 'F'\")\n\n    normalized = unit.upper()\n    if normalized == \"C\":\n        # BUG: wrong factor, should be 9/5\n        result = value * 5.0 / 9.0 + 32.0\n    elif normalized == \"F\":\n        # Correct F -> C\n        result = (value - 32.0) * 5.0 / 9.0\n    else:\n        raise ValueError(\"unit must be 'C' or 'F'\")\n\n    return round(result, 2)\n",
      "weight": 5
    },
    {
      "bug_description": "반올림을 하지 않고 원시 부동소수점 값을 그대로 반환. 0.1, 0.2 같은 값이나 100°C → 212°F 같은 경우 이론값과 float 표현의 미세 오차로 인해 소수점 아래 긴 값이 나와 정밀도/반올림 테스트에서 드러남.",
      "buggy_code": "def convert_temperature(value: float, unit: str) -> float:\n    \"\"\"Buggy: does not apply the required 2-decimal rounding.\"\"\"\n\n    if not isinstance(unit, str):\n        raise ValueError(\"unit must be 'C' or 'F'\")\n\n    normalized = unit.upper()\n    if normalized == \"C\":\n        result = value * 9.0 / 5.0 + 32.0\n    elif normalized == \"F\":\n        result = (value - 32.0) * 5.0 / 9.0\n    else:\n        raise ValueError(\"unit must be 'C' or 'F'\")\n\n    # BUG: missing rounding to 2 decimal places\n    return float(result)\n",
      "weight": 4
    },
    {
      "bug_description": "단위 문자열을 대소문자 구분하여 처리해 'c', 'f' 등 소문자 입력이 모두 ValueError를 발생시킴. 경계값/유효단위 파티션 테스트에서 드러남.",
      "buggy_code": "def convert_temperature(value: float, unit: str) -> float:\n    \"\"\"Buggy: unit is case-sensitive, only 'C' and 'F' accepted.\"\"\"\n\n    if not isinstance(unit, str):\n        raise ValueError(\"unit must be 'C' or 'F'\")\n\n    # BUG: no normalization, case-sensitive comparison\n    if unit == \"C\":\n        result = value * 9.0 / 5.0 + 32.0\n    elif unit == \"F\":\n        result = (value - 32.0) * 5.0 / 9.0\n    else:\n        raise ValueError(\"unit must be 'C' or 'F'\")\n\n    return round(result, 2)\n",
      "weight": 3
    },
    {
      "bug_description": "극단적인 큰 값에서 오버플로우를 피하기 위해 임의로 1e4보다 큰 입력을 잘라(clamp) 버림. 1e5, 1e6 등 큰 값 경계 테스트에서 결과가 비정상적으로 작아짐.",
      "buggy_code": "def convert_temperature(value: float, unit: str) -> float:\n    \"\"\"Buggy: clamps large magnitude values instead of converting them accurately.\"\"\"\n\n    if not isinstance(unit, str):\n        raise ValueError(\"unit must be 'C' or 'F'\")\n\n    normalized = unit.upper()\n\n    # BUG: arbitrary clamping of input magnitude\n    if value > 1e4:\n        value = 1e4\n    elif value < -1e4:\n        value = -1e4\n\n    if normalized == \"C\":\n        result = value * 9.0 / 5.0 + 32.0\n    elif normalized == \"F\":\n        result = (value - 32.0) * 5.0 / 9.0\n    else:\n        raise ValueError(\"unit must be 'C' or 'F'\")\n\n    return round(result, 2)\n",
      "weight": 4
    },
    {
      "bug_description": "round(…, 1)만 수행한 뒤 문자열 포맷으로 두 자리처럼 보이도록 처리하고 다시 float으로 변환. 0.005°C 같은 미세 경계에서 2자리 반올림이 아닌 1자리 반올림이 적용되어 numeric accuracy가 깨짐.",
      "buggy_code": "def convert_temperature(value: float, unit: str) -> float:\n    \"\"\"Buggy: effectively rounds to 1 decimal then pads formatting to 2 decimals.\"\"\"\n\n    if not isinstance(unit, str):\n        raise ValueError(\"unit must be 'C' or 'F'\")\n\n    normalized = unit.upper()\n    if normalized == \"C\":\n        result = value * 9.0 / 5.0 + 32.0\n    elif normalized == \"F\":\n        result = (value - 32.0) * 5.0 / 9.0\n    else:\n        raise ValueError(\"unit must be 'C' or 'F'\")\n\n    # BUG: round to 1 decimal, then format to 2 decimals as string\n    one_dec = round(result, 1)\n    formatted = f\"{one_dec:.2f}\"  # looks like 2 decimals but value is already rounded to 1\n    return float(formatted)\n",
      "weight": 3
    }
  ],
  "description_md": "## 문제 설명\n\n한 IoT 기반 온도 모니터링 서비스에서, 센서로부터 받은 섭씨/화씨 온도를 서로 변환해 저장하고 알림 임계값을 비교하는 공통 유틸리티 함수가 있습니다. 이 함수는 다양한 장치·지역에서 들어오는 데이터를 다루기 때문에, **부동소수점 정밀도**, **경계값 부근의 정확한 변환**, **일관된 반올림 규칙**이 매우 중요합니다.\n\n당신의 역할은 이 변환 함수에 대해 `pytest` 기반 단위 테스트를 작성하여, 숨겨진 버그 구현들을 최대한 많이 탐지하는 것입니다.\n\n### 함수 동작\n\n```python\nconvert_temperature(value: float, unit: str) -> float\n```\n\n- `value`: 입력 온도 값 (부동소수점)\n- `unit`: 입력 온도의 단위\n  - `\"C\"` : 섭씨(Celsius)로 들어온 값을 화씨(Fahrenheit)로 변환\n  - `\"F\"` : 화씨(Fahrenheit)로 들어온 값을 섭씨(Celsius)로 변환\n  - 대소문자 구분 없이 처리하는 것이 의도입니다.\n- 반환값: 변환된 온도 값 (`float`), **소수점 둘째 자리까지** 반올림된 값\n- 잘못된 단위 문자열에 대해서는 `ValueError`를 발생시키는 것이 의도입니다.\n\n사용되는 공식은 다음과 같습니다.\n- 섭씨 → 화씨: `F = C * 9/5 + 32`\n- 화씨 → 섭씨: `C = (F - 32) * 5/9`\n\n### 예시\n\n아래는 의도된 정상 동작의 일부 예시입니다.\n\n- `convert_temperature(0.0, \"C\")` → `32.00`\n- `convert_temperature(100.0, \"C\")` → `212.00`\n- `convert_temperature(32.0, \"F\")` → `0.00`\n- `convert_temperature(-40.0, \"C\")` → `-40.00`  (섭씨/화씨가 일치하는 특이점)\n\n반환값은 항상 소수점 둘째 자리까지 반올림된 값이어야 합니다 (예: `21.37`, `-5.10` 등).\n\n### 테스트에서 고려해야 할 포인트\n\n이 문제는 다음과 같은 테스트 역량을 평가하기 위해 설계되었습니다.\n\n- **floating point precision**: \n  - 이론상 간단한 값이라도 부동소수점 표현 때문에 미묘한 오차가 생길 수 있습니다.\n  - `0.1`, `0.2`, 매우 작은 분수, `0.05`, `0.005` 등에서 반올림 결과가 정확한지 검증해 보세요.\n\n- **boundary analysis (경계값 분석)**:\n  - 물리적으로 중요한 기준점: `-40`, `0`, `32`, `100`, `212` 등\n  - 매우 큰 값, 매우 작은 값(절대값 기준) 같은 수치적인 극단값: 예를 들어 `1e4`, `1e5`, `1e6`, `-1e6` 등\n  - 단위 문자열의 경계: 올바른 단위(`\"C\"`, `\"F\"`)와 잘못된 단위의 구분, 대소문자(`\"c\"`, `\"f\"`) 처리\n\n- **numeric accuracy (수치 정확성)**:\n  - 공식이 정확하게 구현되었는지 (예: `9/5` vs `5/9` 혼동 여부)\n  - 반올림이 올바르게 적용되는지 (정말로 \"둘째 자리\"까지인지, 1자리만 반올림하는지 등)\n  - 극값 근처에서 임의의 잘림(clamp)이나 왜곡이 없는지\n\n### 당신이 해야 할 일\n\n1. 제공된 `convert_temperature` 함수에 대해, `pytest`를 사용하여 테스트 코드를 작성하세요.\n2. 다양한 입력 파티션과 경계값을 커버해야 합니다.\n   - 섭씨→화씨, 화씨→섭씨 모두에 대해 대표값과 경계값을 선택\n   - 극단적인 크기의 입력 값(아주 크거나 아주 작은 값)\n   - 반올림 경계에 걸리는 값 (예: 소수점 셋째 자리에서 올림/버림이 갈리는 값)\n   - 정상 단위와 비정상 단위, 대소문자 변 variations\n3. 정답(golden) 구현과 여러 개의 버그 구현이 동일한 인터페이스로 준비되어 있으며, \n   당신의 테스트는 이 중 어떤 구현이 주어지더라도 버그를 최대한 많이 드러내야 합니다.\n4. `pytest`의 다양한 기능(파라미터화, approx 비교 등)을 적절히 활용하여, \n   부동소수점 정밀도와 경계값을 엄격하게 검증하는 테스트를 설계해 보세요.\n\n정확한 구현을 가정하고 하드코딩된 기대값을 비교하는 테스트를 작성하되, \n부동소수점 비교 시에는 적절한 허용 오차 또는 소수 자릿수 기반 비교를 사용할 수 있습니다. (단, 함수 계약상 \"둘째 자리까지 반올림\"이라는 점을 활용할 수 있습니다.)\n\n이 문제의 목표는 단순한 값 몇 개를 확인하는 것이 아니라, \n**정밀도, 경계, 수치적 안정성**을 종합적으로 고려한 테스트 설계를 연습하는 것입니다.\n",
  "initial_test_template": "import pytest\nfrom target import convert_temperature\n\n\n# 힌트: 정확한 수학적 기대값을 사용해 대표적인 기준점(0°C, 100°C, -40°C 등)을 검증해 보세요.\ndef test_reference_points_c_to_f():\n    # TODO: 0°C -> 32.00°F, 100°C -> 212.00°F, -40°C -> -40.00°F 등을 검증\n    # 부동소수점 비교 시 pytest.approx 또는 소수 둘째 자리까지의 비교를 고려하세요.\n    pass\n\n\ndef test_reference_points_f_to_c():\n    # TODO: 32°F -> 0.00°C, 212°F -> 100.00°C, -40°F -> -40.00°C 등을 검증\n    pass\n\n\n# 힌트: 반올림 경계(소수점 셋째 자리에서 올림/버림이 갈리는 값)를 집중적으로 테스트하세요.\n@pytest.mark.parametrize(\n    \"value, unit\",\n    [\n        # TODO: 0.005, 0.0049, 0.0051 등과 같이 반올림 결과가 달라지는 입력 추가\n        # 예: (0.005, \"C\"), (0.005, \"F\"), ...\n    ],\n)\ndef test_rounding_boundaries(value, unit):\n    # TODO: 소수 둘째 자리 반올림이 정확히 동작하는지 확인\n    pass\n\n\n# 힌트: 매우 큰 값/작은 값, 단위 문자열의 대소문자 및 잘못된 단위를 포함해 경계값을 설계하세요.\ndef test_extreme_and_invalid_inputs():\n    # TODO: 1e5, -1e6 같은 극단적인 값에서 결과가 비정상적으로 잘리지(clamp) 않는지 확인\n    # TODO: 'c', 'f', 'X', '', None 등을 단위로 넣었을 때의 동작/예외를 검증\n    pass\n",
  "tags": [
    "hard",
    "floating point precision",
    "boundary analysis",
    "numeric accuracy",
    "unit-test",
    "temperature",
    "math"
  ],
  "difficulty": "Hard",
  "strong_test_code": "import pytest\nfrom target import convert_temperature\n\n\ndef test_reference_points_c_to_f():\n    # 기준점 - 변환 공식 버그 잡기\n    assert convert_temperature(0.0, 'C') == 32.00\n    assert convert_temperature(100.0, 'C') == 212.00\n    assert convert_temperature(-40.0, 'C') == -40.00\n\n\ndef test_reference_points_f_to_c():\n    assert convert_temperature(32.0, 'F') == 0.00\n    assert convert_temperature(212.0, 'F') == 100.00\n    assert convert_temperature(-40.0, 'F') == -40.00\n\n\ndef test_case_insensitive_unit():\n    # 대소문자 구분 버그 잡기\n    assert convert_temperature(0.0, 'c') == 32.00\n    assert convert_temperature(0.0, 'C') == 32.00\n    assert convert_temperature(32.0, 'f') == 0.00\n    assert convert_temperature(32.0, 'F') == 0.00\n\n\ndef test_rounding_to_two_decimals():\n    # 반올림 버그 잡기\n    # 37°C -> 98.6°F\n    result = convert_temperature(37.0, 'C')\n    assert result == 98.60\n    # 소수점 셋째 자리에서 반올림 확인\n    result2 = convert_temperature(37.777, 'C')\n    assert isinstance(result2, float)\n    assert round(result2, 2) == result2  # 이미 2자리로 반올림되어야 함\n\n\ndef test_extreme_large_values_not_clamped():\n    # 큰 값 클램핑 버그 잡기\n    result = convert_temperature(1e5, 'C')\n    expected = round(1e5 * 9.0/5.0 + 32.0, 2)\n    assert result == expected\n    \n    result2 = convert_temperature(-1e6, 'C')\n    expected2 = round(-1e6 * 9.0/5.0 + 32.0, 2)\n    assert result2 == expected2\n\n\ndef test_invalid_unit_raises_error():\n    with pytest.raises(ValueError):\n        convert_temperature(0.0, 'X')\n    with pytest.raises(ValueError):\n        convert_temperature(0.0, '')\n"
}