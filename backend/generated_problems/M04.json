{
  "title": "API 응답 JSON 구조 검증 함수 테스트",
  "function_signature": "def validate_api_response(response: dict) -> dict:",
  "golden_code": "from typing import Any, Dict\n\n\ndef validate_api_response(response: dict) -> dict:\n    \"\"\"Validate a typical API response JSON structure.\n\n    Expected structure:\n    - response: dict with keys {\"status\", \"data\", \"error\"} only.\n    - status: str, one of {\"success\", \"error\"}.\n    - For status == \"success\":\n        - error must be None.\n        - data must be a dict (can be empty dict).\n    - For status == \"error\":\n        - error must be a non-empty string.\n        - data must be None.\n\n    The function returns a *normalized* copy of the response:\n    - Extra keys are not allowed.\n    - Missing keys or wrong types raise ValueError.\n    - It does not mutate the input `response`.\n\n    Args:\n        response: Parsed JSON object (Python dict) representing an API response.\n\n    Returns:\n        A new dict with keys \"status\", \"data\", and \"error\" that passed validation.\n\n    Raises:\n        TypeError: If `response` is not a dict.\n        ValueError: If required keys are missing, types are wrong, or\n                    status/data/error combination is invalid.\n    \"\"\"\n    if not isinstance(response, dict):\n        raise TypeError(\"response must be a dict\")\n\n    expected_keys = {\"status\", \"data\", \"error\"}\n    keys = set(response.keys())\n\n    missing = expected_keys - keys\n    extra = keys - expected_keys\n    if missing:\n        raise ValueError(f\"missing keys: {sorted(missing)}\")\n    if extra:\n        raise ValueError(f\"unexpected keys: {sorted(extra)}\")\n\n    status = response.get(\"status\")\n    data = response.get(\"data\")\n    error = response.get(\"error\")\n\n    if not isinstance(status, str):\n        raise ValueError(\"status must be a string\")\n    if status not in {\"success\", \"error\"}:\n        raise ValueError(\"status must be either 'success' or 'error'\")\n\n    if status == \"success\":\n        if error is not None:\n            raise ValueError(\"error must be None when status is 'success'\")\n        if not isinstance(data, dict):\n            raise ValueError(\"data must be a dict when status is 'success'\")\n    else:  # status == \"error\"\n        if data is not None:\n            raise ValueError(\"data must be None when status is 'error'\")\n        if not isinstance(error, str) or not error.strip():\n            raise ValueError(\"error must be a non-empty string when status is 'error'\")\n\n    # Return a normalized copy to avoid mutating caller's dict\n    return {\"status\": status, \"data\": data, \"error\": error}\n",
  "buggy_implementations": [
    {
      "bug_description": "status가 'success' 또는 'error'가 아닌 임의의 문자열도 허용하는 버그. API validation에서 허용되지 않은 상태값을 잡지 못함.",
      "buggy_code": "from typing import Any, Dict\n\n\ndef validate_api_response(response: dict) -> dict:\n    if not isinstance(response, dict):\n        raise TypeError(\"response must be a dict\")\n\n    expected_keys = {\"status\", \"data\", \"error\"}\n    keys = set(response.keys())\n\n    missing = expected_keys - keys\n    extra = keys - expected_keys\n    if missing:\n        raise ValueError(f\"missing keys: {sorted(missing)}\")\n    if extra:\n        raise ValueError(f\"unexpected keys: {sorted(extra)}\")\n\n    status = response.get(\"status\")\n    data = response.get(\"data\")\n    error = response.get(\"error\")\n\n    # BUG: only check that status is a string, but do NOT restrict allowed values\n    if not isinstance(status, str):\n        raise ValueError(\"status must be a string\")\n\n    if status == \"success\":\n        if error is not None:\n            raise ValueError(\"error must be None when status is 'success'\")\n        if not isinstance(data, dict):\n            raise ValueError(\"data must be a dict when status is 'success'\")\n    else:  # any non-success treated as error\n        if data is not None:\n            raise ValueError(\"data must be None when status is 'error'\")\n        if not isinstance(error, str) or not error.strip():\n            raise ValueError(\"error must be a non-empty string when status is 'error'\")\n\n    return {\"status\": status, \"data\": data, \"error\": error}\n",
      "weight": 4
    },
    {
      "bug_description": "status='success'일 때 data가 dict가 아니라 list나 다른 타입이어도 허용하는 버그. JSON 구조 검증이 느슨함.",
      "buggy_code": "from typing import Any, Dict\n\n\ndef validate_api_response(response: dict) -> dict:\n    if not isinstance(response, dict):\n        raise TypeError(\"response must be a dict\")\n\n    expected_keys = {\"status\", \"data\", \"error\"}\n    keys = set(response.keys())\n\n    missing = expected_keys - keys\n    extra = keys - expected_keys\n    if missing:\n        raise ValueError(f\"missing keys: {sorted(missing)}\")\n    if extra:\n        raise ValueError(f\"unexpected keys: {sorted(extra)}\")\n\n    status = response.get(\"status\")\n    data = response.get(\"data\")\n    error = response.get(\"error\")\n\n    if not isinstance(status, str):\n        raise ValueError(\"status must be a string\")\n    if status not in {\"success\", \"error\"}:\n        raise ValueError(\"status must be either 'success' or 'error'\")\n\n    if status == \"success\":\n        if error is not None:\n            raise ValueError(\"error must be None when status is 'success'\")\n        # BUG: allow any non-None data, should require dict\n        if data is None:\n            raise ValueError(\"data must not be None when status is 'success'\")\n    else:\n        if data is not None:\n            raise ValueError(\"data must be None when status is 'error'\")\n        if not isinstance(error, str) or not error.strip():\n            raise ValueError(\"error must be a non-empty string when status is 'error'\")\n\n    return {\"status\": status, \"data\": data, \"error\": error}\n",
      "weight": 3
    },
    {
      "bug_description": "status='error'일 때 error가 빈 문자열이어도 통과시키는 버그. 에러 메시지 필드를 제대로 검증하지 못함.",
      "buggy_code": "from typing import Any, Dict\n\n\ndef validate_api_response(response: dict) -> dict:\n    if not isinstance(response, dict):\n        raise TypeError(\"response must be a dict\")\n\n    expected_keys = {\"status\", \"data\", \"error\"}\n    keys = set(response.keys())\n\n    missing = expected_keys - keys\n    extra = keys - expected_keys\n    if missing:\n        raise ValueError(f\"missing keys: {sorted(missing)}\")\n    if extra:\n        raise ValueError(f\"unexpected keys: {sorted(extra)}\")\n\n    status = response.get(\"status\")\n    data = response.get(\"data\")\n    error = response.get(\"error\")\n\n    if not isinstance(status, str):\n        raise ValueError(\"status must be a string\")\n    if status not in {\"success\", \"error\"}:\n        raise ValueError(\"status must be either 'success' or 'error'\")\n\n    if status == \"success\":\n        if error is not None:\n            raise ValueError(\"error must be None when status is 'success'\")\n        if not isinstance(data, dict):\n            raise ValueError(\"data must be a dict when status is 'success'\")\n    else:\n        if data is not None:\n            raise ValueError(\"data must be None when status is 'error'\")\n        # BUG: only check type, not emptiness\n        if not isinstance(error, str):\n            raise ValueError(\"error must be a string when status is 'error'\")\n\n    return {\"status\": status, \"data\": data, \"error\": error}\n",
      "weight": 3
    },
    {
      "bug_description": "추가 필드를 허용하는 버그. status, data, error 외의 키가 있어도 에러가 발생하지 않아, JSON 구조 제약을 위반.",
      "buggy_code": "from typing import Any, Dict\n\n\ndef validate_api_response(response: dict) -> dict:\n    if not isinstance(response, dict):\n        raise TypeError(\"response must be a dict\")\n\n    expected_keys = {\"status\", \"data\", \"error\"}\n    keys = set(response.keys())\n\n    missing = expected_keys - keys\n    # BUG: ignore extra keys entirely\n    if missing:\n        raise ValueError(f\"missing keys: {sorted(missing)}\")\n\n    status = response.get(\"status\")\n    data = response.get(\"data\")\n    error = response.get(\"error\")\n\n    if not isinstance(status, str):\n        raise ValueError(\"status must be a string\")\n    if status not in {\"success\", \"error\"}:\n        raise ValueError(\"status must be either 'success' or 'error'\")\n\n    if status == \"success\":\n        if error is not None:\n            raise ValueError(\"error must be None when status is 'success'\")\n        if not isinstance(data, dict):\n            raise ValueError(\"data must be a dict when status is 'success'\")\n    else:\n        if data is not None:\n            raise ValueError(\"data must be None when status is 'error'\")\n        if not isinstance(error, str) or not error.strip():\n            raise ValueError(\"error must be a non-empty string when status is 'error'\")\n\n    # BUG: return original dict, including extra keys, not a normalized copy\n    return response\n",
      "weight": 4
    }
  ],
  "description_md": "## 문제 설명\n\n어떤 서비스에서는 모든 HTTP API 응답을 공통 JSON 포맷으로 내려줍니다. 프론트엔드/클라이언트는 이 JSON 구조를 전제로 동작하기 때문에, 백엔드에서 구조가 조금만 틀어져도 치명적인 버그가 발생할 수 있습니다.\n\n이번 과제에서는 `status`, `data`, `error` 세 필드를 가진 API 응답 딕셔너리를 검증하는 `validate_api_response` 함수를 테스트해야 합니다. 이 함수는 파이썬에서 이미 JSON을 파싱한 후의 `dict`를 입력으로 받아, 구조와 값의 조합을 검증하고, 유효한 경우 정규화된 딕셔너리를 반환합니다.\n\n### 함수 동작\n\n```python\nvalidate_api_response(response: dict) -> dict\n```\n\n- 입력(`response`)\n  - 파싱된 JSON 객체(파이썬 dict)\n  - 반드시 `status`, `data`, `error` 세 키를 **모두** 가져야 하며, 다른 키는 허용되지 않습니다.\n- 필드 규칙\n  - `status`: 문자열, `\"success\"` 또는 `\"error\"` 중 하나여야 합니다.\n  - `status == \"success\"` 인 경우\n    - `data`: dict 타입 (내용은 자유, 비어 있어도 됨)\n    - `error`: 반드시 `None`\n  - `status == \"error\"` 인 경우\n    - `data`: 반드시 `None`\n    - `error`: 공백이 아닌(non-empty) 에러 메시지 문자열\n- 반환값\n  - 위 조건을 통과한 경우, `{\"status\": ..., \"data\": ..., \"error\": ...}` 형태의 **새로운 dict** 를 반환합니다.\n- 예외\n  - `response`가 dict가 아닌 경우: `TypeError`\n  - 필수 키 누락, 불필요한 키 포함, 타입 불일치, 필드 조합이 규칙에 맞지 않는 경우: `ValueError`\n\n### 정상 동작 예시\n\n```python\n# 성공 응답 예시\nvalidate_api_response({\n    \"status\": \"success\",\n    \"data\": {\"user_id\": 1},\n    \"error\": None,\n})\n# => {\"status\": \"success\", \"data\": {\"user_id\": 1}, \"error\": None}\n\n# 실패 응답 예시\nvalidate_api_response({\n    \"status\": \"error\",\n    \"data\": None,\n    \"error\": \"INVALID_TOKEN\",\n})\n# => {\"status\": \"error\", \"data\": None, \"error\": \"INVALID_TOKEN\"}\n```\n\n### 테스트에서 고려해야 할 점 (힌트)\n\n다음과 같은 다양한 상황에 대해 API 응답 검증이 올바르게 이루어지는지 테스트해 보세요.\n\n- `status` 값이 허용된 값인지, 문자열이 아닌 값은 어떻게 처리되는지\n- `status == \"success\"`일 때와 `status == \"error\"`일 때 `data` / `error` 필드의 **타입**과 **값 조합**\n  - 예: 성공인데 `error`에 문자열이 들어온 경우, 실패인데 `data`에 dict가 들어온 경우 등\n- `error` 메시지가 비어 있거나 공백뿐인 문자열일 때 처리\n- 반드시 필요한 키가 누락되었을 때, 혹은 정의되지 않은 추가 키가 포함되었을 때의 동작\n- 반환된 딕셔너리가 입력 딕셔너리와 독립적인지(불필요한 키가 포함되지 않는지 등)\n\n이 문제는 API validation, JSON 구조 검증, 응답 처리 로직을 이해하고 테스트하는 능력을 평가하기 위한 것입니다.\n\n### 수험자가 할 일\n\n- 제공된 `validate_api_response` 함수에 대해 **pytest 기반의 테스트 코드**를 작성하십시오.\n- 다양한 정상/비정상 API 응답 케이스를 설계하여, 포함된 여러 buggy 구현들이 최대한 많이 실패하도록 만드세요.\n- 단순한 해피 패스뿐 아니라, 구조/타입/값 조합과 관련된 여러 에러 상황도 충분히 테스트하는 것이 중요합니다.\n",
  "initial_test_template": "import pytest\nfrom target import validate_api_response\n\n\n# 기본 성공/실패 시나리오를 검증하는 테스트\n# - 올바른 success, error 응답에서 예외가 나지 않고 dict가 반환되는지 확인\n# - 반환된 dict 구조(status, data, error)와 값이 기대와 일치하는지 확인\n\ndef test_valid_success_and_error_responses():\n    pass\n\n\n# JSON 구조(키 세트)를 검증하는 테스트\n# - status/data/error 중 하나라도 누락되면 ValueError가 발생해야 함\n# - status/data/error 외의 키가 추가되면 ValueError가 발생해야 함\n\ndef test_missing_and_extra_keys_structure_validation():\n    pass\n\n\n# 필드 값 조합 및 타입을 검증하는 테스트\n# - status 값이 허용되지 않은 문자열/타입일 때\n# - success인데 error가 None이 아니거나 data 타입이 dict가 아닌 경우\n# - error인데 error 메시지가 비어 있거나 data가 None이 아닌 경우\n\ndef test_field_combinations_and_types():\n    pass\n\n\n# 응답 정규화/불변성 관련 테스트(선택 사항)\n# - 반환된 dict가 입력 dict를 그대로 참조하지 않는지 (deep copy 수준까지는 아니어도 키/값 세트 검증)\n# - extra 필드가 반환값에 포함되지 않는지 확인\n\ndef test_response_normalization_and_no_extra_keys():\n    pass\n",
  "tags": [
    "medium",
    "qa",
    "testing",
    "unit-test",
    "api",
    "json",
    "response-handling",
    "api validation"
  ],
  "difficulty": "Medium"
}