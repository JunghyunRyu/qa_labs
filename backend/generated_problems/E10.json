{
  "title": "전화번호 정규화 함수 테스트",
  "function_signature": "def normalize_us_phone(phone: str) -> str:",
  "golden_code": "def normalize_us_phone(phone: str) -> str:\n    '''Normalize a US phone number string to the format '+1-AAA-BBB-CCCC'.\n\n    The function accepts common user-entered formats and returns a\n    canonical, country-code-prefixed representation.\n\n    Accepted inputs:\n    - 10 digits: interpreted as a US national number (area + local)\n    - 11 digits starting with '1': interpreted as US number with country code\n    - Optional leading '+1' country code\n    - Non-digit separators such as spaces, dashes, dots, and parentheses\n      may appear anywhere and are ignored.\n\n    Rules:\n    - Only country code 1 (US/Canada) is supported. Any other country\n      code (e.g. '+44') raises ValueError.\n    - If the resulting digits do not contain exactly 10 or 11 digits\n      in the supported formats, ValueError is raised.\n\n    Parameters\n    ----------\n    phone: str\n        Raw phone number string entered by a user.\n\n    Returns\n    -------\n    str\n        Normalized phone number in the form '+1-AAA-BBB-CCCC'.\n    '''\n    if not isinstance(phone, str):\n        raise TypeError(\"phone must be a string\")\n\n    raw = phone.strip()\n    if not raw:\n        raise ValueError(\"phone number is empty\")\n\n    has_plus = raw.startswith(\"+\")\n\n    # Keep only digits; plus sign is handled via has_plus flag.\n    digits = \"\".join(ch for ch in raw if ch.isdigit())\n\n    if has_plus:\n        # With a plus sign we only support +1 ...\n        if not digits.startswith(\"1\"):\n            raise ValueError(\"only +1 country code is supported\")\n\n    if len(digits) == 10:\n        # Local US number without explicit country code.\n        national = digits\n    elif len(digits) == 11 and digits[0] == \"1\":\n        # Strip leading country code 1.\n        national = digits[1:]\n    else:\n        raise ValueError(\"invalid phone number length or format\")\n\n    area = national[0:3]\n    prefix = national[3:6]\n    line = national[6:10]\n\n    return f\"+1-{area}-{prefix}-{line}\"\n",
  "buggy_implementations": [
    {
      "bug_description": "유효한 11자리 미국 번호(예: '1-555-123-4567', '+1 (555) 123-4567')를 잘못된 길이로 판단하여 ValueError를 발생시킨다.",
      "buggy_code": "def normalize_us_phone(phone: str) -> str:\n    '''Normalize a US phone number string to the format '+1-AAA-BBB-CCCC'.\n\n    This buggy version incorrectly rejects valid numbers that include\n    a leading US country code '1'.\n    '''\n    if not isinstance(phone, str):\n        raise TypeError(\"phone must be a string\")\n\n    raw = phone.strip()\n    if not raw:\n        raise ValueError(\"phone number is empty\")\n\n    has_plus = raw.startswith(\"+\")\n\n    digits = \"\".join(ch for ch in raw if ch.isdigit())\n\n    if has_plus and not digits.startswith(\"1\"):\n        raise ValueError(\"only +1 country code is supported\")\n\n    # BUG: accepts only 10 digits and rejects valid 11-digit numbers with leading '1'\n    if len(digits) != 10:\n        raise ValueError(\"invalid phone number length or format\")\n\n    national = digits\n    area = national[0:3]\n    prefix = national[3:6]\n    line = national[6:10]\n\n    return f\"+1-{area}-{prefix}-{line}\"\n",
      "weight": 4
    },
    {
      "bug_description": "앞에 '+'가 붙은 번호에서 국가 코드를 검증하지 않아 '+2 (555) 123-4567' 같은 미국 이외 번호도 '+1-555-123-4567'로 잘못 정상 처리한다.",
      "buggy_code": "def normalize_us_phone(phone: str) -> str:\n    '''Normalize a US phone number string to the format '+1-AAA-BBB-CCCC'.\n\n    This buggy version fails to validate the country code when a leading\n    '+' is present.\n    '''\n    if not isinstance(phone, str):\n        raise TypeError(\"phone must be a string\")\n\n    raw = phone.strip()\n    if not raw:\n        raise ValueError(\"phone number is empty\")\n\n    has_plus = raw.startswith(\"+\")\n\n    digits = \"\".join(ch for ch in raw if ch.isdigit())\n\n    # BUG: if a plus is present, the country code is never checked.\n    # Numbers like '+2 (555) 123-4567' are incorrectly accepted.\n    if len(digits) == 10:\n        national = digits\n    elif len(digits) == 11:\n        # BUG: blindly drop the first digit as if it were always country code '1'\n        national = digits[1:]\n    else:\n        raise ValueError(\"invalid phone number length or format\")\n\n    area = national[0:3]\n    prefix = national[3:6]\n    line = national[6:10]\n\n    return f\"+1-{area}-{prefix}-{line}\"\n",
      "weight": 3
    },
    {
      "bug_description": "출력 포맷에서 '+' 기호를 누락하여 '1-AAA-BBB-CCCC' 형태로 반환한다.",
      "buggy_code": "def normalize_us_phone(phone: str) -> str:\n    '''Normalize a US phone number string to the format '+1-AAA-BBB-CCCC'.\n\n    This buggy version formats the output without the leading '+',\n    returning '1-AAA-BBB-CCCC' instead.\n    '''\n    if not isinstance(phone, str):\n        raise TypeError(\"phone must be a string\")\n\n    raw = phone.strip()\n    if not raw:\n        raise ValueError(\"phone number is empty\")\n\n    has_plus = raw.startswith(\"+\")\n\n    digits = \"\".join(ch for ch in raw if ch.isdigit())\n\n    if has_plus:\n        if not digits.startswith(\"1\"):\n            raise ValueError(\"only +1 country code is supported\")\n\n    if len(digits) == 10:\n        national = digits\n    elif len(digits) == 11 and digits[0] == \"1\":\n        national = digits[1:]\n    else:\n        raise ValueError(\"invalid phone number length or format\")\n\n    area = national[0:3]\n    prefix = national[3:6]\n    line = national[6:10]\n\n    # BUG: missing '+' in the formatted output\n    return f\"1-{area}-{prefix}-{line}\"\n",
      "weight": 3
    },
    {
      "bug_description": "자릿수 그룹을 잘못 나누어 지역번호를 3자리 대신 2자리로, 끝번호를 4자리 대신 5자리로 포맷팅한다.",
      "buggy_code": "def normalize_us_phone(phone: str) -> str:\n    '''Normalize a US phone number string to the format '+1-AAA-BBB-CCCC'.\n\n    This buggy version mis-groups the digits when formatting the\n    national number.\n    '''\n    if not isinstance(phone, str):\n        raise TypeError(\"phone must be a string\")\n\n    raw = phone.strip()\n    if not raw:\n        raise ValueError(\"phone number is empty\")\n\n    has_plus = raw.startswith(\"+\")\n\n    digits = \"\".join(ch for ch in raw if ch.isdigit())\n\n    if has_plus:\n        if not digits.startswith(\"1\"):\n            raise ValueError(\"only +1 country code is supported\")\n\n    if len(digits) == 10:\n        national = digits\n    elif len(digits) == 11 and digits[0] == \"1\":\n        national = digits[1:]\n    else:\n        raise ValueError(\"invalid phone number length or format\")\n\n    # BUG: area code is 2 digits, prefix is 3 digits, line number is 5 digits\n    area = national[0:2]\n    prefix = national[2:5]\n    line = national[5:10]\n\n    return f\"+1-{area}-{prefix}-{line}\"\n",
      "weight": 2
    }
  ],
  "description_md": "## 문제 설명\n\n고객 지원/CRM 시스템에서는 사용자가 입력한 다양한 형태의 전화번호를 저장하기 전에 **일관된 표준 형식**으로 변환해야 합니다. 이 문제에서는 미국(US) 번호를 대상으로, 문자열로 주어진 전화번호를 표준 형식으로 정규화하는 함수를 테스트합니다.\n\n테스트 대상 함수 `normalize_us_phone(phone: str) -> str` 는 다음과 같은 역할을 합니다.\n\n- 입력: 사용자가 자유롭게 입력한 전화번호 문자열 (`phone`)\n- 처리:\n  - 공백, 대시(`-`), 점(`.`), 괄호(`(`, `)`) 등 **구분자 문자를 제거**하고 숫자만 추출\n  - 다음과 같은 경우를 유효한 미국 번호로 간주\n    - 숫자 10자리: 지역번호(3) + 국번호(3) + 가입자번호(4)\n    - 숫자 11자리이면서 맨 앞이 `1`: 미국 국가 코드 + 10자리 번호\n    - 위 두 경우에 대해 앞에 `+1` 이 붙어 있을 수도 있음 (예: `+1 (555) 123-4567`)\n  - 미국 이외 국가 코드(예: `+44`, `+81`)이거나, 자릿수가 맞지 않으면 **`ValueError`** 발생\n- 출력: 항상 **`+1-AAA-BBB-CCCC`** 형식의 문자열로 반환 (A=지역번호, B=국번호, C=가입자번호)\n\n또한, `phone` 인자가 문자열이 아닌 경우에는 **`TypeError`** 를 발생시킵니다.\n\n### 동작 예시\n\n```text\nnormalize_us_phone(\"5551234567\")            -> \"+1-555-123-4567\"\nnormalize_us_phone(\"+1 (555) 123-4567\")    -> \"+1-555-123-4567\"\nnormalize_us_phone(\"1-212-555-0000\")       -> \"+1-212-555-0000\"\n```\n\n다음과 같은 입력은 예외를 발생시켜야 합니다.\n\n```text\nnormalize_us_phone(\"+44 20 7946 0958\")   # 미국 이외 국가 코드 -> ValueError\nnormalize_us_phone(\"123456789\")          # 자릿수가 10 또는 11이 아님 -> ValueError\n```\n\n### 테스트에서 고려해야 할 점 (힌트)\n\n- **문자열 전처리(string manipulation)**\n  - 공백, 대시, 괄호 등 다양한 구분자가 섞인 입력을 올바르게 처리하는지\n  - `1`, `+1` 이 붙은 경우와 붙지 않은 경우가 동일한 결과로 정규화되는지\n- **데이터 포맷팅(data formatting)**\n  - 반환 형식이 정확히 `+1-AAA-BBB-CCCC` (플러스와 대시 위치, 자릿수 포함)를 따르는지\n  - 10자리/11자리 입력에서 지역번호(3), 국번호(3), 가입자번호(4)가 올바르게 잘려 나가는지\n- **예외 처리**\n  - 너무 짧거나 긴 번호, 혹은 `+2`, `+44` 등의 다른 국가 코드를 가진 번호가 적절히 `ValueError` 를 일으키는지\n  - 문자열이 아닌 입력에 대해 `TypeError` 가 발생하는지\n\n### 수험자에게 주어진 과제\n\n`pytest` 를 사용하여 `normalize_us_phone` 함수에 대한 **단위 테스트 코드**를 작성하세요. 목표는:\n\n- 정상 입력에 대해 기대하는 표준 형식 문자열이 정확히 반환되는지 검증하고,\n- 잘못된 입력에 대해 적절한 예외가 발생하는지 확인하며,\n- 준비된 여러 개의 버그 구현들에서 최대한 많은 결함을 찾아내는 것 입니다.\n\n단일 함수에 대한 테스트이므로, 다양한 입력 케이스를 설계하여 **문자열 처리와 출력 포맷 검증** 능력을 충분히 보여주세요.",
  "initial_test_template": "import pytest\nfrom target import normalize_us_phone\n\n\ndef test_simple_local_number():\n    # TODO: 간단한 10자리 숫자만 있는 입력이 올바른 형식으로 변환되는지 확인하세요.\n    # 예: '5551234567' -> '+1-555-123-4567'\n    pass\n\n\ndef test_with_country_code_and_separators():\n    # TODO: '1' 또는 '+1' 국가 코드와 공백, 대시, 괄호 등이 섞인 입력을 테스트하세요.\n    #       문자열 전처리(string manipulation)가 제대로 되는지, 최종 형식이 동일한지 확인합니다.\n    pass\n\n\ndef test_invalid_or_foreign_number():\n    # TODO: 자릿수가 너무 짧거나 긴 번호, 혹은 '+2', '+44' 등 미국 이외 국가 코드를\n    #       사용하는 번호가 ValueError를 발생시키는지 확인하세요.\n    pass\n\n\ndef test_output_format_is_exact():\n    # TODO: 반환 문자열이 정확히 '+1-AAA-BBB-CCCC' 형식을 따르는지 (플러스/대시 위치 포함)\n    #       데이터를 포맷팅하는 로직을 검사하는 테스트를 작성하세요.\n    pass\n",
  "tags": [
    "easy",
    "qa",
    "testing",
    "unit-test",
    "pytest",
    "string manipulation",
    "data formatting",
    "phone-number"
  ],
  "difficulty": "Easy",
  "strong_test_code": "import pytest\nfrom target import normalize_us_phone\n\n\ndef test_simple_10_digit_number():\n    # 기본 10자리 - 그룹핑 버그 잡기\n    assert normalize_us_phone('5551234567') == '+1-555-123-4567'\n    assert normalize_us_phone('2125550000') == '+1-212-555-0000'\n\n\ndef test_11_digit_with_country_code():\n    # 11자리 번호 - 11자리 거부 버그 잡기\n    assert normalize_us_phone('15551234567') == '+1-555-123-4567'\n    assert normalize_us_phone('1-555-123-4567') == '+1-555-123-4567'\n    assert normalize_us_phone('+1 (555) 123-4567') == '+1-555-123-4567'\n\n\ndef test_various_separators():\n    # 구분자 처리\n    assert normalize_us_phone('555.123.4567') == '+1-555-123-4567'\n    assert normalize_us_phone('(555) 123-4567') == '+1-555-123-4567'\n    assert normalize_us_phone('555 123 4567') == '+1-555-123-4567'\n\n\ndef test_output_format_has_plus():\n    # + 기호 누락 버그 잡기\n    result = normalize_us_phone('5551234567')\n    assert result.startswith('+1-')\n    assert result == '+1-555-123-4567'\n\n\ndef test_invalid_country_code():\n    # 국가 코드 검증 버그 잡기\n    with pytest.raises(ValueError):\n        normalize_us_phone('+44 20 7946 0958')\n    with pytest.raises(ValueError):\n        normalize_us_phone('+2 (555) 123-4567')\n\n\ndef test_invalid_length():\n    # 잘못된 길이\n    with pytest.raises(ValueError):\n        normalize_us_phone('123456789')  # 9자리\n    with pytest.raises(ValueError):\n        normalize_us_phone('123456789012')  # 12자리\n"
}