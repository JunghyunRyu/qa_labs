{
  "title": "복합 할인/배송 규칙을 가진 최종 결제 금액 계산",
  "function_signature": "def calculate_final_price(price_per_unit: float, quantity: int, membership: str, season: str, coupon: dict | None, shipping_fee: float) -> float:",
  "golden_code": "def calculate_final_price(price_per_unit: float, quantity: int, membership: str, season: str, coupon: dict | None, shipping_fee: float) -> float:\n    \"\"\"Calculate the final payable amount for an order.\n\n    Business rules (all monetary values are in the same currency):\n\n    1. Base subtotal = price_per_unit * quantity.\n       - price_per_unit must be >= 0\n       - quantity must be >= 0 (0 means no items)\n\n    2. Membership discount (applied on subtotal):\n       - membership one of: \"standard\", \"silver\", \"gold\" (case-insensitive)\n       - standard:   0% discount\n       - silver:     5% discount\n       - gold:      10% discount\n\n    3. Seasonal discount (percentage, applied AFTER membership discount):\n       - season one of: \"none\", \"spring\", \"summer\", \"autumn\", \"winter\" (case-insensitive)\n       - \"winter\":  extra 5% discount\n       - \"summer\":  extra 3% discount\n       - others:    0%\n\n    4. Coupon (optional, applied AFTER seasonal discount):\n       - coupon is either None or a dict with keys:\n         - \"type\": \"fixed\" or \"percent\"\n         - \"value\": non-negative float\n         - \"min_subtotal\": minimal original subtotal (before any discount)\n           required to be eligible for the coupon.\n       - If original subtotal < min_subtotal, coupon is ignored.\n       - For type == \"fixed\": discount_value = value.\n       - For type == \"percent\": discount_value = discounted_subtotal * (value / 100).\n       - Coupon discount cannot reduce product cost below 0; it is capped at\n         the current discounted subtotal.\n\n    5. Shipping fee:\n       - shipping_fee is added at the end (after all discounts on products).\n       - shipping_fee must be >= 0.\n\n    6. Final amount:\n       - final = max(0, discounted_product_total) + shipping_fee\n       - Result is rounded to 2 decimal places using round(x, 2).\n\n    Raises:\n        ValueError: if any of the numeric inputs are negative or membership/season\n                    are invalid strings, or coupon structure is invalid.\n    \"\"\"\n\n    # Validate numeric inputs\n    if price_per_unit < 0:\n        raise ValueError(\"price_per_unit must be non-negative\")\n    if quantity < 0:\n        raise ValueError(\"quantity must be non-negative\")\n    if shipping_fee < 0:\n        raise ValueError(\"shipping_fee must be non-negative\")\n\n    # Base subtotal\n    original_subtotal = price_per_unit * quantity\n\n    # Early exit: if no items, only shipping fee is paid (may be zero)\n    # Note: further logic still validates membership/season strings for consistency.\n\n    # Normalize membership and season\n    if not isinstance(membership, str):\n        raise ValueError(\"membership must be a string\")\n    if not isinstance(season, str):\n        raise ValueError(\"season must be a string\")\n\n    membership_key = membership.strip().lower()\n    season_key = season.strip().lower()\n\n    membership_discounts = {\n        \"standard\": 0.0,\n        \"silver\": 0.05,\n        \"gold\": 0.10,\n    }\n\n    if membership_key not in membership_discounts:\n        raise ValueError(\"invalid membership level\")\n\n    season_discounts = {\n        \"none\": 0.0,\n        \"spring\": 0.0,\n        \"summer\": 0.03,\n        \"autumn\": 0.0,\n        \"winter\": 0.05,\n    }\n\n    if season_key not in season_discounts:\n        raise ValueError(\"invalid season value\")\n\n    # Apply membership discount\n    subtotal = original_subtotal\n    member_rate = membership_discounts[membership_key]\n    subtotal *= (1.0 - member_rate)\n\n    # Apply seasonal discount\n    season_rate = season_discounts[season_key]\n    subtotal *= (1.0 - season_rate)\n\n    # Apply coupon if present and eligible\n    if coupon is not None:\n        if not isinstance(coupon, dict):\n            raise ValueError(\"coupon must be a dict or None\")\n        required_keys = {\"type\", \"value\", \"min_subtotal\"}\n        if not required_keys.issubset(coupon.keys()):\n            raise ValueError(\"coupon dict missing required keys\")\n\n        c_type = coupon[\"type\"]\n        c_value = coupon[\"value\"]\n        c_min = coupon[\"min_subtotal\"]\n\n        if c_type not in (\"fixed\", \"percent\"):\n            raise ValueError(\"coupon type must be 'fixed' or 'percent'\")\n        if c_value < 0 or c_min < 0:\n            raise ValueError(\"coupon value and min_subtotal must be non-negative\")\n\n        # Eligibility based on original subtotal (before any discounts)\n        if original_subtotal >= c_min and subtotal > 0:\n            if c_type == \"fixed\":\n                discount_value = c_value\n            else:  # percent\n                discount_value = subtotal * (c_value / 100.0)\n\n            # Cap discount so subtotal never goes below zero\n            if discount_value > subtotal:\n                discount_value = subtotal\n\n            subtotal -= discount_value\n\n    # Ensure product subtotal is not negative due to numerical issues\n    if subtotal < 0:\n        subtotal = 0.0\n\n    final_amount = subtotal + shipping_fee\n\n    # Final safety: amount cannot be negative\n    if final_amount < 0:\n        final_amount = 0.0\n\n    return round(final_amount, 2)\n",
  "buggy_implementations": [
    {
      "bug_description": "쿠폰 최소 금액(min_subtotal) 조건을 '할인 적용 후 subtotal' 기준으로 잘못 비교하여, 원래는 불가능한 케이스에서 쿠폰이 적용되거나 반대로 적용되지 않음. 복합 할인 순서와 조건을 이해하지 못하면 놓치기 쉬움.",
      "buggy_code": "def calculate_final_price(price_per_unit: float, quantity: int, membership: str, season: str, coupon: dict | None, shipping_fee: float) -> float:\n    \"\"\"Buggy: compares coupon min_subtotal against discounted subtotal instead of original subtotal.\"\"\"\n\n    if price_per_unit < 0:\n        raise ValueError(\"price_per_unit must be non-negative\")\n    if quantity < 0:\n        raise ValueError(\"quantity must be non-negative\")\n    if shipping_fee < 0:\n        raise ValueError(\"shipping_fee must be non-negative\")\n\n    original_subtotal = price_per_unit * quantity\n\n    if not isinstance(membership, str):\n        raise ValueError(\"membership must be a string\")\n    if not isinstance(season, str):\n        raise ValueError(\"season must be a string\")\n\n    membership_key = membership.strip().lower()\n    season_key = season.strip().lower()\n\n    membership_discounts = {\n        \"standard\": 0.0,\n        \"silver\": 0.05,\n        \"gold\": 0.10,\n    }\n    if membership_key not in membership_discounts:\n        raise ValueError(\"invalid membership level\")\n\n    season_discounts = {\n        \"none\": 0.0,\n        \"spring\": 0.0,\n        \"summer\": 0.03,\n        \"autumn\": 0.0,\n        \"winter\": 0.05,\n    }\n    if season_key not in season_discounts:\n        raise ValueError(\"invalid season value\")\n\n    subtotal = original_subtotal\n    subtotal *= (1.0 - membership_discounts[membership_key])\n    subtotal *= (1.0 - season_discounts[season_key])\n\n    if coupon is not None:\n        if not isinstance(coupon, dict):\n            raise ValueError(\"coupon must be a dict or None\")\n        required_keys = {\"type\", \"value\", \"min_subtotal\"}\n        if not required_keys.issubset(coupon.keys()):\n            raise ValueError(\"coupon dict missing required keys\")\n\n        c_type = coupon[\"type\"]\n        c_value = coupon[\"value\"]\n        c_min = coupon[\"min_subtotal\"]\n\n        if c_type not in (\"fixed\", \"percent\"):\n            raise ValueError(\"coupon type must be 'fixed' or 'percent'\")\n        if c_value < 0 or c_min < 0:\n            raise ValueError(\"coupon value and min_subtotal must be non-negative\")\n\n        # BUG: eligibility based on discounted subtotal instead of original_subtotal\n        if subtotal >= c_min and subtotal > 0:\n            if c_type == \"fixed\":\n                discount_value = c_value\n            else:\n                discount_value = subtotal * (c_value / 100.0)\n            if discount_value > subtotal:\n                discount_value = subtotal\n            subtotal -= discount_value\n\n    if subtotal < 0:\n        subtotal = 0.0\n    final_amount = subtotal + shipping_fee\n    if final_amount < 0:\n        final_amount = 0.0\n    return round(final_amount, 2)\n",
      "weight": 5
    },
    {
      "bug_description": "시즌 할인과 쿠폰의 적용 순서를 바꾸어 쿠폰을 먼저 적용하고 시즌 할인을 나중에 적용함. 여러 할인 조합에서 최종 금액이 달라지므로, 조건별 순서 테스트가 필요.",
      "buggy_code": "def calculate_final_price(price_per_unit: float, quantity: int, membership: str, season: str, coupon: dict | None, shipping_fee: float) -> float:\n    \"\"\"Buggy: applies coupon before seasonal discount, violating the specified order.\"\"\"\n\n    if price_per_unit < 0:\n        raise ValueError(\"price_per_unit must be non-negative\")\n    if quantity < 0:\n        raise ValueError(\"quantity must be non-negative\")\n    if shipping_fee < 0:\n        raise ValueError(\"shipping_fee must be non-negative\")\n\n    original_subtotal = price_per_unit * quantity\n\n    if not isinstance(membership, str):\n        raise ValueError(\"membership must be a string\")\n    if not isinstance(season, str):\n        raise ValueError(\"season must be a string\")\n\n    membership_key = membership.strip().lower()\n    season_key = season.strip().lower()\n\n    membership_discounts = {\n        \"standard\": 0.0,\n        \"silver\": 0.05,\n        \"gold\": 0.10,\n    }\n    if membership_key not in membership_discounts:\n        raise ValueError(\"invalid membership level\")\n\n    season_discounts = {\n        \"none\": 0.0,\n        \"spring\": 0.0,\n        \"summer\": 0.03,\n        \"autumn\": 0.0,\n        \"winter\": 0.05,\n    }\n    if season_key not in season_discounts:\n        raise ValueError(\"invalid season value\")\n\n    subtotal = original_subtotal\n    # membership first (correct)\n    subtotal *= (1.0 - membership_discounts[membership_key])\n\n    # BUG: apply coupon BEFORE seasonal discount\n    if coupon is not None:\n        if not isinstance(coupon, dict):\n            raise ValueError(\"coupon must be a dict or None\")\n        required_keys = {\"type\", \"value\", \"min_subtotal\"}\n        if not required_keys.issubset(coupon.keys()):\n            raise ValueError(\"coupon dict missing required keys\")\n\n        c_type = coupon[\"type\"]\n        c_value = coupon[\"value\"]\n        c_min = coupon[\"min_subtotal\"]\n\n        if c_type not in (\"fixed\", \"percent\"):\n            raise ValueError(\"coupon type must be 'fixed' or 'percent'\")\n        if c_value < 0 or c_min < 0:\n            raise ValueError(\"coupon value and min_subtotal must be non-negative\")\n\n        if original_subtotal >= c_min and subtotal > 0:\n            if c_type == \"fixed\":\n                discount_value = c_value\n            else:\n                discount_value = subtotal * (c_value / 100.0)\n            if discount_value > subtotal:\n                discount_value = subtotal\n            subtotal -= discount_value\n\n    # Now apply seasonal discount (out of order)\n    season_rate = season_discounts[season_key]\n    subtotal *= (1.0 - season_rate)\n\n    if subtotal < 0:\n        subtotal = 0.0\n    final_amount = subtotal + shipping_fee\n    if final_amount < 0:\n        final_amount = 0.0\n    return round(final_amount, 2)\n",
      "weight": 4
    },
    {
      "bug_description": "회원 등급 할인율에서 gold와 silver를 혼동하여 gold를 5%, silver를 10%로 잘못 적용. 복수의 membership 값에 대해 비교 테스트를 하지 않으면 발견하기 어려움.",
      "buggy_code": "def calculate_final_price(price_per_unit: float, quantity: int, membership: str, season: str, coupon: dict | None, shipping_fee: float) -> float:\n    \"\"\"Buggy: swaps discount rates for silver and gold memberships.\"\"\"\n\n    if price_per_unit < 0:\n        raise ValueError(\"price_per_unit must be non-negative\")\n    if quantity < 0:\n        raise ValueError(\"quantity must be non-negative\")\n    if shipping_fee < 0:\n        raise ValueError(\"shipping_fee must be non-negative\")\n\n    original_subtotal = price_per_unit * quantity\n\n    if not isinstance(membership, str):\n        raise ValueError(\"membership must be a string\")\n    if not isinstance(season, str):\n        raise ValueError(\"season must be a string\")\n\n    membership_key = membership.strip().lower()\n    season_key = season.strip().lower()\n\n    # BUG: swapped rates for silver and gold\n    membership_discounts = {\n        \"standard\": 0.0,\n        \"silver\": 0.10,  # should be 0.05\n        \"gold\": 0.05,    # should be 0.10\n    }\n    if membership_key not in membership_discounts:\n        raise ValueError(\"invalid membership level\")\n\n    season_discounts = {\n        \"none\": 0.0,\n        \"spring\": 0.0,\n        \"summer\": 0.03,\n        \"autumn\": 0.0,\n        \"winter\": 0.05,\n    }\n    if season_key not in season_discounts:\n        raise ValueError(\"invalid season value\")\n\n    subtotal = original_subtotal\n    subtotal *= (1.0 - membership_discounts[membership_key])\n    subtotal *= (1.0 - season_discounts[season_key])\n\n    if coupon is not None:\n        if not isinstance(coupon, dict):\n            raise ValueError(\"coupon must be a dict or None\")\n        required_keys = {\"type\", \"value\", \"min_subtotal\"}\n        if not required_keys.issubset(coupon.keys()):\n            raise ValueError(\"coupon dict missing required keys\")\n\n        c_type = coupon[\"type\"]\n        c_value = coupon[\"value\"]\n        c_min = coupon[\"min_subtotal\"]\n\n        if c_type not in (\"fixed\", \"percent\"):\n            raise ValueError(\"coupon type must be 'fixed' or 'percent'\")\n        if c_value < 0 or c_min < 0:\n            raise ValueError(\"coupon value and min_subtotal must be non-negative\")\n\n        if original_subtotal >= c_min and subtotal > 0:\n            if c_type == \"fixed\":\n                discount_value = c_value\n            else:\n                discount_value = subtotal * (c_value / 100.0)\n            if discount_value > subtotal:\n                discount_value = subtotal\n            subtotal -= discount_value\n\n    if subtotal < 0:\n        subtotal = 0.0\n    final_amount = subtotal + shipping_fee\n    if final_amount < 0:\n        final_amount = 0.0\n    return round(final_amount, 2)\n",
      "weight": 3
    },
    {
      "bug_description": "퍼센트 쿠폰이 subtotal을 초과하는 극단적인 경우를 고려하지 않아, subtotal이 음수가 된 뒤 뒤늦게 0으로 보정됨. 결과적으로 금액은 같지만, 할인 상한 조건을 요구하는 비즈니스 규칙을 위반하는 로직 버그.",
      "buggy_code": "def calculate_final_price(price_per_unit: float, quantity: int, membership: str, season: str, coupon: dict | None, shipping_fee: float) -> float:\n    \"\"\"Buggy: does not cap coupon discount to current subtotal before subtraction.\"\"\"\n\n    if price_per_unit < 0:\n        raise ValueError(\"price_per_unit must be non-negative\")\n    if quantity < 0:\n        raise ValueError(\"quantity must be non-negative\")\n    if shipping_fee < 0:\n        raise ValueError(\"shipping_fee must be non-negative\")\n\n    original_subtotal = price_per_unit * quantity\n\n    if not isinstance(membership, str):\n        raise ValueError(\"membership must be a string\")\n    if not isinstance(season, str):\n        raise ValueError(\"season must be a string\")\n\n    membership_key = membership.strip().lower()\n    season_key = season.strip().lower()\n\n    membership_discounts = {\n        \"standard\": 0.0,\n        \"silver\": 0.05,\n        \"gold\": 0.10,\n    }\n    if membership_key not in membership_discounts:\n        raise ValueError(\"invalid membership level\")\n\n    season_discounts = {\n        \"none\": 0.0,\n        \"spring\": 0.0,\n        \"summer\": 0.03,\n        \"autumn\": 0.0,\n        \"winter\": 0.05,\n    }\n    if season_key not in season_discounts:\n        raise ValueError(\"invalid season value\")\n\n    subtotal = original_subtotal\n    subtotal *= (1.0 - membership_discounts[membership_key])\n    subtotal *= (1.0 - season_discounts[season_key])\n\n    if coupon is not None:\n        if not isinstance(coupon, dict):\n            raise ValueError(\"coupon must be a dict or None\")\n        required_keys = {\"type\", \"value\", \"min_subtotal\"}\n        if not required_keys.issubset(coupon.keys()):\n            raise ValueError(\"coupon dict missing required keys\")\n\n        c_type = coupon[\"type\"]\n        c_value = coupon[\"value\"]\n        c_min = coupon[\"min_subtotal\"]\n\n        if c_type not in (\"fixed\", \"percent\"):\n            raise ValueError(\"coupon type must be 'fixed' or 'percent'\")\n        if c_value < 0 or c_min < 0:\n            raise ValueError(\"coupon value and min_subtotal must be non-negative\")\n\n        if original_subtotal >= c_min and subtotal > 0:\n            if c_type == \"fixed\":\n                discount_value = c_value\n            else:\n                # BUG: no capping of discount_value vs subtotal\n                discount_value = subtotal * (c_value / 100.0)\n            subtotal -= discount_value\n\n    # Subtotal may be negative here\n    if subtotal < 0:\n        subtotal = 0.0\n\n    final_amount = subtotal + shipping_fee\n    if final_amount < 0:\n        final_amount = 0.0\n    return round(final_amount, 2)\n",
      "weight": 2
    },
    {
      "bug_description": "season 값 검증을 느슨하게 하여 허용되지 않은 시즌 문자열(예: 'blackfriday')도 0% 할인으로 조용히 통과시킴. 다중 조건 검증의 누락을 찾는 테스트가 필요.",
      "buggy_code": "def calculate_final_price(price_per_unit: float, quantity: int, membership: str, season: str, coupon: dict | None, shipping_fee: float) -> float:\n    \"\"\"Buggy: treats unknown season as 'none' instead of raising ValueError.\"\"\"\n\n    if price_per_unit < 0:\n        raise ValueError(\"price_per_unit must be non-negative\")\n    if quantity < 0:\n        raise ValueError(\"quantity must be non-negative\")\n    if shipping_fee < 0:\n        raise ValueError(\"shipping_fee must be non-negative\")\n\n    original_subtotal = price_per_unit * quantity\n\n    if not isinstance(membership, str):\n        raise ValueError(\"membership must be a string\")\n    if not isinstance(season, str):\n        raise ValueError(\"season must be a string\")\n\n    membership_key = membership.strip().lower()\n    season_key = season.strip().lower()\n\n    membership_discounts = {\n        \"standard\": 0.0,\n        \"silver\": 0.05,\n        \"gold\": 0.10,\n    }\n    if membership_key not in membership_discounts:\n        raise ValueError(\"invalid membership level\")\n\n    season_discounts = {\n        \"none\": 0.0,\n        \"spring\": 0.0,\n        \"summer\": 0.03,\n        \"autumn\": 0.0,\n        \"winter\": 0.05,\n    }\n\n    # BUG: unknown seasons are treated as 'none' instead of error\n    season_rate = season_discounts.get(season_key, 0.0)\n\n    subtotal = original_subtotal\n    subtotal *= (1.0 - membership_discounts[membership_key])\n    subtotal *= (1.0 - season_rate)\n\n    if coupon is not None:\n        if not isinstance(coupon, dict):\n            raise ValueError(\"coupon must be a dict or None\")\n        required_keys = {\"type\", \"value\", \"min_subtotal\"}\n        if not required_keys.issubset(coupon.keys()):\n            raise ValueError(\"coupon dict missing required keys\")\n\n        c_type = coupon[\"type\"]\n        c_value = coupon[\"value\"]\n        c_min = coupon[\"min_subtotal\"]\n\n        if c_type not in (\"fixed\", \"percent\"):\n            raise ValueError(\"coupon type must be 'fixed' or 'percent'\")\n        if c_value < 0 or c_min < 0:\n            raise ValueError(\"coupon value and min_subtotal must be non-negative\")\n\n        if original_subtotal >= c_min and subtotal > 0:\n            if c_type == \"fixed\":\n                discount_value = c_value\n            else:\n                discount_value = subtotal * (c_value / 100.0)\n            if discount_value > subtotal:\n                discount_value = subtotal\n            subtotal -= discount_value\n\n    if subtotal < 0:\n        subtotal = 0.0\n    final_amount = subtotal + shipping_fee\n    if final_amount < 0:\n        final_amount = 0.0\n    return round(final_amount, 2)\n",
      "weight": 3
    }
  ],
  "description_md": "## 문제 설명\n\n한 전자상거래 서비스에서 **최종 결제 금액을 계산하는 가격 엔진**을 개발하고 있습니다. 이 엔진은 다음과 같이 여러 비즈니스 규칙을 동시에 반영해야 합니다.\n\n- 상품 단가와 수량\n- 회원 등급(일반/실버/골드)에 따른 할인\n- 시즌(봄/여름/가을/겨울)에 따른 추가 할인\n- 최소 주문 금액 조건이 있는 쿠폰(정액/정률)\n- 마지막에 더해지는 배송비\n\n운영 환경에서는 이 로직이 수많은 주문에 대해 호출되므로, **조건 조합에 따라 미묘한 계산 오류**가 발생하지 않도록 정교한 테스트가 필요합니다.\n\n### 함수 설명\n\n```python\ncalculate_final_price(\n    price_per_unit: float,\n    quantity: int,\n    membership: str,\n    season: str,\n    coupon: dict | None,\n    shipping_fee: float,\n) -> float\n```\n\n- `price_per_unit`: 상품 1개의 가격 (0 이상)\n- `quantity`: 주문 수량 (0 이상, 0이면 상품 금액은 0)\n- `membership`: 회원 등급 문자열 (예: \"standard\", \"silver\", \"gold\" – 대소문자 무시)\n- `season`: 시즌 문자열 (예: \"none\", \"summer\", \"winter\" – 대소문자 무시)\n- `coupon`: 쿠폰 정보 dict 또는 `None`\n  - 예: `{\"type\": \"fixed\", \"value\": 2000.0, \"min_subtotal\": 30000.0}`\n  - 예: `{\"type\": \"percent\", \"value\": 10.0, \"min_subtotal\": 50000.0}`\n- `shipping_fee`: 배송비 (0 이상, 항상 최종에 더해짐)\n\n반환값은 **최종 결제 금액(float)** 이며, 소수 둘째 자리까지 `round(x, 2)`로 반올림합니다.\n\n### 비즈니스 규칙(요약)\n\n1. 기본 상품 금액 = `price_per_unit * quantity`\n2. 회원 등급 할인 적용\n3. 시즌 할인 추가 적용 (회원 할인 후에 적용)\n4. 쿠폰 적용\n   - 원래 상품 금액(할인 전 subtotal)이 `min_subtotal` 이상이어야 쿠폰 적용 가능\n   - 쿠폰 종류에 따라 정액/정률 할인\n   - 할인액은 현재 상품 금액을 0 미만으로 만들 수 없음\n5. 마지막에 배송비를 더해 최종 금액을 계산\n6. 입력 값이 잘못된 경우(`membership`/`season` 값, 음수 금액 등)에는 `ValueError`를 발생시켜야 합니다.\n\n자세한 규칙은 제공된 함수의 docstring(골든 구현 기준)을 참고하세요.\n\n### 동작 예시\n\n다음 예시는 **정상 동작해야 하는 시나리오 예시**입니다.\n\n1. 기본 케이스 (할인 없음)\n   - 입력: `price_per_unit=10000`, `quantity=2`, `membership=\"standard\"`, `season=\"none\"`, `coupon=None`, `shipping_fee=3000`\n   - 계산: 상품 20000 + 배송비 3000 = **23000.00**\n\n2. 회원 + 시즌 + 퍼센트 쿠폰 조합\n   - 입력: `price_per_unit=5000`, `quantity=10`, `membership=\"gold\"`, `season=\"winter\"`,\n     `coupon={\"type\": \"percent\", \"value\": 10, \"min_subtotal\": 30000}`, `shipping_fee=0`\n   - 원 subtotal: 5000 * 10 = 50000\n   - gold 10% 할인 → 45000\n   - winter 5% 추가 할인 → 42750\n   - 쿠폰 10% (조건 충족) → 42750 * 0.9 = **38475.00**\n\n### 테스트에서 고려해야 할 포인트 (힌트)\n\n- **다양한 membership/season 조합**에 대해, 할인 순서와 비율이 정확한지 검증해 보세요.\n- 쿠폰의 `min_subtotal` 기준이 **어떤 subtotal**을 기준으로 하는지(할인 전/후)를 구분해 테스트해 보세요.\n- 정액/정률 쿠폰이 다른 할인들과 **어떤 순서**로 적용되어야 하는지에 따라 결과가 달라지는 케이스를 만들어 보세요.\n- 극단적인 값: 수량 0, 가격 0, 아주 큰 할인율(예: 200% 정률 쿠폰) 등에서 상품 금액이 0 미만으로 내려가지 않는지 확인해 보세요.\n- 유효하지 않은 membership/season 문자열, 음수 shipping_fee, 구조가 잘못된 쿠폰(dict 키 누락 등)에 대해 적절히 `ValueError`가 발생하는지 확인해 보세요.\n\n이 문제에는 이미 **여러 개의 버그 구현**이 준비되어 있으며, 수험자는 이를 알 수 없습니다. 여러분의 목표는:\n\n> pytest 기반 단위 테스트를 작성하여 다양한 조건 조합을 검증하고, 가능한 한 많은 버그 구현을 실패시키는 것입니다.\n\n단순한 예시 몇 개만으로는 모든 버그를 잡을 수 없습니다. **복잡한 비즈니스 로직, 여러 할인 규칙의 순서, 다중 조건 분기**를 충분히 커버하는 테스트 케이스를 설계해 보세요.\n",
  "initial_test_template": "import pytest\n\nfrom target import calculate_final_price\n\n\n# 아래 테스트 함수들은 예시 템플릿입니다.\n# 다양한 membership/season/coupon 조합을 추가로 설계해 보세요.\n\n\ndef test_basic_no_discounts():\n    \"\"\"기본 케이스: 할인/쿠폰 없이 단순 합계 + 배송비.\n    complex business logic의 기본 경로를 검증하는 테스트부터 시작해 보세요.\n    \"\"\"\n    # TODO: 단순 케이스에 대한 기대값을 계산하고 assert로 검증하세요.\n    pass\n\n\ndef test_membership_and_season_combinations():\n    \"\"\"여러 membership/season 조합 테스트.\n    - standard/silver/gold 각각에 대해 시즌별(예: none, summer, winter)로 비교해 보세요.\n    - 다중 조건에서 할인 순서(회원 → 시즌)가 올바르게 적용되는지 확인해 보세요.\n    \"\"\"\n    # TODO: 같은 subtotal에서 membership 등급에 따라 최종 금액이 단조 감소하는지 등 비교 테스트를 설계하세요.\n    pass\n\n\ndef test_coupon_min_subtotal_and_order():\n    \"\"\"쿠폰 min_subtotal 기준 및 적용 순서 검증.\n    - min_subtotal 경계값 근처 (바로 미만/이상) 케이스를 만들어 보세요.\n    - membership/season 할인과 쿠폰이 어떤 순서로 적용되어야 하는지에 따라\n      결과가 달라지는 조합을 만들어, 잘못된 구현을 잡아내 보세요.\n    \"\"\"\n    # TODO: 같은 입력에서 골든 로직과 다른 결과가 나올 수 있는 조합을 상상해 보세요.\n    pass\n\n\ndef test_extreme_discounts_and_invalid_inputs():\n    \"\"\"극단적인 할인/잘못된 입력 처리 테스트.\n    - 0개 수량, 0원 가격, 매우 큰 퍼센트 쿠폰(>100%) 등 edge case를 만들어 보세요.\n    - 잘못된 membership/season 문자열, 음수 shipping_fee, 잘못된 쿠폰 dict 등에서\n      ValueError가 발생하는지 검증하세요.\n    \"\"\"\n    # TODO: 예외 발생 여부를 pytest.raises로 확인하는 테스트를 작성하세요.\n    pass\n",
  "tags": [
    "hard",
    "qa",
    "testing",
    "unit-test",
    "pricing",
    "e-commerce",
    "complex business logic",
    "multiple conditions"
  ],
  "difficulty": "Hard"
}