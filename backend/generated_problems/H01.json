{
  "title": "장바구니 복합 할인 계산(cents) 함수 테스트",
  "function_signature": "def calculate_cart_total(items: list[dict], vip_tier: str = 'NONE', coupon: dict | None = None, coupon_already_redeemed: bool = False) -> dict[str, int]:",
  "golden_code": "def calculate_cart_total(items: list[dict], vip_tier: str = 'NONE', coupon: dict | None = None, coupon_already_redeemed: bool = False) -> dict[str, int]:\n    '''Calculate a cart total (in cents) with layered discount rules.\n\n    Items\n    -----\n    Each item in `items` must be a dict with:\n      - unit_price_cents: int (>= 0)\n      - quantity: int (>= 1)\n      - category: 'regular' | 'sale' | 'gift_card'\n\n    Discounts (applied in order)\n    ----------------------------\n    1) Quantity discount (only for category 'regular', per line; rounded down):\n         qty >= 10 -> 15%\n         qty >= 5  -> 10%\n         qty >= 3  -> 5%\n    2) VIP discount on eligible items ('regular' + 'sale', excluding 'gift_card')\n       AFTER quantity discount:\n         NONE 0%, SILVER 2%, GOLD 5%, PLATINUM 8%\n    3) Coupon discount applied LAST on the remaining amount after (1)+(2).\n\n    Coupon (optional)\n    -----------------\n    Coupon is a dict with:\n      - code: optional str (ignored for calculations)\n      - type: 'percent' (1..80) or 'fixed' (>0 cents)\n      - value: int\n      - min_subtotal_cents: optional int >= 0, compared against eligible subtotal BEFORE discounts\n      - scope: optional 'order' or 'regular' (default 'order')\n      - stackable_with_vip: optional bool (default True)\n        If False AND the coupon is applicable, VIP discount is skipped.\n      - max_discount_cents: optional int >= 0 cap applied after coupon discount is computed\n\n    Errors\n    ------\n    - If coupon is provided and coupon_already_redeemed is True: raise ValueError.\n    - Invalid item/coupon/vip input: raise ValueError.\n\n    Returns\n    -------\n    A breakdown dict with keys (all ints, cents):\n      subtotal_cents, eligible_subtotal_cents,\n      quantity_discount_cents, vip_discount_cents, coupon_discount_cents,\n      discount_cents, payable_cents.\n\n    This function is deterministic and must not mutate inputs.\n    '''\n    vip_rates = {\n        'NONE': 0,\n        'SILVER': 2,\n        'GOLD': 5,\n        'PLATINUM': 8,\n    }\n    if vip_tier not in vip_rates:\n        raise ValueError(f'unknown vip_tier: {vip_tier!r}')\n\n    if not isinstance(items, list):\n        raise ValueError('items must be a list of item dicts')\n\n    allowed_categories = {'regular', 'sale', 'gift_card'}\n\n    subtotal_cents = 0\n    eligible_subtotal_cents = 0\n\n    quantity_discount_cents = 0\n    regular_after_qty_cents = 0\n    sale_after_qty_cents = 0\n\n    for idx, item in enumerate(items):\n        if not isinstance(item, dict):\n            raise ValueError(f'item {idx} must be a dict')\n\n        try:\n            price = item['unit_price_cents']\n            qty = item['quantity']\n            category = item['category']\n        except KeyError as e:\n            raise ValueError(f'missing required key {e.args[0]!r} in item {idx}')\n\n        if not isinstance(price, int):\n            raise ValueError(f'unit_price_cents must be int (item {idx})')\n        if not isinstance(qty, int):\n            raise ValueError(f'quantity must be int (item {idx})')\n        if not isinstance(category, str):\n            raise ValueError(f'category must be str (item {idx})')\n\n        if price < 0:\n            raise ValueError(f'unit_price_cents must be >= 0 (item {idx})')\n        if qty <= 0:\n            raise ValueError(f'quantity must be >= 1 (item {idx})')\n        if category not in allowed_categories:\n            raise ValueError(f'unknown category {category!r} (item {idx})')\n\n        line_total = price * qty\n        subtotal_cents += line_total\n\n        if category == 'gift_card':\n            continue\n\n        eligible_subtotal_cents += line_total\n\n        if category == 'regular':\n            if qty >= 10:\n                rate = 15\n            elif qty >= 5:\n                rate = 10\n            elif qty >= 3:\n                rate = 5\n            else:\n                rate = 0\n\n            line_qty_discount = (line_total * rate) // 100\n            quantity_discount_cents += line_qty_discount\n            regular_after_qty_cents += (line_total - line_qty_discount)\n        else:\n            sale_after_qty_cents += line_total\n\n    coupon_type = None\n    coupon_value = None\n    coupon_scope = 'order'\n    coupon_min_subtotal = 0\n    coupon_stackable_with_vip = True\n    coupon_max_discount = None\n    coupon_applicable = False\n\n    if coupon is not None:\n        if coupon_already_redeemed:\n            raise ValueError('coupon already redeemed')\n        if not isinstance(coupon, dict):\n            raise ValueError('coupon must be a dict or None')\n\n        coupon_type = coupon.get('type')\n        coupon_value = coupon.get('value')\n        coupon_scope = coupon.get('scope', 'order')\n        coupon_min_subtotal = coupon.get('min_subtotal_cents', 0)\n        coupon_stackable_with_vip = coupon.get('stackable_with_vip', True)\n        coupon_max_discount = coupon.get('max_discount_cents')\n\n        if coupon_type not in ('percent', 'fixed'):\n            raise ValueError(f'unknown coupon type: {coupon_type!r}')\n        if not isinstance(coupon_value, int):\n            raise ValueError('coupon value must be int')\n        if not isinstance(coupon_min_subtotal, int) or coupon_min_subtotal < 0:\n            raise ValueError('min_subtotal_cents must be a non-negative int')\n        if coupon_scope not in ('order', 'regular'):\n            raise ValueError(f'unknown coupon scope: {coupon_scope!r}')\n        if not isinstance(coupon_stackable_with_vip, bool):\n            raise ValueError('stackable_with_vip must be bool')\n        if coupon_max_discount is not None:\n            if not isinstance(coupon_max_discount, int) or coupon_max_discount < 0:\n                raise ValueError('max_discount_cents must be a non-negative int')\n\n        if coupon_type == 'percent':\n            if coupon_value < 1 or coupon_value > 80:\n                raise ValueError('percent coupon value must be between 1 and 80')\n        else:\n            if coupon_value <= 0:\n                raise ValueError('fixed coupon value must be positive')\n\n        coupon_applicable = eligible_subtotal_cents >= coupon_min_subtotal\n\n    vip_rate = vip_rates[vip_tier]\n    if coupon is not None and coupon_applicable and (not coupon_stackable_with_vip):\n        vip_rate = 0\n\n    vip_discount_regular = (regular_after_qty_cents * vip_rate) // 100\n    vip_discount_sale = (sale_after_qty_cents * vip_rate) // 100\n    vip_discount_cents = vip_discount_regular + vip_discount_sale\n\n    regular_after_vip_cents = regular_after_qty_cents - vip_discount_regular\n    sale_after_vip_cents = sale_after_qty_cents - vip_discount_sale\n\n    coupon_discount_cents = 0\n    if coupon is not None and coupon_applicable:\n        if coupon_scope == 'order':\n            coupon_base = regular_after_vip_cents + sale_after_vip_cents\n        else:\n            coupon_base = regular_after_vip_cents\n\n        if coupon_base < 0:\n            coupon_base = 0\n\n        if coupon_type == 'percent':\n            coupon_discount_cents = (coupon_base * coupon_value) // 100\n        else:\n            coupon_discount_cents = coupon_value if coupon_value < coupon_base else coupon_base\n\n        if coupon_max_discount is not None and coupon_discount_cents > coupon_max_discount:\n            coupon_discount_cents = coupon_max_discount\n\n    discount_cents = quantity_discount_cents + vip_discount_cents + coupon_discount_cents\n    payable_cents = subtotal_cents - discount_cents\n\n    if payable_cents < 0:\n        payable_cents = 0\n\n    return {\n        'subtotal_cents': subtotal_cents,\n        'eligible_subtotal_cents': eligible_subtotal_cents,\n        'quantity_discount_cents': quantity_discount_cents,\n        'vip_discount_cents': vip_discount_cents,\n        'coupon_discount_cents': coupon_discount_cents,\n        'discount_cents': discount_cents,\n        'payable_cents': payable_cents,\n    }\n",
  "buggy_implementations": [
    {
      "bug_description": "수량 할인 경계값(3/5/10)에서 >= 대신 > 비교를 사용해 quantity가 정확히 3, 5, 10일 때 할인율이 한 단계 낮게 적용되는 off-by-one 버그.",
      "buggy_code": "def calculate_cart_total(items: list[dict], vip_tier: str = 'NONE', coupon: dict | None = None, coupon_already_redeemed: bool = False) -> dict[str, int]:\n    vip_rates = {'NONE': 0, 'SILVER': 2, 'GOLD': 5, 'PLATINUM': 8}\n    if vip_tier not in vip_rates:\n        raise ValueError(f'unknown vip_tier: {vip_tier!r}')\n    if not isinstance(items, list):\n        raise ValueError('items must be a list of item dicts')\n\n    allowed_categories = {'regular', 'sale', 'gift_card'}\n    subtotal_cents = 0\n    eligible_subtotal_cents = 0\n    quantity_discount_cents = 0\n    regular_after_qty_cents = 0\n    sale_after_qty_cents = 0\n\n    for idx, item in enumerate(items):\n        if not isinstance(item, dict):\n            raise ValueError(f'item {idx} must be a dict')\n        try:\n            price = item['unit_price_cents']\n            qty = item['quantity']\n            category = item['category']\n        except KeyError as e:\n            raise ValueError(f'missing required key {e.args[0]!r} in item {idx}')\n\n        if not isinstance(price, int) or not isinstance(qty, int) or not isinstance(category, str):\n            raise ValueError(f'invalid types in item {idx}')\n        if price < 0:\n            raise ValueError(f'unit_price_cents must be >= 0 (item {idx})')\n        if qty <= 0:\n            raise ValueError(f'quantity must be >= 1 (item {idx})')\n        if category not in allowed_categories:\n            raise ValueError(f'unknown category {category!r} (item {idx})')\n\n        line_total = price * qty\n        subtotal_cents += line_total\n        if category == 'gift_card':\n            continue\n        eligible_subtotal_cents += line_total\n\n        if category == 'regular':\n            # BUG: off-by-one thresholds\n            if qty > 10:\n                rate = 15\n            elif qty > 5:\n                rate = 10\n            elif qty > 3:\n                rate = 5\n            else:\n                rate = 0\n            line_qty_discount = (line_total * rate) // 100\n            quantity_discount_cents += line_qty_discount\n            regular_after_qty_cents += (line_total - line_qty_discount)\n        else:\n            sale_after_qty_cents += line_total\n\n    coupon_type = None\n    coupon_value = None\n    coupon_scope = 'order'\n    coupon_min_subtotal = 0\n    coupon_stackable_with_vip = True\n    coupon_max_discount = None\n    coupon_applicable = False\n\n    if coupon is not None:\n        if coupon_already_redeemed:\n            raise ValueError('coupon already redeemed')\n        if not isinstance(coupon, dict):\n            raise ValueError('coupon must be a dict or None')\n        coupon_type = coupon.get('type')\n        coupon_value = coupon.get('value')\n        coupon_scope = coupon.get('scope', 'order')\n        coupon_min_subtotal = coupon.get('min_subtotal_cents', 0)\n        coupon_stackable_with_vip = coupon.get('stackable_with_vip', True)\n        coupon_max_discount = coupon.get('max_discount_cents')\n\n        if coupon_type not in ('percent', 'fixed'):\n            raise ValueError(f'unknown coupon type: {coupon_type!r}')\n        if not isinstance(coupon_value, int):\n            raise ValueError('coupon value must be int')\n        if not isinstance(coupon_min_subtotal, int) or coupon_min_subtotal < 0:\n            raise ValueError('min_subtotal_cents must be a non-negative int')\n        if coupon_scope not in ('order', 'regular'):\n            raise ValueError(f'unknown coupon scope: {coupon_scope!r}')\n        if not isinstance(coupon_stackable_with_vip, bool):\n            raise ValueError('stackable_with_vip must be bool')\n        if coupon_max_discount is not None:\n            if not isinstance(coupon_max_discount, int) or coupon_max_discount < 0:\n                raise ValueError('max_discount_cents must be a non-negative int')\n        if coupon_type == 'percent':\n            if coupon_value < 1 or coupon_value > 80:\n                raise ValueError('percent coupon value must be between 1 and 80')\n        else:\n            if coupon_value <= 0:\n                raise ValueError('fixed coupon value must be positive')\n        coupon_applicable = eligible_subtotal_cents >= coupon_min_subtotal\n\n    vip_rate = vip_rates[vip_tier]\n    if coupon is not None and coupon_applicable and (not coupon_stackable_with_vip):\n        vip_rate = 0\n\n    vip_discount_regular = (regular_after_qty_cents * vip_rate) // 100\n    vip_discount_sale = (sale_after_qty_cents * vip_rate) // 100\n    vip_discount_cents = vip_discount_regular + vip_discount_sale\n\n    regular_after_vip_cents = regular_after_qty_cents - vip_discount_regular\n    sale_after_vip_cents = sale_after_qty_cents - vip_discount_sale\n\n    coupon_discount_cents = 0\n    if coupon is not None and coupon_applicable:\n        coupon_base = (regular_after_vip_cents + sale_after_vip_cents) if coupon_scope == 'order' else regular_after_vip_cents\n        if coupon_base < 0:\n            coupon_base = 0\n        if coupon_type == 'percent':\n            coupon_discount_cents = (coupon_base * coupon_value) // 100\n        else:\n            coupon_discount_cents = coupon_value if coupon_value < coupon_base else coupon_base\n        if coupon_max_discount is not None and coupon_discount_cents > coupon_max_discount:\n            coupon_discount_cents = coupon_max_discount\n\n    discount_cents = quantity_discount_cents + vip_discount_cents + coupon_discount_cents\n    payable_cents = subtotal_cents - discount_cents\n    if payable_cents < 0:\n        payable_cents = 0\n\n    return {\n        'subtotal_cents': subtotal_cents,\n        'eligible_subtotal_cents': eligible_subtotal_cents,\n        'quantity_discount_cents': quantity_discount_cents,\n        'vip_discount_cents': vip_discount_cents,\n        'coupon_discount_cents': coupon_discount_cents,\n        'discount_cents': discount_cents,\n        'payable_cents': payable_cents,\n    }\n",
      "weight": 4
    },
    {
      "bug_description": "stackable_with_vip=False인 쿠폰이 '최소 금액 미달'로 실제 적용되지 않더라도 VIP 할인을 무조건 차단하여, 특정 상태 조합에서 VIP 할인 누락이 발생함(상태 기반/조합 규칙 버그).",
      "buggy_code": "def calculate_cart_total(items: list[dict], vip_tier: str = 'NONE', coupon: dict | None = None, coupon_already_redeemed: bool = False) -> dict[str, int]:\n    vip_rates = {'NONE': 0, 'SILVER': 2, 'GOLD': 5, 'PLATINUM': 8}\n    if vip_tier not in vip_rates:\n        raise ValueError(f'unknown vip_tier: {vip_tier!r}')\n    if not isinstance(items, list):\n        raise ValueError('items must be a list of item dicts')\n\n    allowed_categories = {'regular', 'sale', 'gift_card'}\n    subtotal_cents = 0\n    eligible_subtotal_cents = 0\n    quantity_discount_cents = 0\n    regular_after_qty_cents = 0\n    sale_after_qty_cents = 0\n\n    for idx, item in enumerate(items):\n        if not isinstance(item, dict):\n            raise ValueError(f'item {idx} must be a dict')\n        try:\n            price = item['unit_price_cents']\n            qty = item['quantity']\n            category = item['category']\n        except KeyError as e:\n            raise ValueError(f'missing required key {e.args[0]!r} in item {idx}')\n\n        if not isinstance(price, int):\n            raise ValueError(f'unit_price_cents must be int (item {idx})')\n        if not isinstance(qty, int):\n            raise ValueError(f'quantity must be int (item {idx})')\n        if not isinstance(category, str):\n            raise ValueError(f'category must be str (item {idx})')\n        if price < 0:\n            raise ValueError(f'unit_price_cents must be >= 0 (item {idx})')\n        if qty <= 0:\n            raise ValueError(f'quantity must be >= 1 (item {idx})')\n        if category not in allowed_categories:\n            raise ValueError(f'unknown category {category!r} (item {idx})')\n\n        line_total = price * qty\n        subtotal_cents += line_total\n        if category == 'gift_card':\n            continue\n        eligible_subtotal_cents += line_total\n\n        if category == 'regular':\n            if qty >= 10:\n                rate = 15\n            elif qty >= 5:\n                rate = 10\n            elif qty >= 3:\n                rate = 5\n            else:\n                rate = 0\n            line_qty_discount = (line_total * rate) // 100\n            quantity_discount_cents += line_qty_discount\n            regular_after_qty_cents += (line_total - line_qty_discount)\n        else:\n            sale_after_qty_cents += line_total\n\n    coupon_type = None\n    coupon_value = None\n    coupon_scope = 'order'\n    coupon_min_subtotal = 0\n    coupon_stackable_with_vip = True\n    coupon_max_discount = None\n    coupon_applicable = False\n\n    if coupon is not None:\n        if coupon_already_redeemed:\n            raise ValueError('coupon already redeemed')\n        if not isinstance(coupon, dict):\n            raise ValueError('coupon must be a dict or None')\n\n        coupon_type = coupon.get('type')\n        coupon_value = coupon.get('value')\n        coupon_scope = coupon.get('scope', 'order')\n        coupon_min_subtotal = coupon.get('min_subtotal_cents', 0)\n        coupon_stackable_with_vip = coupon.get('stackable_with_vip', True)\n        coupon_max_discount = coupon.get('max_discount_cents')\n\n        if coupon_type not in ('percent', 'fixed'):\n            raise ValueError(f'unknown coupon type: {coupon_type!r}')\n        if not isinstance(coupon_value, int):\n            raise ValueError('coupon value must be int')\n        if not isinstance(coupon_min_subtotal, int) or coupon_min_subtotal < 0:\n            raise ValueError('min_subtotal_cents must be a non-negative int')\n        if coupon_scope not in ('order', 'regular'):\n            raise ValueError(f'unknown coupon scope: {coupon_scope!r}')\n        if not isinstance(coupon_stackable_with_vip, bool):\n            raise ValueError('stackable_with_vip must be bool')\n        if coupon_max_discount is not None:\n            if not isinstance(coupon_max_discount, int) or coupon_max_discount < 0:\n                raise ValueError('max_discount_cents must be a non-negative int')\n        if coupon_type == 'percent':\n            if coupon_value < 1 or coupon_value > 80:\n                raise ValueError('percent coupon value must be between 1 and 80')\n        else:\n            if coupon_value <= 0:\n                raise ValueError('fixed coupon value must be positive')\n\n        coupon_applicable = eligible_subtotal_cents >= coupon_min_subtotal\n\n    vip_rate = vip_rates[vip_tier]\n    # BUG: coupon_applicable 여부와 무관하게 VIP를 차단\n    if coupon is not None and (not coupon_stackable_with_vip):\n        vip_rate = 0\n\n    vip_discount_regular = (regular_after_qty_cents * vip_rate) // 100\n    vip_discount_sale = (sale_after_qty_cents * vip_rate) // 100\n    vip_discount_cents = vip_discount_regular + vip_discount_sale\n\n    regular_after_vip_cents = regular_after_qty_cents - vip_discount_regular\n    sale_after_vip_cents = sale_after_qty_cents - vip_discount_sale\n\n    coupon_discount_cents = 0\n    if coupon is not None and coupon_applicable:\n        coupon_base = (regular_after_vip_cents + sale_after_vip_cents) if coupon_scope == 'order' else regular_after_vip_cents\n        if coupon_base < 0:\n            coupon_base = 0\n        if coupon_type == 'percent':\n            coupon_discount_cents = (coupon_base * coupon_value) // 100\n        else:\n            coupon_discount_cents = coupon_value if coupon_value < coupon_base else coupon_base\n        if coupon_max_discount is not None and coupon_discount_cents > coupon_max_discount:\n            coupon_discount_cents = coupon_max_discount\n\n    discount_cents = quantity_discount_cents + vip_discount_cents + coupon_discount_cents\n    payable_cents = subtotal_cents - discount_cents\n    if payable_cents < 0:\n        payable_cents = 0\n\n    return {\n        'subtotal_cents': subtotal_cents,\n        'eligible_subtotal_cents': eligible_subtotal_cents,\n        'quantity_discount_cents': quantity_discount_cents,\n        'vip_discount_cents': vip_discount_cents,\n        'coupon_discount_cents': coupon_discount_cents,\n        'discount_cents': discount_cents,\n        'payable_cents': payable_cents,\n    }\n",
      "weight": 5
    },
    {
      "bug_description": "쿠폰 적용 조건(min_subtotal_cents) 판정 시, 할인 제외 카테고리(gift_card)까지 포함한 subtotal을 사용하여 min_subtotal을 충족했다고 잘못 판단함(등가 분할/정책 위반).",
      "buggy_code": "def calculate_cart_total(items: list[dict], vip_tier: str = 'NONE', coupon: dict | None = None, coupon_already_redeemed: bool = False) -> dict[str, int]:\n    vip_rates = {'NONE': 0, 'SILVER': 2, 'GOLD': 5, 'PLATINUM': 8}\n    if vip_tier not in vip_rates:\n        raise ValueError(f'unknown vip_tier: {vip_tier!r}')\n    if not isinstance(items, list):\n        raise ValueError('items must be a list of item dicts')\n\n    allowed_categories = {'regular', 'sale', 'gift_card'}\n    subtotal_cents = 0\n    eligible_subtotal_cents = 0\n    quantity_discount_cents = 0\n    regular_after_qty_cents = 0\n    sale_after_qty_cents = 0\n\n    for idx, item in enumerate(items):\n        if not isinstance(item, dict):\n            raise ValueError(f'item {idx} must be a dict')\n        try:\n            price = item['unit_price_cents']\n            qty = item['quantity']\n            category = item['category']\n        except KeyError as e:\n            raise ValueError(f'missing required key {e.args[0]!r} in item {idx}')\n\n        if not isinstance(price, int) or not isinstance(qty, int) or not isinstance(category, str):\n            raise ValueError(f'invalid types in item {idx}')\n        if price < 0:\n            raise ValueError(f'unit_price_cents must be >= 0 (item {idx})')\n        if qty <= 0:\n            raise ValueError(f'quantity must be >= 1 (item {idx})')\n        if category not in allowed_categories:\n            raise ValueError(f'unknown category {category!r} (item {idx})')\n\n        line_total = price * qty\n        subtotal_cents += line_total\n        if category == 'gift_card':\n            continue\n        eligible_subtotal_cents += line_total\n\n        if category == 'regular':\n            if qty >= 10:\n                rate = 15\n            elif qty >= 5:\n                rate = 10\n            elif qty >= 3:\n                rate = 5\n            else:\n                rate = 0\n            line_qty_discount = (line_total * rate) // 100\n            quantity_discount_cents += line_qty_discount\n            regular_after_qty_cents += (line_total - line_qty_discount)\n        else:\n            sale_after_qty_cents += line_total\n\n    coupon_type = None\n    coupon_value = None\n    coupon_scope = 'order'\n    coupon_min_subtotal = 0\n    coupon_stackable_with_vip = True\n    coupon_max_discount = None\n    coupon_applicable = False\n\n    if coupon is not None:\n        if coupon_already_redeemed:\n            raise ValueError('coupon already redeemed')\n        if not isinstance(coupon, dict):\n            raise ValueError('coupon must be a dict or None')\n\n        coupon_type = coupon.get('type')\n        coupon_value = coupon.get('value')\n        coupon_scope = coupon.get('scope', 'order')\n        coupon_min_subtotal = coupon.get('min_subtotal_cents', 0)\n        coupon_stackable_with_vip = coupon.get('stackable_with_vip', True)\n        coupon_max_discount = coupon.get('max_discount_cents')\n\n        if coupon_type not in ('percent', 'fixed'):\n            raise ValueError(f'unknown coupon type: {coupon_type!r}')\n        if not isinstance(coupon_value, int):\n            raise ValueError('coupon value must be int')\n        if not isinstance(coupon_min_subtotal, int) or coupon_min_subtotal < 0:\n            raise ValueError('min_subtotal_cents must be a non-negative int')\n        if coupon_scope not in ('order', 'regular'):\n            raise ValueError(f'unknown coupon scope: {coupon_scope!r}')\n        if not isinstance(coupon_stackable_with_vip, bool):\n            raise ValueError('stackable_with_vip must be bool')\n        if coupon_max_discount is not None:\n            if not isinstance(coupon_max_discount, int) or coupon_max_discount < 0:\n                raise ValueError('max_discount_cents must be a non-negative int')\n        if coupon_type == 'percent':\n            if coupon_value < 1 or coupon_value > 80:\n                raise ValueError('percent coupon value must be between 1 and 80')\n        else:\n            if coupon_value <= 0:\n                raise ValueError('fixed coupon value must be positive')\n\n        # BUG: min_subtotal 판정을 subtotal(기프트카드 포함)로 수행\n        coupon_applicable = subtotal_cents >= coupon_min_subtotal\n\n    vip_rate = vip_rates[vip_tier]\n    if coupon is not None and coupon_applicable and (not coupon_stackable_with_vip):\n        vip_rate = 0\n\n    vip_discount_regular = (regular_after_qty_cents * vip_rate) // 100\n    vip_discount_sale = (sale_after_qty_cents * vip_rate) // 100\n    vip_discount_cents = vip_discount_regular + vip_discount_sale\n\n    regular_after_vip_cents = regular_after_qty_cents - vip_discount_regular\n    sale_after_vip_cents = sale_after_qty_cents - vip_discount_sale\n\n    coupon_discount_cents = 0\n    if coupon is not None and coupon_applicable:\n        coupon_base = (regular_after_vip_cents + sale_after_vip_cents) if coupon_scope == 'order' else regular_after_vip_cents\n        if coupon_base < 0:\n            coupon_base = 0\n        if coupon_type == 'percent':\n            coupon_discount_cents = (coupon_base * coupon_value) // 100\n        else:\n            coupon_discount_cents = coupon_value if coupon_value < coupon_base else coupon_base\n        if coupon_max_discount is not None and coupon_discount_cents > coupon_max_discount:\n            coupon_discount_cents = coupon_max_discount\n\n    discount_cents = quantity_discount_cents + vip_discount_cents + coupon_discount_cents\n    payable_cents = subtotal_cents - discount_cents\n    if payable_cents < 0:\n        payable_cents = 0\n\n    return {\n        'subtotal_cents': subtotal_cents,\n        'eligible_subtotal_cents': eligible_subtotal_cents,\n        'quantity_discount_cents': quantity_discount_cents,\n        'vip_discount_cents': vip_discount_cents,\n        'coupon_discount_cents': coupon_discount_cents,\n        'discount_cents': discount_cents,\n        'payable_cents': payable_cents,\n    }\n",
      "weight": 4
    },
    {
      "bug_description": "알 수 없는 vip_tier 입력에 대해 예외(ValueError)를 발생시키지 않고 'NONE'으로 간주해 계속 계산하는 오류 처리 누락 버그.",
      "buggy_code": "def calculate_cart_total(items: list[dict], vip_tier: str = 'NONE', coupon: dict | None = None, coupon_already_redeemed: bool = False) -> dict[str, int]:\n    vip_rates = {'NONE': 0, 'SILVER': 2, 'GOLD': 5, 'PLATINUM': 8}\n    # BUG: invalid vip_tier를 조용히 NONE 처리\n    if vip_tier not in vip_rates:\n        vip_tier = 'NONE'\n\n    if not isinstance(items, list):\n        raise ValueError('items must be a list of item dicts')\n\n    allowed_categories = {'regular', 'sale', 'gift_card'}\n    subtotal_cents = 0\n    eligible_subtotal_cents = 0\n    quantity_discount_cents = 0\n    regular_after_qty_cents = 0\n    sale_after_qty_cents = 0\n\n    for idx, item in enumerate(items):\n        if not isinstance(item, dict):\n            raise ValueError(f'item {idx} must be a dict')\n        try:\n            price = item['unit_price_cents']\n            qty = item['quantity']\n            category = item['category']\n        except KeyError as e:\n            raise ValueError(f'missing required key {e.args[0]!r} in item {idx}')\n\n        if not isinstance(price, int):\n            raise ValueError(f'unit_price_cents must be int (item {idx})')\n        if not isinstance(qty, int):\n            raise ValueError(f'quantity must be int (item {idx})')\n        if not isinstance(category, str):\n            raise ValueError(f'category must be str (item {idx})')\n        if price < 0:\n            raise ValueError(f'unit_price_cents must be >= 0 (item {idx})')\n        if qty <= 0:\n            raise ValueError(f'quantity must be >= 1 (item {idx})')\n        if category not in allowed_categories:\n            raise ValueError(f'unknown category {category!r} (item {idx})')\n\n        line_total = price * qty\n        subtotal_cents += line_total\n        if category == 'gift_card':\n            continue\n        eligible_subtotal_cents += line_total\n\n        if category == 'regular':\n            if qty >= 10:\n                rate = 15\n            elif qty >= 5:\n                rate = 10\n            elif qty >= 3:\n                rate = 5\n            else:\n                rate = 0\n            line_qty_discount = (line_total * rate) // 100\n            quantity_discount_cents += line_qty_discount\n            regular_after_qty_cents += (line_total - line_qty_discount)\n        else:\n            sale_after_qty_cents += line_total\n\n    coupon_type = None\n    coupon_value = None\n    coupon_scope = 'order'\n    coupon_min_subtotal = 0\n    coupon_stackable_with_vip = True\n    coupon_max_discount = None\n    coupon_applicable = False\n\n    if coupon is not None:\n        if coupon_already_redeemed:\n            raise ValueError('coupon already redeemed')\n        if not isinstance(coupon, dict):\n            raise ValueError('coupon must be a dict or None')\n\n        coupon_type = coupon.get('type')\n        coupon_value = coupon.get('value')\n        coupon_scope = coupon.get('scope', 'order')\n        coupon_min_subtotal = coupon.get('min_subtotal_cents', 0)\n        coupon_stackable_with_vip = coupon.get('stackable_with_vip', True)\n        coupon_max_discount = coupon.get('max_discount_cents')\n\n        if coupon_type not in ('percent', 'fixed'):\n            raise ValueError(f'unknown coupon type: {coupon_type!r}')\n        if not isinstance(coupon_value, int):\n            raise ValueError('coupon value must be int')\n        if not isinstance(coupon_min_subtotal, int) or coupon_min_subtotal < 0:\n            raise ValueError('min_subtotal_cents must be a non-negative int')\n        if coupon_scope not in ('order', 'regular'):\n            raise ValueError(f'unknown coupon scope: {coupon_scope!r}')\n        if not isinstance(coupon_stackable_with_vip, bool):\n            raise ValueError('stackable_with_vip must be bool')\n        if coupon_max_discount is not None:\n            if not isinstance(coupon_max_discount, int) or coupon_max_discount < 0:\n                raise ValueError('max_discount_cents must be a non-negative int')\n        if coupon_type == 'percent':\n            if coupon_value < 1 or coupon_value > 80:\n                raise ValueError('percent coupon value must be between 1 and 80')\n        else:\n            if coupon_value <= 0:\n                raise ValueError('fixed coupon value must be positive')\n\n        coupon_applicable = eligible_subtotal_cents >= coupon_min_subtotal\n\n    vip_rate = vip_rates[vip_tier]\n    if coupon is not None and coupon_applicable and (not coupon_stackable_with_vip):\n        vip_rate = 0\n\n    vip_discount_regular = (regular_after_qty_cents * vip_rate) // 100\n    vip_discount_sale = (sale_after_qty_cents * vip_rate) // 100\n    vip_discount_cents = vip_discount_regular + vip_discount_sale\n\n    regular_after_vip_cents = regular_after_qty_cents - vip_discount_regular\n    sale_after_vip_cents = sale_after_qty_cents - vip_discount_sale\n\n    coupon_discount_cents = 0\n    if coupon is not None and coupon_applicable:\n        coupon_base = (regular_after_vip_cents + sale_after_vip_cents) if coupon_scope == 'order' else regular_after_vip_cents\n        if coupon_base < 0:\n            coupon_base = 0\n        if coupon_type == 'percent':\n            coupon_discount_cents = (coupon_base * coupon_value) // 100\n        else:\n            coupon_discount_cents = coupon_value if coupon_value < coupon_base else coupon_base\n        if coupon_max_discount is not None and coupon_discount_cents > coupon_max_discount:\n            coupon_discount_cents = coupon_max_discount\n\n    discount_cents = quantity_discount_cents + vip_discount_cents + coupon_discount_cents\n    payable_cents = subtotal_cents - discount_cents\n    if payable_cents < 0:\n        payable_cents = 0\n\n    return {\n        'subtotal_cents': subtotal_cents,\n        'eligible_subtotal_cents': eligible_subtotal_cents,\n        'quantity_discount_cents': quantity_discount_cents,\n        'vip_discount_cents': vip_discount_cents,\n        'coupon_discount_cents': coupon_discount_cents,\n        'discount_cents': discount_cents,\n        'payable_cents': payable_cents,\n    }\n",
      "weight": 3
    },
    {
      "bug_description": "함수가 내부적으로 쿠폰 code를 전역/정적 상태로 '이미 사용됨' 처리하여, 동일한 coupon code로 두 번 호출하면 coupon_already_redeemed=False여도 ValueError가 발생하는 숨은 상태(state leak) 버그.",
      "buggy_code": "def calculate_cart_total(items: list[dict], vip_tier: str = 'NONE', coupon: dict | None = None, coupon_already_redeemed: bool = False) -> dict[str, int]:\n    vip_rates = {'NONE': 0, 'SILVER': 2, 'GOLD': 5, 'PLATINUM': 8}\n    if vip_tier not in vip_rates:\n        raise ValueError(f'unknown vip_tier: {vip_tier!r}')\n    if not isinstance(items, list):\n        raise ValueError('items must be a list of item dicts')\n\n    allowed_categories = {'regular', 'sale', 'gift_card'}\n    subtotal_cents = 0\n    eligible_subtotal_cents = 0\n    quantity_discount_cents = 0\n    regular_after_qty_cents = 0\n    sale_after_qty_cents = 0\n\n    for idx, item in enumerate(items):\n        if not isinstance(item, dict):\n            raise ValueError(f'item {idx} must be a dict')\n        try:\n            price = item['unit_price_cents']\n            qty = item['quantity']\n            category = item['category']\n        except KeyError as e:\n            raise ValueError(f'missing required key {e.args[0]!r} in item {idx}')\n\n        if not isinstance(price, int):\n            raise ValueError(f'unit_price_cents must be int (item {idx})')\n        if not isinstance(qty, int):\n            raise ValueError(f'quantity must be int (item {idx})')\n        if not isinstance(category, str):\n            raise ValueError(f'category must be str (item {idx})')\n        if price < 0:\n            raise ValueError(f'unit_price_cents must be >= 0 (item {idx})')\n        if qty <= 0:\n            raise ValueError(f'quantity must be >= 1 (item {idx})')\n        if category not in allowed_categories:\n            raise ValueError(f'unknown category {category!r} (item {idx})')\n\n        line_total = price * qty\n        subtotal_cents += line_total\n        if category == 'gift_card':\n            continue\n        eligible_subtotal_cents += line_total\n\n        if category == 'regular':\n            if qty >= 10:\n                rate = 15\n            elif qty >= 5:\n                rate = 10\n            elif qty >= 3:\n                rate = 5\n            else:\n                rate = 0\n            line_qty_discount = (line_total * rate) // 100\n            quantity_discount_cents += line_qty_discount\n            regular_after_qty_cents += (line_total - line_qty_discount)\n        else:\n            sale_after_qty_cents += line_total\n\n    coupon_type = None\n    coupon_value = None\n    coupon_scope = 'order'\n    coupon_min_subtotal = 0\n    coupon_stackable_with_vip = True\n    coupon_max_discount = None\n    coupon_applicable = False\n\n    if coupon is not None:\n        if coupon_already_redeemed:\n            raise ValueError('coupon already redeemed')\n        if not isinstance(coupon, dict):\n            raise ValueError('coupon must be a dict or None')\n\n        coupon_type = coupon.get('type')\n        coupon_value = coupon.get('value')\n        coupon_scope = coupon.get('scope', 'order')\n        coupon_min_subtotal = coupon.get('min_subtotal_cents', 0)\n        coupon_stackable_with_vip = coupon.get('stackable_with_vip', True)\n        coupon_max_discount = coupon.get('max_discount_cents')\n\n        if coupon_type not in ('percent', 'fixed'):\n            raise ValueError(f'unknown coupon type: {coupon_type!r}')\n        if not isinstance(coupon_value, int):\n            raise ValueError('coupon value must be int')\n        if not isinstance(coupon_min_subtotal, int) or coupon_min_subtotal < 0:\n            raise ValueError('min_subtotal_cents must be a non-negative int')\n        if coupon_scope not in ('order', 'regular'):\n            raise ValueError(f'unknown coupon scope: {coupon_scope!r}')\n        if not isinstance(coupon_stackable_with_vip, bool):\n            raise ValueError('stackable_with_vip must be bool')\n        if coupon_max_discount is not None:\n            if not isinstance(coupon_max_discount, int) or coupon_max_discount < 0:\n                raise ValueError('max_discount_cents must be a non-negative int')\n        if coupon_type == 'percent':\n            if coupon_value < 1 or coupon_value > 80:\n                raise ValueError('percent coupon value must be between 1 and 80')\n        else:\n            if coupon_value <= 0:\n                raise ValueError('fixed coupon value must be positive')\n\n        coupon_applicable = eligible_subtotal_cents >= coupon_min_subtotal\n\n        # BUG: hidden global/stateful coupon redemption tracking\n        if coupon_applicable:\n            code = coupon.get('code')\n            if isinstance(code, str):\n                if not hasattr(calculate_cart_total, '_redeemed_codes'):\n                    calculate_cart_total._redeemed_codes = set()\n                if code in calculate_cart_total._redeemed_codes:\n                    raise ValueError('coupon already redeemed')\n                calculate_cart_total._redeemed_codes.add(code)\n\n    vip_rate = vip_rates[vip_tier]\n    if coupon is not None and coupon_applicable and (not coupon_stackable_with_vip):\n        vip_rate = 0\n\n    vip_discount_regular = (regular_after_qty_cents * vip_rate) // 100\n    vip_discount_sale = (sale_after_qty_cents * vip_rate) // 100\n    vip_discount_cents = vip_discount_regular + vip_discount_sale\n\n    regular_after_vip_cents = regular_after_qty_cents - vip_discount_regular\n    sale_after_vip_cents = sale_after_qty_cents - vip_discount_sale\n\n    coupon_discount_cents = 0\n    if coupon is not None and coupon_applicable:\n        coupon_base = (regular_after_vip_cents + sale_after_vip_cents) if coupon_scope == 'order' else regular_after_vip_cents\n        if coupon_base < 0:\n            coupon_base = 0\n        if coupon_type == 'percent':\n            coupon_discount_cents = (coupon_base * coupon_value) // 100\n        else:\n            coupon_discount_cents = coupon_value if coupon_value < coupon_base else coupon_base\n        if coupon_max_discount is not None and coupon_discount_cents > coupon_max_discount:\n            coupon_discount_cents = coupon_max_discount\n\n    discount_cents = quantity_discount_cents + vip_discount_cents + coupon_discount_cents\n    payable_cents = subtotal_cents - discount_cents\n    if payable_cents < 0:\n        payable_cents = 0\n\n    return {\n        'subtotal_cents': subtotal_cents,\n        'eligible_subtotal_cents': eligible_subtotal_cents,\n        'quantity_discount_cents': quantity_discount_cents,\n        'vip_discount_cents': vip_discount_cents,\n        'coupon_discount_cents': coupon_discount_cents,\n        'discount_cents': discount_cents,\n        'payable_cents': payable_cents,\n    }\n",
      "weight": 4
    }
  ],
  "description_md": "## 문제 설명\n\n당신은 이커머스 서비스의 결제(Checkout) 팀에 합류한 QA 엔지니어입니다. 최근 프로모션이 복잡해지면서 장바구니 총액 계산 로직에서 경계값/조합 케이스 누락으로 과할인·할인 누락 이슈가 발생하고 있습니다.\n\n이번 과제의 목표는 `calculate_cart_total` 함수에 대해 **pytest 기반 테스트 코드**를 작성하여, 다양한 버그 구현을 최대한 많이 탐지하는 것입니다.\n\n---\n\n## 함수 역할\n\n`calculate_cart_total(items, vip_tier='NONE', coupon=None, coupon_already_redeemed=False) -> dict[str, int]`\n\n- 입력 장바구니(`items`)에 대해 할인 규칙(수량 할인, VIP 등급 할인, 쿠폰)을 적용해 **최종 결제 금액(payable)을 cents 단위 정수**로 계산합니다.\n- 반환값은 금액 breakdown을 담은 dict 입니다.\n\n### items 포맷\n각 아이템은 dict 이며, 다음 키를 포함해야 합니다.\n\n- `unit_price_cents`: int (0 이상)\n- `quantity`: int (1 이상)\n- `category`: `'regular' | 'sale' | 'gift_card'`\n\n> `gift_card`는 일반적으로 할인 제외 품목으로 취급됩니다.\n\n### VIP 등급\n- `vip_tier`는 `'NONE' | 'SILVER' | 'GOLD' | 'PLATINUM'` 중 하나입니다.\n\n### coupon 포맷(선택)\n쿠폰은 dict 이며 주요 키는 다음과 같습니다.\n\n- `code`: 선택(str). 계산 자체에는 영향이 없어야 합니다(식별용).\n- `type`: `'percent'` 또는 `'fixed'`\n- `value`: int\n- `min_subtotal_cents`: 선택(int, 0 이상). **할인 적용 가능 여부**를 판단하는 최소 금액 조건\n- `scope`: 선택. `'order'` 또는 `'regular'` (기본 `'order'`)\n- `stackable_with_vip`: 선택(bool). VIP 할인과의 중복 허용 여부\n- `max_discount_cents`: 선택(int, 0 이상). 쿠폰 할인 최대치\n\n### 예외/에러 처리\n- 입력이 잘못된 경우(Value 범위/타입/필수 키 누락/알 수 없는 vip_tier 등) `ValueError`가 발생해야 합니다.\n- `coupon`이 주어졌는데 `coupon_already_redeemed=True`이면 `ValueError`가 발생해야 합니다.\n\n---\n\n## 정상 동작 예시\n\n예시 1) 수량 할인 경계값 케이스\n- items: `[{'unit_price_cents': 1000, 'quantity': 3, 'category': 'regular'}]`\n- vip_tier: `'NONE'`\n- coupon: `None`\n\n예시 2) 여러 할인 조합\n- items: \n  - `{'unit_price_cents': 2000, 'quantity': 5, 'category': 'regular'}`\n  - `{'unit_price_cents': 1500, 'quantity': 1, 'category': 'sale'}`\n  - `{'unit_price_cents': 5000, 'quantity': 1, 'category': 'gift_card'}`\n- vip_tier: `'GOLD'`\n- coupon: `{'code': 'WELCOME10', 'type': 'percent', 'value': 10, 'min_subtotal_cents': 5000, 'scope': 'order', 'stackable_with_vip': True}`\n\n(테스트에서는 breakdown dict의 각 필드도 함께 검증해도 좋습니다.)\n\n---\n\n## 테스트 힌트 (중요)\n\n다음 역량을 종합적으로 평가합니다.\n\n- **Boundary Value Analysis(경계값 분석)**: 수량 할인 임계값(예: 2/3, 4/5, 9/10), 쿠폰 최소 금액 조건의 바로 전/후, 쿠폰 최대 할인 캡 근처 등\n- **Equivalence Partitioning(동등 분할)**: 카테고리별(regular/sale/gift_card), 쿠폰 타입별(percent/fixed), 쿠폰 scope별(order/regular), 쿠폰 적용 가능/불가(min_subtotal) 파티션\n- **Error Handling(에러 처리)**: 잘못된 vip_tier, 음수 가격, 0 또는 음수 수량, 잘못된 쿠폰 dict(unknown type, 범위 밖 value 등)\n- **State-based Testing(상태 기반 테스트)**: \n  - 같은 입력을 여러 번 호출해도 결과가 바뀌지 않는지(숨은 상태/캐시/누적 등)\n  - coupon_already_redeemed 상태와 쿠폰 적용/미적용의 상호작용\n  - 입력 객체(items/coupon)가 함수 호출 후 변형되지 않는지\n\n---\n\n## 수험자가 해야 할 일\n\n`pytest` 기반의 테스트 코드를 작성하여, 제공되는 여러 구현 중 **버그가 있는 구현들을 최대한 많이 실패(fail)하도록** 만드세요.\n\n- 정답 구현에서는 모든 테스트가 통과해야 합니다.\n- 버그 구현에서는 가능한 많은 테스트가 실패하도록 만드는 것이 목표입니다.\n",
  "initial_test_template": "import copy\nimport pytest\nfrom target import calculate_cart_total\n\n\ndef test_quantity_discount_boundaries():\n    # TODO: boundary value analysis\n    # - quantities around 2/3, 4/5, 9/10 (regular category)\n    # - ensure the right discount tier is applied and rounding is floor-based\n    pass\n\n\ndef test_coupon_min_subtotal_and_category_partitions():\n    # TODO: equivalence partitioning\n    # - carts with/without gift_card\n    # - ensure coupon min_subtotal is evaluated against the correct subtotal definition\n    # - try percent vs fixed coupons\n    pass\n\n\ndef test_vip_and_coupon_stackability_rules():\n    # TODO: state-based testing (rule interaction)\n    # - stackable_with_vip True vs False\n    # - include case where coupon exists but is NOT applicable due to min_subtotal\n    # - verify VIP discount behavior in each state\n    pass\n\n\ndef test_error_handling_invalid_inputs():\n    # TODO: error handling\n    # - invalid vip_tier should raise ValueError\n    # - negative unit_price_cents, zero/negative quantity\n    # - invalid coupon dicts (unknown type, out-of-range percent, negative fixed, invalid scope)\n    pass\n\n\ndef test_no_hidden_state_or_input_mutation_across_calls():\n    # TODO: state-based testing\n    # - calling twice with the same inputs should yield identical results\n    # - ensure items/coupon dicts are not mutated (use copy.deepcopy)\n    items = [{'unit_price_cents': 1000, 'quantity': 3, 'category': 'regular'}]\n    coupon = {'code': 'REPEATABLE', 'type': 'percent', 'value': 10, 'min_subtotal_cents': 0, 'scope': 'order', 'stackable_with_vip': True}\n    _items = copy.deepcopy(items)\n    _coupon = copy.deepcopy(coupon)\n    # TODO: call calculate_cart_total multiple times and compare results + input integrity\n    pass\n",
  "tags": [
    "hard",
    "boundary value analysis",
    "equivalence partitioning",
    "error handling",
    "state-based testing",
    "pricing",
    "cart",
    "discount",
    "python",
    "pytest",
    "unit-test"
  ],
  "difficulty": "Hard",
  "problem_id": "H01"
}