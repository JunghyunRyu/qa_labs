{
  "title": "중첩 사용자 정보 딕셔너리 검증 함수 테스트",
  "function_signature": "def validate_user_profile(user: dict) -> tuple[bool, list[str]]:",
  "golden_code": "from typing import Any\n\n\ndef validate_user_profile(user: dict) -> tuple[bool, list[str]]:\n    \"\"\"Validate a nested user profile dictionary.\n\n    Expected structure::\n\n        {\n            \"name\": str,              # non-empty, stripped, at most 100 chars\n            \"email\": str,             # basic pattern check: one '@', non-empty local/domain\n            \"address\": {\n                \"city\": str,         # non-empty, stripped\n                \"postal_code\": str   # 5-digit string or 5+4 format '12345-6789'\n            }\n        }\n\n    Validation rules:\n    - All top-level keys (name, email, address) must exist.\n    - address must be a dict containing keys city and postal_code.\n    - All required fields must be of type str (not None, not numbers, etc.).\n    - name and city must be non-empty after stripping whitespace.\n    - email must contain exactly one '@', with non-empty local part and domain part,\n      and domain must contain at least one '.' not at the start or end.\n    - postal_code must be:\n        * exactly 5 digits (e.g. '12345'), or\n        * '5digits-4digits' (e.g. '12345-6789').\n\n    Returns:\n        (is_valid, errors):\n            is_valid: bool, True if all checks pass.\n            errors: list of human-readable error messages for each failed rule.\n\n    The function never raises on bad input; it always returns (False, [..])\n    for invalid structures or types.\n    \"\"\"\n\n    errors: list[str] = []\n\n    if not isinstance(user, dict):\n        return False, [\"user must be a dict\"]\n\n    # Required top-level keys\n    required_top = [\"name\", \"email\", \"address\"]\n    for key in required_top:\n        if key not in user:\n            errors.append(f\"missing key: {key}\")\n\n    if errors:\n        return False, errors\n\n    name = user.get(\"name\")\n    email = user.get(\"email\")\n    address = user.get(\"address\")\n\n    # Type checks\n    if not isinstance(name, str):\n        errors.append(\"name must be a string\")\n    if not isinstance(email, str):\n        errors.append(\"email must be a string\")\n    if not isinstance(address, dict):\n        errors.append(\"address must be a dict\")\n\n    if errors:\n        return False, errors\n\n    # String content checks\n    if not name.strip():\n        errors.append(\"name cannot be empty\")\n    if len(name) > 100:\n        errors.append(\"name is too long (max 100 chars)\")\n\n    # Email validation (simple but robust for common mistakes)\n    if \"@\" not in email or email.count(\"@\") != 1:\n        errors.append(\"email must contain exactly one '@'\")\n    else:\n        local, domain = email.split(\"@\", 1)\n        if not local:\n            errors.append(\"email local part cannot be empty\")\n        if not domain:\n            errors.append(\"email domain cannot be empty\")\n        elif \".\" not in domain or domain.startswith(\".\") or domain.endswith(\".\"):\n            errors.append(\"email domain must contain a '.' not at the start or end\")\n\n    # Address nested structure\n    city = address.get(\"city\") if isinstance(address, dict) else None\n    postal_code = address.get(\"postal_code\") if isinstance(address, dict) else None\n\n    if \"city\" not in address:\n        errors.append(\"missing key: address.city\")\n    if \"postal_code\" not in address:\n        errors.append(\"missing key: address.postal_code\")\n\n    if city is not None and not isinstance(city, str):\n        errors.append(\"city must be a string\")\n    if postal_code is not None and not isinstance(postal_code, str):\n        errors.append(\"postal_code must be a string\")\n\n    if isinstance(city, str) and not city.strip():\n        errors.append(\"city cannot be empty\")\n\n    # Postal code format: '12345' or '12345-6789'\n    if isinstance(postal_code, str):\n        pc = postal_code\n        def is_five_digits(s: str) -> bool:\n            return len(s) == 5 and s.isdigit()\n\n        def is_five_plus_four(s: str) -> bool:\n            parts = s.split(\"-\")\n            if len(parts) != 2:\n                return False\n            first, second = parts\n            return len(first) == 5 and len(second) == 4 and first.isdigit() and second.isdigit()\n\n        if not (is_five_digits(pc) or is_five_plus_four(pc)):\n            errors.append(\"postal_code must be '12345' or '12345-6789' format\")\n\n    return len(errors) == 0, errors\n",
  "buggy_implementations": [
    {
      "bug_description": "address.postal_code가 5+4 형식일 때(예: '12345-6789')를 허용하지 않고 5자리 숫자만 허용하는 버그. 중첩 구조 내 특정 파티션에서만 실패.",
      "buggy_code": "from typing import Any\n\n\ndef validate_user_profile(user: dict) -> tuple[bool, list[str]]:\n    errors: list[str] = []\n\n    if not isinstance(user, dict):\n        return False, [\"user must be a dict\"]\n\n    required_top = [\"name\", \"email\", \"address\"]\n    for key in required_top:\n        if key not in user:\n            errors.append(f\"missing key: {key}\")\n\n    if errors:\n        return False, errors\n\n    name = user.get(\"name\")\n    email = user.get(\"email\")\n    address = user.get(\"address\")\n\n    if not isinstance(name, str):\n        errors.append(\"name must be a string\")\n    if not isinstance(email, str):\n        errors.append(\"email must be a string\")\n    if not isinstance(address, dict):\n        errors.append(\"address must be a dict\")\n\n    if errors:\n        return False, errors\n\n    if not name.strip():\n        errors.append(\"name cannot be empty\")\n    if len(name) > 100:\n        errors.append(\"name is too long (max 100 chars)\")\n\n    if \"@\" not in email or email.count(\"@\") != 1:\n        errors.append(\"email must contain exactly one '@'\")\n    else:\n        local, domain = email.split(\"@\", 1)\n        if not local:\n            errors.append(\"email local part cannot be empty\")\n        if not domain:\n            errors.append(\"email domain cannot be empty\")\n        elif \".\" not in domain or domain.startswith(\".\") or domain.endswith(\".\"):\n            errors.append(\"email domain must contain a '.' not at the start or end\")\n\n    city = address.get(\"city\") if isinstance(address, dict) else None\n    postal_code = address.get(\"postal_code\") if isinstance(address, dict) else None\n\n    if \"city\" not in address:\n        errors.append(\"missing key: address.city\")\n    if \"postal_code\" not in address:\n        errors.append(\"missing key: address.postal_code\")\n\n    if city is not None and not isinstance(city, str):\n        errors.append(\"city must be a string\")\n    if postal_code is not None and not isinstance(postal_code, str):\n        errors.append(\"postal_code must be a string\")\n\n    if isinstance(city, str) and not city.strip():\n        errors.append(\"city cannot be empty\")\n\n    # BUG: only allow exactly 5 digits, ignore 5+4 format\n    if isinstance(postal_code, str):\n        pc = postal_code\n        if not (len(pc) == 5 and pc.isdigit()):\n            errors.append(\"postal_code must be '12345' or '12345-6789' format\")\n\n    return len(errors) == 0, errors\n",
      "weight": 3
    },
    {
      "bug_description": "address가 dict가 아니어도(city, postal_code 접근 시) 예외가 발생하지 않고 조용히 통과시켜 버리는 버그. 중첩 구조 타입 검증이 불완전함.",
      "buggy_code": "from typing import Any\n\n\ndef validate_user_profile(user: dict) -> tuple[bool, list[str]]:\n    errors: list[str] = []\n\n    if not isinstance(user, dict):\n        return False, [\"user must be a dict\"]\n\n    required_top = [\"name\", \"email\", \"address\"]\n    for key in required_top:\n        if key not in user:\n            errors.append(f\"missing key: {key}\")\n\n    if errors:\n        return False, errors\n\n    name = user.get(\"name\")\n    email = user.get(\"email\")\n    address = user.get(\"address\")\n\n    if not isinstance(name, str):\n        errors.append(\"name must be a string\")\n    if not isinstance(email, str):\n        errors.append(\"email must be a string\")\n    # BUG: do not enforce address to be a dict here\n    # if not isinstance(address, dict):\n    #     errors.append(\"address must be a dict\")\n\n    if errors:\n        return False, errors\n\n    if not name.strip():\n        errors.append(\"name cannot be empty\")\n    if len(name) > 100:\n        errors.append(\"name is too long (max 100 chars)\")\n\n    if \"@\" not in email or email.count(\"@\") != 1:\n        errors.append(\"email must contain exactly one '@'\")\n    else:\n        local, domain = email.split(\"@\", 1)\n        if not local:\n            errors.append(\"email local part cannot be empty\")\n        if not domain:\n            errors.append(\"email domain cannot be empty\")\n        elif \".\" not in domain or domain.startswith(\".\") or domain.endswith(\".\"):\n            errors.append(\"email domain must contain a '.' not at the start or end\")\n\n    # BUG: if address is not a dict, the following will all be skipped silently\n    if isinstance(address, dict):\n        city = address.get(\"city\")\n        postal_code = address.get(\"postal_code\")\n\n        if \"city\" not in address:\n            errors.append(\"missing key: address.city\")\n        if \"postal_code\" not in address:\n            errors.append(\"missing key: address.postal_code\")\n\n        if city is not None and not isinstance(city, str):\n            errors.append(\"city must be a string\")\n        if postal_code is not None and not isinstance(postal_code, str):\n            errors.append(\"postal_code must be a string\")\n\n        if isinstance(city, str) and not city.strip():\n            errors.append(\"city cannot be empty\")\n\n        if isinstance(postal_code, str):\n            pc = postal_code\n            def is_five_digits(s: str) -> bool:\n                return len(s) == 5 and s.isdigit()\n\n            def is_five_plus_four(s: str) -> bool:\n                parts = s.split(\"-\")\n                if len(parts) != 2:\n                    return False\n                first, second = parts\n                return len(first) == 5 and len(second) == 4 and first.isdigit() and second.isdigit()\n\n            if not (is_five_digits(pc) or is_five_plus_four(pc)):\n                errors.append(\"postal_code must be '12345' or '12345-6789' format\")\n    # If address is not dict, we never report an error here\n\n    return len(errors) == 0, errors\n",
      "weight": 4
    },
    {
      "bug_description": "email 도메인에 '.' 가 없어도 통과시키는 버그. 유효한 이메일 형식에 대한 검증이 느슨해 특정 파티션에서 실패.",
      "buggy_code": "from typing import Any\n\n\ndef validate_user_profile(user: dict) -> tuple[bool, list[str]]:\n    errors: list[str] = []\n\n    if not isinstance(user, dict):\n        return False, [\"user must be a dict\"]\n\n    required_top = [\"name\", \"email\", \"address\"]\n    for key in required_top:\n        if key not in user:\n            errors.append(f\"missing key: {key}\")\n\n    if errors:\n        return False, errors\n\n    name = user.get(\"name\")\n    email = user.get(\"email\")\n    address = user.get(\"address\")\n\n    if not isinstance(name, str):\n        errors.append(\"name must be a string\")\n    if not isinstance(email, str):\n        errors.append(\"email must be a string\")\n    if not isinstance(address, dict):\n        errors.append(\"address must be a dict\")\n\n    if errors:\n        return False, errors\n\n    if not name.strip():\n        errors.append(\"name cannot be empty\")\n    if len(name) > 100:\n        errors.append(\"name is too long (max 100 chars)\")\n\n    if \"@\" not in email or email.count(\"@\") != 1:\n        errors.append(\"email must contain exactly one '@'\")\n    else:\n        local, domain = email.split(\"@\", 1)\n        if not local:\n            errors.append(\"email local part cannot be empty\")\n        if not domain:\n            errors.append(\"email domain cannot be empty\")\n        # BUG: skip domain '.' check entirely\n        # elif \".\" not in domain or domain.startswith(\".\") or domain.endswith(\".\"):\n        #     errors.append(\"email domain must contain a '.' not at the start or end\")\n\n    city = address.get(\"city\") if isinstance(address, dict) else None\n    postal_code = address.get(\"postal_code\") if isinstance(address, dict) else None\n\n    if \"city\" not in address:\n        errors.append(\"missing key: address.city\")\n    if \"postal_code\" not in address:\n        errors.append(\"missing key: address.postal_code\")\n\n    if city is not None and not isinstance(city, str):\n        errors.append(\"city must be a string\")\n    if postal_code is not None and not isinstance(postal_code, str):\n        errors.append(\"postal_code must be a string\")\n\n    if isinstance(city, str) and not city.strip():\n        errors.append(\"city cannot be empty\")\n\n    if isinstance(postal_code, str):\n        pc = postal_code\n        def is_five_digits(s: str) -> bool:\n            return len(s) == 5 and s.isdigit()\n\n        def is_five_plus_four(s: str) -> bool:\n            parts = s.split(\"-\")\n            if len(parts) != 2:\n                return False\n            first, second = parts\n            return len(first) == 5 and len(second) == 4 and first.isdigit() and second.isdigit()\n\n        if not (is_five_digits(pc) or is_five_plus_four(pc)):\n            errors.append(\"postal_code must be '12345' or '12345-6789' format\")\n\n    return len(errors) == 0, errors\n",
      "weight": 3
    },
    {
      "bug_description": "name 길이 제한(100자)을 잘못 구현하여 정확히 100자 이름을 잘못된 것으로 처리하는 off-by-one 경계값 버그.",
      "buggy_code": "from typing import Any\n\n\ndef validate_user_profile(user: dict) -> tuple[bool, list[str]]:\n    errors: list[str] = []\n\n    if not isinstance(user, dict):\n        return False, [\"user must be a dict\"]\n\n    required_top = [\"name\", \"email\", \"address\"]\n    for key in required_top:\n        if key not in user:\n            errors.append(f\"missing key: {key}\")\n\n    if errors:\n        return False, errors\n\n    name = user.get(\"name\")\n    email = user.get(\"email\")\n    address = user.get(\"address\")\n\n    if not isinstance(name, str):\n        errors.append(\"name must be a string\")\n    if not isinstance(email, str):\n        errors.append(\"email must be a string\")\n    if not isinstance(address, dict):\n        errors.append(\"address must be a dict\")\n\n    if errors:\n        return False, errors\n\n    if not name.strip():\n        errors.append(\"name cannot be empty\")\n    # BUG: reject 100 as well; should allow up to 100\n    if len(name) >= 100:\n        errors.append(\"name is too long (max 100 chars)\")\n\n    if \"@\" not in email or email.count(\"@\") != 1:\n        errors.append(\"email must contain exactly one '@'\")\n    else:\n        local, domain = email.split(\"@\", 1)\n        if not local:\n            errors.append(\"email local part cannot be empty\")\n        if not domain:\n            errors.append(\"email domain cannot be empty\")\n        elif \".\" not in domain or domain.startswith(\".\") or domain.endswith(\".\"):\n            errors.append(\"email domain must contain a '.' not at the start or end\")\n\n    city = address.get(\"city\") if isinstance(address, dict) else None\n    postal_code = address.get(\"postal_code\") if isinstance(address, dict) else None\n\n    if \"city\" not in address:\n        errors.append(\"missing key: address.city\")\n    if \"postal_code\" not in address:\n        errors.append(\"missing key: address.postal_code\")\n\n    if city is not None and not isinstance(city, str):\n        errors.append(\"city must be a string\")\n    if postal_code is not None and not isinstance(postal_code, str):\n        errors.append(\"postal_code must be a string\")\n\n    if isinstance(city, str) and not city.strip():\n        errors.append(\"city cannot be empty\")\n\n    if isinstance(postal_code, str):\n        pc = postal_code\n        def is_five_digits(s: str) -> bool:\n            return len(s) == 5 and s.isdigit()\n\n        def is_five_plus_four(s: str) -> bool:\n            parts = s.split(\"-\")\n            if len(parts) != 2:\n                return False\n            first, second = parts\n            return len(first) == 5 and len(second) == 4 and first.isdigit() and second.isdigit()\n\n        if not (is_five_digits(pc) or is_five_plus_four(pc)):\n            errors.append(\"postal_code must be '12345' or '12345-6789' format\")\n\n    return len(errors) == 0, errors\n",
      "weight": 2
    }
  ],
  "description_md": "## 문제 설명\n\n사용자 프로필 정보를 검증하는 백엔드 서비스에서, 외부 API나 데이터베이스에 저장되기 전에\n입력 데이터가 올바른지 확인하는 것이 매우 중요합니다. 특히 이름, 이메일, 주소(도시, 우편번호)\n같이 **중첩된 딕셔너리 구조**로 전달되는 데이터는 키 유무, 타입, 값 형식 등을 꼼꼼하게 검사해야 합니다.\n\n이 문제에서 여러분은 `validate_user_profile` 함수를 테스트해야 합니다. 이 함수는\n다음과 같은 중첩 딕셔너리를 입력으로 받습니다:\n\n```python\nuser = {\n    \"name\": \"Alice\",\n    \"email\": \"alice@example.com\",\n    \"address\": {\n        \"city\": \"Seoul\",\n        \"postal_code\": \"12345-6789\",\n    },\n}\n```\n\n### 함수 역할\n\n- 입력: `user` (dict)\n  - `name`: 문자열, 공백 제거 후 비어 있지 않아야 하며, 최대 100자까지 허용\n  - `email`: 문자열, `@`가 하나만 존재하고, 로컬/도메인 부분이 비어 있지 않으며,\n    도메인에 `.` 이 포함되어야 하는 등 기본 형식 검증 수행\n  - `address`: 딕셔너리\n    - `city`: 문자열, 공백 제거 후 비어 있지 않아야 함\n    - `postal_code`: 문자열, 다음 중 하나를 만족해야 함\n      - 정확히 5자리 숫자 (예: `\"12345\"`)\n      - 5자리-4자리 형식 (예: `\"12345-6789\"`)\n\n- 반환: `(is_valid, errors)` 형식의 튜플\n  - `is_valid`: 모든 검증을 통과하면 `True`, 하나라도 실패하면 `False`\n  - `errors`: 실패한 규칙에 대한 에러 메시지 문자열 리스트\n\n함수는 잘못된 입력(타입 오류, 키 누락 등)에 대해서도 **예외를 던지지 않고**,\n항상 `(False, [에러 메시지...])`를 반환해야 합니다.\n\n### 정상 동작 예시\n\n```python\nvalidate_user_profile({\n    \"name\": \"Alice\",\n    \"email\": \"alice@example.com\",\n    \"address\": {\"city\": \"Seoul\", \"postal_code\": \"12345\"},\n})\n# -> (True, [])\n\nvalidate_user_profile({\n    \"name\": \"Bob\",\n    \"email\": \"bob@test.co.kr\",\n    \"address\": {\"city\": \"Busan\", \"postal_code\": \"54321-0000\"},\n})\n# -> (True, [])\n```\n\n### 테스트에서 고려해야 할 것들\n\n이 문제는 다음과 같은 **데이터 구조 및 검증 테스트 스킬**을 연습하도록 설계되었습니다.\n\n- 중첩된 딕셔너리 구조에서 **필수 키 누락**, **잘못된 타입**, **비어있는 문자열** 등을 어떻게 검증할지\n- 이메일, 우편번호 등 특정 필드에 대해 **형식(valid format)** 검증을 어떻게 테스트할지\n- 정상 케이스뿐 아니라, 다양한 **에러 파티션**(예: address 전체가 잘못된 타입인 경우,\n  city만 잘못된 경우, postal_code 형식만 잘못된 경우 등)을 나누어 테스트하는 방법\n- 특히, `address` 내부 구조(`city`, `postal_code`)에 대한 테스트를 통해\n  **nested structures**와 **validation 로직**을 집중적으로 검증해야 합니다.\n\n구체적으로 다음과 같은 아이디어를 포함하는 테스트를 고민해 보세요 (힌트):\n\n- `user`가 딕셔너리가 아닌 경우, 혹은 `address`가 딕셔너리가 아닌 경우\n- `name`이 공백이거나, 아주 길거나(경계값: 99, 100, 101 글자 등)\n- `email`에 `@`가 없거나, 여러 개 있거나, 도메인에 `.` 이 없는 경우\n- `address`에 `city` 또는 `postal_code` 키가 누락된 경우\n- `postal_code`가 5자리 숫자는 맞지만, 5+4 형식을 제대로 처리하는지 여부\n- 중첩된 필드가 잘못된 타입(예: `city`가 int, `postal_code`가 None 등)인 경우\n\n### 여러분이 할 일\n\n제공된 `validate_user_profile` 함수에 대해 **pytest 기반의 단위 테스트 코드**를 작성하세요.\n플랫폼에는 여러 개의 버그가 심어진 구현들이 함께 존재합니다. 여러분의 테스트는\n이러한 buggy 구현들을 최대한 많이 실패시키고, 올바른 `golden` 구현만 통과하도록\n설계되어야 합니다.\n\n- 다양한 입력 케이스를 만들어, 중첩 딕셔너리 구조와 각 필드의 유효성 검사를 충분히 커버하세요.\n- `is_valid` 값과 `errors` 내용(길이, 특정 메시지 포함 여부 등)을 적절히 검증하는 assert를 작성하세요.\n- 특히 **data structure testing**, **nested structures**, **validation** 관점에서\n  빠뜨리기 쉬운 케이스를 적극적으로 포함해 보세요.\n",
  "initial_test_template": "import pytest\nfrom target import validate_user_profile\n\n\n# 기본적으로 올바른 사용자 프로필 예시\nVALID_USER = {\n    \"name\": \"Alice\",\n    \"email\": \"alice@example.com\",\n    \"address\": {\"city\": \"Seoul\", \"postal_code\": \"12345\"},\n}\n\n\ndef test_valid_minimal_profile():\n    \"\"\"완전히 올바른 중첩 구조가 True 를 반환하는지 확인하는 기본 테스트.\"\"\"\n    # TODO: VALID_USER 를 사용해 is_valid 가 True 이고 errors 가 빈 리스트인지 확인하세요.\n    pass\n\n\ndef test_address_nested_structure_required_keys():\n    \"\"\"address 내부에 city / postal_code 키 누락, 타입 오류 등을 테스트.\"\"\"\n    # TODO: address 가 dict 가 아닌 경우, city / postal_code 키가 없는 경우 등을 나누어\n    #       nested structure 검증이 제대로 동작하는지 테스트하세요.\n    pass\n\n\ndef test_postal_code_formats():\n    \"\"\"우편번호 형식(5자리, 5+4 형식)에 대한 검증 테스트.\"\"\"\n    # TODO: \"12345\" 와 \"12345-6789\" 등 유효한 케이스와, 잘못된 형식을 가진 케이스들을 작성하고\n    #       is_valid 와 errors 를 통해 bug 를 잡을 수 있도록 하세요.\n    pass\n\n\ndef test_email_and_name_validation_boundaries():\n    \"\"\"email 형식, name 길이/공백 등 문자열 유효성 경계값 테스트.\"\"\"\n    # TODO: '@' 가 없거나 여러 개인 이메일, 도메인에 '.' 이 없는 이메일,\n    #       name 길이가 99, 100, 101 인 경우 등을 테스트해 보세요.\n    pass\n",
  "tags": [
    "medium",
    "qa",
    "testing",
    "unit-test",
    "data structure testing",
    "nested structures",
    "validation",
    "dictionary"
  ],
  "difficulty": "Medium"
}