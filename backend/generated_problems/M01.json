{
  "title": "ShoppingCart 클래스 상태 기반 테스트",
  "function_signature": "class ShoppingCart:\n    def __init__(self) -> None:\n        ...\n\n    def add_item(self, name: str, price: float, quantity: int = 1) -> None:\n        ...\n\n    def remove_item(self, name: str) -> None:\n        ...\n\n    def get_total(self) -> float:\n        ...\n\n    def clear(self) -> None:\n        ...",
  "golden_code": "class ShoppingCart:\n    \"\"\"Simple in-memory shopping cart.\n\n    The cart stores items in a dict keyed by item name.\n\n    - add_item(name, price, quantity):\n        * name: non-empty string key for the item.\n        * price: non-negative float representing unit price.\n        * quantity: positive integer number of units to add.\n        If the same item name is added multiple times, quantities are accumulated\n        and the *latest* price overwrites the previous price.\n\n    - remove_item(name):\n        Removes the item with the given name if it exists. If the item does not\n        exist, this is a no-op (no exception is raised).\n\n    - get_total():\n        Returns the total cost as a float, computed as the sum of\n        price * quantity for all items currently in the cart.\n        Returns 0.0 if the cart is empty.\n\n    - clear():\n        Removes all items from the cart so that it becomes empty and\n        get_total() returns 0.0.\n\n    The class is stateful: method behavior depends on the current contents\n    of the cart and how it has been used previously.\n    \"\"\"\n\n    def __init__(self) -> None:\n        # Internal representation: {name: {\"price\": float, \"quantity\": int}}\n        self._items: dict[str, dict[str, float | int]] = {}\n\n    def add_item(self, name: str, price: float, quantity: int = 1) -> None:\n        \"\"\"Add an item to the cart.\n\n        Raises:\n            ValueError: if name is empty, price is negative,\n                        or quantity is not a positive integer.\n        \"\"\"\n        if not isinstance(name, str) or not name.strip():\n            raise ValueError(\"name must be a non-empty string\")\n        if price < 0:\n            raise ValueError(\"price must be non-negative\")\n        if not isinstance(quantity, int) or quantity <= 0:\n            raise ValueError(\"quantity must be a positive integer\")\n\n        if name in self._items:\n            # Accumulate quantity and overwrite price with latest\n            self._items[name][\"quantity\"] += quantity\n            self._items[name][\"price\"] = float(price)\n        else:\n            self._items[name] = {\"price\": float(price), \"quantity\": quantity}\n\n    def remove_item(self, name: str) -> None:\n        \"\"\"Remove an item from the cart by name.\n\n        If the item does not exist, this method does nothing.\n        \"\"\"\n        if name in self._items:\n            del self._items[name]\n\n    def get_total(self) -> float:\n        \"\"\"Return the total cost of all items in the cart.\n\n        The result is the sum of price * quantity for every item.\n        \"\"\"\n        total = 0.0\n        for data in self._items.values():\n            total += float(data[\"price\"]) * int(data[\"quantity\"])\n        return total\n\n    def clear(self) -> None:\n        \"\"\"Remove all items from the cart and reset its state.\"\"\"\n        self._items.clear()\n",
  "buggy_implementations": [
    {
      "bug_description": "상태 기반 버그: 기존 아이템에 대한 add_item이 가격을 덮어쓰지 않고 항상 초기 가격만 사용하여, 여러 번 가격이 바뀌는 시나리오에서 get_total()이 잘못 계산된다.",
      "buggy_code": "class ShoppingCart:\n    def __init__(self) -> None:\n        self._items: dict[str, dict[str, float | int]] = {}\n\n    def add_item(self, name: str, price: float, quantity: int = 1) -> None:\n        if not isinstance(name, str) or not name.strip():\n            raise ValueError(\"name must be a non-empty string\")\n        if price < 0:\n            raise ValueError(\"price must be non-negative\")\n        if not isinstance(quantity, int) or quantity <= 0:\n            raise ValueError(\"quantity must be a positive integer\")\n\n        if name in self._items:\n            # BUG: quantity만 누적하고, 가격은 이전 가격을 유지해야 하지만\n            # 여기서는 가격을 전혀 갱신하지 않는다.\n            self._items[name][\"quantity\"] += quantity\n        else:\n            self._items[name] = {\"price\": float(price), \"quantity\": quantity}\n\n    def remove_item(self, name: str) -> None:\n        if name in self._items:\n            del self._items[name]\n\n    def get_total(self) -> float:\n        total = 0.0\n        for data in self._items.values():\n            total += float(data[\"price\"]) * int(data[\"quantity\"])\n        return total\n\n    def clear(self) -> None:\n        self._items.clear()\n",
      "weight": 4
    },
    {
      "bug_description": "객체 라이프사이클/상태 공유 버그: _items가 클래스 변수로 정의되어 모든 ShoppingCart 인스턴스가 같은 카트를 공유한다.",
      "buggy_code": "class ShoppingCart:\n    # BUG: 인스턴스별이 아닌 클래스 전체가 공유하는 상태\n    _items: dict[str, dict[str, float | int]] = {}\n\n    def __init__(self) -> None:\n        # BUG: 별도 인스턴스 상태를 만들지 않음\n        pass\n\n    def add_item(self, name: str, price: float, quantity: int = 1) -> None:\n        if not isinstance(name, str) or not name.strip():\n            raise ValueError(\"name must be a non-empty string\")\n        if price < 0:\n            raise ValueError(\"price must be non-negative\")\n        if not isinstance(quantity, int) or quantity <= 0:\n            raise ValueError(\"quantity must be a positive integer\")\n\n        if name in self._items:\n            self._items[name][\"quantity\"] += quantity\n            self._items[name][\"price\"] = float(price)\n        else:\n            self._items[name] = {\"price\": float(price), \"quantity\": quantity}\n\n    def remove_item(self, name: str) -> None:\n        if name in self._items:\n            del self._items[name]\n\n    def get_total(self) -> float:\n        total = 0.0\n        for data in self._items.values():\n            total += float(data[\"price\"]) * int(data[\"quantity\"])\n        return total\n\n    def clear(self) -> None:\n        self._items.clear()\n",
      "weight": 5
    },
    {
      "bug_description": "상태 전이 누락 버그: remove_item이 존재하지 않는 아이템 이름에 대해 호출될 경우 ValueError를 던져야 한다고 가정하지는 않지만, 이 구현은 KeyError를 일으켜 객체의 정상 흐름을 깨뜨린다.",
      "buggy_code": "class ShoppingCart:\n    def __init__(self) -> None:\n        self._items: dict[str, dict[str, float | int]] = {}\n\n    def add_item(self, name: str, price: float, quantity: int = 1) -> None:\n        if not isinstance(name, str) or not name.strip():\n            raise ValueError(\"name must be a non-empty string\")\n        if price < 0:\n            raise ValueError(\"price must be non-negative\")\n        if not isinstance(quantity, int) or quantity <= 0:\n            raise ValueError(\"quantity must be a positive integer\")\n\n        if name in self._items:\n            self._items[name][\"quantity\"] += quantity\n            self._items[name][\"price\"] = float(price)\n        else:\n            self._items[name] = {\"price\": float(price), \"quantity\": quantity}\n\n    def remove_item(self, name: str) -> None:\n        # BUG: 존재하지 않는 키에 대해 KeyError 발생\n        del self._items[name]\n\n    def get_total(self) -> float:\n        total = 0.0\n        for data in self._items.values():\n            total += float(data[\"price\"]) * int(data[\"quantity\"])\n        return total\n\n    def clear(self) -> None:\n        self._items.clear()\n",
      "weight": 3
    },
    {
      "bug_description": "clear 메서드가 내부 상태를 완전히 리셋하지 않는 버그: clear 후에도 get_total()이 이전 합계를 반환한다.",
      "buggy_code": "class ShoppingCart:\n    def __init__(self) -> None:\n        self._items: dict[str, dict[str, float | int]] = {}\n        self._cached_total: float = 0.0\n\n    def add_item(self, name: str, price: float, quantity: int = 1) -> None:\n        if not isinstance(name, str) or not name.strip():\n            raise ValueError(\"name must be a non-empty string\")\n        if price < 0:\n            raise ValueError(\"price must be non-negative\")\n        if not isinstance(quantity, int) or quantity <= 0:\n            raise ValueError(\"quantity must be a positive integer\")\n\n        if name in self._items:\n            self._items[name][\"quantity\"] += quantity\n            self._items[name][\"price\"] = float(price)\n        else:\n            self._items[name] = {\"price\": float(price), \"quantity\": quantity}\n        # 간단한 캐시 업데이트\n        self._cached_total += float(price) * int(quantity)\n\n    def remove_item(self, name: str) -> None:\n        if name in self._items:\n            data = self._items[name]\n            self._cached_total -= float(data[\"price\"]) * int(data[\"quantity\"])\n            del self._items[name]\n\n    def get_total(self) -> float:\n        # BUG: 실제 항목이 비어 있어도 캐시된 값을 그대로 반환할 수 있음\n        return float(self._cached_total)\n\n    def clear(self) -> None:\n        # BUG: 캐시를 초기화하지 않아, 이후 get_total이 이전 합계를 반환\n        self._items.clear()\n",
      "weight": 4
    }
  ],
  "description_md": "## 문제 설명\n\n한 쇼핑몰 서비스에서 사용할 간단한 `ShoppingCart` 클래스를 개발 중입니다. 이 카트는 메모리 상에만 존재하며, 사용자 세션 동안 상품을 추가/삭제하고 총 금액을 계산하는 역할을 합니다. 실제 서비스에서도 매우 자주 등장하는 전형적인 상태 기반 객체입니다.\n\n여러 개발자가 이 클래스를 구현했지만, 일부 구현에는 미묘한 버그가 숨어 있습니다. 여러분의 임무는 **pytest 기반 테스트 코드**를 작성하여 이러한 버그를 최대한 많이 찾아내는 것입니다.\n\n### 클래스 역할\n\n`ShoppingCart`는 다음과 같은 메서드를 가집니다.\n\n- `add_item(name: str, price: float, quantity: int = 1) -> None`\n  - 이름이 `name`인 상품을 카트에 추가합니다.\n  - `price`는 단가, `quantity`는 수량입니다.\n  - 같은 `name`의 상품을 여러 번 추가하면 **수량은 누적**되고, **가격은 마지막에 추가된 가격으로 갱신**됩니다.\n  - 이름이 비어 있거나, 가격이 음수이거나, 수량이 0 이하인 경우에는 `ValueError`가 발생합니다.\n\n- `remove_item(name: str) -> None`\n  - 이름이 `name`인 상품을 카트에서 제거합니다.\n  - 해당 상품이 없으면 **아무 일도 일어나지 않아야 하며**, 예외가 발생하지 않습니다.\n\n- `get_total() -> float`\n  - 현재 카트에 담긴 모든 상품에 대해 `price * quantity`를 합산한 총 금액을 반환합니다.\n  - 카트가 비어 있으면 `0.0`을 반환합니다.\n\n- `clear() -> None`\n  - 카트에서 모든 상품을 제거하고, 총액도 0이 되도록 상태를 리셋합니다.\n\n이 클래스는 **상태 기반(stateful)** 이므로, 각 메서드의 동작은 **이전에 어떤 메서드가 어떤 순서로 호출되었는지**에 따라 달라집니다.\n\n### 예시 동작\n\n```python\ncart = ShoppingCart()\ncart.add_item(\"apple\", 1.0, 2)  # 2개, 단가 1.0\ncart.add_item(\"banana\", 2.5, 1)\nassert cart.get_total() == 1.0 * 2 + 2.5 * 1  # 4.5\n\ncart.add_item(\"apple\", 1.2, 1)  # apple 가격을 1.2로 변경, 수량 +1 (총 3개)\nassert cart.get_total() == 1.2 * 3 + 2.5 * 1\n\ncart.remove_item(\"banana\")\nassert cart.get_total() == 1.2 * 3\n\ncart.clear()\nassert cart.get_total() == 0.0\n```\n\n### 테스트 시 고려해야 할 포인트 (힌트)\n\n- **상태 기반 테스트 (state-based testing)**\n  - `add_item` → `get_total`, `add_item` → `remove_item` → `get_total`, `add_item` 여러 번 호출 후 `clear` 등, **여러 메서드를 조합한 시나리오**를 구성해 보세요.\n  - 같은 이름의 상품을 여러 번 추가하면서 가격이 변경되는 경우, 기대되는 총액이 제대로 반영되는지 확인해 보세요.\n\n- **클래스 테스트 (class testing)**\n  - `ShoppingCart` 인스턴스를 여러 개 생성했을 때, 서로의 상태가 **독립적**인지 확인해 보세요.\n  - 한 카트에서 작업한 내용이 다른 카트에 영향을 주지 않아야 합니다.\n\n- **객체 라이프사이클 (object lifecycle)**\n  - 새로 생성한 직후의 카트, 여러 상품을 추가/삭제한 중간 상태, `clear()` 호출 이후의 상태 등 **다양한 라이프사이클 단계**에서의 동작을 검증해 보세요.\n  - 특히 `clear()` 호출 후에 다시 `add_item()`/`get_total()`을 호출했을 때의 동작도 확인해 보세요.\n\n- **예외와 무해한(no-op) 연산**\n  - 유효하지 않은 인자(음수 가격, 0 이하 수량, 빈 이름 등)에 대해 적절히 `ValueError`가 발생하는지 테스트하세요.\n  - 존재하지 않는 상품 이름으로 `remove_item()`을 호출했을 때 **예외가 발생하지 않고** 상태가 그대로 유지되는지 검증해 보세요.\n\n### 수험자가 해야 할 일\n\n- 제공된 `ShoppingCart` 클래스를 임포트하여 **pytest 기반의 테스트 코드**를 작성하세요.\n- 가능한 한 다양한 상태 전이 시나리오를 만들어, 숨겨진 버그 구현들을 최대한 많이 찾아내는 것이 목표입니다.\n- 단일 메서드만이 아니라, 메서드 호출 순서와 객체 간의 상호 독립성까지 포함해 **상태 기반, 클래스 중심, 객체 라이프사이클** 관점에서 테스트를 설계해 보세요.\n",
  "initial_test_template": "import pytest\nfrom target import ShoppingCart\n\n\ndef test_initial_state_and_empty_total():\n    # TODO: 새로 생성한 카트의 get_total()이 0.0인지 확인\n    # TODO: 비어 있는 상태에서 remove_item, clear 호출 시 예외가 발생하지 않는지 확인\n    pass\n\n\ndef test_add_and_total_simple_flow():\n    # TODO: 여러 아이템을 추가한 후 총액이 price * quantity 합과 일치하는지 검증\n    # TODO: 같은 아이템 이름을 여러 번 추가하여 수량 누적 및 최신 가격 반영 여부 확인 (state-based)\n    pass\n\n\ndef test_remove_and_clear_affect_state():\n    # TODO: add_item -> remove_item -> get_total, add_item -> clear -> get_total 순서로\n    #       상태 변화가 올바른지 확인 (예: remove/clear 후 총액이 갱신되는지)\n    pass\n\n\ndef test_multiple_carts_independent_lifecycle():\n    # TODO: ShoppingCart 인스턴스를 2개 이상 생성하여, 한 카트의 연산이 다른 카트에\n    #       영향을 주지 않는지 검증 (객체 라이프사이클 및 상태 독립성)\n    pass\n",
  "tags": [
    "medium",
    "qa",
    "testing",
    "unit-test",
    "state-based testing",
    "class testing",
    "object lifecycle",
    "ecommerce",
    "shopping-cart"
  ],
  "difficulty": "Medium"
}