{
  "title": "이메일 주소 유효성 검증 함수 테스트",
  "function_signature": "def is_valid_email(email: str) -> bool:",
  "golden_code": "def is_valid_email(email: str) -> bool:\n    '''\n    Validate an email address for a typical web service signup flow.\n\n    The function returns True only when ALL rules below are satisfied.\n    It is intentionally stricter than full RFC 5322 to match common product constraints.\n\n    Rules:\n    - Type: `email` must be `str`, otherwise raise TypeError.\n    - Whitespace: leading/trailing whitespace is not allowed; any whitespace char is invalid.\n    - Structure: exactly one '@' splitting into local-part and domain.\n    - Length constraints:\n      * total length <= 254\n      * local-part length: 1..64\n      * each domain label length: 1..63\n    - Local-part allowed characters:\n      * ASCII letters/digits\n      * special: ! # $ % & ' * + / = ? ^ _ ` { | } ~ -\n      * dot '.' is allowed but:\n        - cannot be the first or last character\n        - cannot appear consecutively ('..' invalid)\n    - Domain rules:\n      * must contain at least one dot (e.g., example.com)\n      * labels consist of ASCII letters/digits/hyphen\n      * labels cannot start or end with '-'\n      * no empty labels (no consecutive dots)\n      * TLD (last label) must be ASCII letters only, length 2..63\n\n    Returns:\n      bool: True if valid, False otherwise.\n    '''\n    if not isinstance(email, str):\n        raise TypeError('email must be a str')\n\n    if email == '':\n        return False\n\n    # Reject leading/trailing whitespace and any whitespace character.\n    if email != email.strip():\n        return False\n    if any(ch.isspace() for ch in email):\n        return False\n\n    if len(email) > 254:\n        return False\n\n    parts = email.split('@')\n    if len(parts) != 2:\n        return False\n    local, domain = parts\n\n    if not local or not domain:\n        return False\n\n    if len(local) > 64:\n        return False\n\n    # ASCII-only policy (common in many products; avoids IDN complexity).\n    if not local.isascii() or not domain.isascii():\n        return False\n\n    if local[0] == '.' or local[-1] == '.':\n        return False\n    if '..' in local:\n        return False\n\n    allowed_base = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789')\n    allowed = set(allowed_base)\n    for ch in \"!#$%&'*+/=?^_`{|}~-.\":\n        allowed.add(ch)\n\n    for ch in local:\n        if ch not in allowed:\n            return False\n\n    if domain[0] == '.' or domain[-1] == '.':\n        return False\n    if '..' in domain:\n        return False\n\n    labels = domain.split('.')\n    if len(labels) < 2:\n        return False\n\n    for label in labels:\n        if label == '':\n            return False\n        if len(label) > 63:\n            return False\n        if label[0] == '-' or label[-1] == '-':\n            return False\n        for ch in label:\n            if not (ch.isascii() and (ch.isalnum() or ch == '-')):\n                return False\n\n    tld = labels[-1]\n    if not (2 <= len(tld) <= 63):\n        return False\n    if not (tld.isascii() and tld.isalpha()):\n        return False\n\n    return True\n",
  "buggy_implementations": [
    {
      "bug_description": "경계값 처리 오류: local-part 길이가 정확히 64인 유효 이메일까지 잘못 거부(off-by-one)합니다. (boundary value analysis)",
      "buggy_code": "def is_valid_email(email: str) -> bool:\n    '''Buggy: off-by-one on local-part max length (rejects length 64).'''\n    if not isinstance(email, str):\n        raise TypeError('email must be a str')\n\n    if email == '':\n        return False\n    if email != email.strip():\n        return False\n    if any(ch.isspace() for ch in email):\n        return False\n    if len(email) > 254:\n        return False\n\n    parts = email.split('@')\n    if len(parts) != 2:\n        return False\n    local, domain = parts\n    if not local or not domain:\n        return False\n\n    # BUG: should be > 64, but uses >= 64\n    if len(local) >= 64:\n        return False\n\n    if not local.isascii() or not domain.isascii():\n        return False\n\n    if local[0] == '.' or local[-1] == '.':\n        return False\n    if '..' in local:\n        return False\n\n    allowed_base = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789')\n    allowed = set(allowed_base)\n    for ch in \"!#$%&'*+/=?^_`{|}~-.\":\n        allowed.add(ch)\n    for ch in local:\n        if ch not in allowed:\n            return False\n\n    if domain[0] == '.' or domain[-1] == '.':\n        return False\n    if '..' in domain:\n        return False\n    labels = domain.split('.')\n    if len(labels) < 2:\n        return False\n\n    for label in labels:\n        if label == '':\n            return False\n        if len(label) > 63:\n            return False\n        if label[0] == '-' or label[-1] == '-':\n            return False\n        for ch in label:\n            if not (ch.isascii() and (ch.isalnum() or ch == '-')):\n                return False\n\n    tld = labels[-1]\n    if not (2 <= len(tld) <= 63):\n        return False\n    if not (tld.isascii() and tld.isalpha()):\n        return False\n\n    return True\n",
      "weight": 4
    },
    {
      "bug_description": "동치 분할 누락: local-part에서 연속된 점('..')을 허용하여 'a..b@example.com' 같은 입력이 잘못 통과합니다. (equivalence partitioning)",
      "buggy_code": "def is_valid_email(email: str) -> bool:\n    '''Buggy: forgets to reject consecutive dots in local-part.'''\n    if not isinstance(email, str):\n        raise TypeError('email must be a str')\n\n    if email == '':\n        return False\n    if email != email.strip():\n        return False\n    if any(ch.isspace() for ch in email):\n        return False\n    if len(email) > 254:\n        return False\n\n    parts = email.split('@')\n    if len(parts) != 2:\n        return False\n    local, domain = parts\n\n    if not local or not domain:\n        return False\n    if len(local) > 64:\n        return False\n\n    if not local.isascii() or not domain.isascii():\n        return False\n\n    if local[0] == '.' or local[-1] == '.':\n        return False\n\n    # BUG: missing '..' check in local\n\n    allowed_base = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789')\n    allowed = set(allowed_base)\n    for ch in \"!#$%&'*+/=?^_`{|}~-.\":\n        allowed.add(ch)\n\n    for ch in local:\n        if ch not in allowed:\n            return False\n\n    if domain[0] == '.' or domain[-1] == '.':\n        return False\n    if '..' in domain:\n        return False\n\n    labels = domain.split('.')\n    if len(labels) < 2:\n        return False\n\n    for label in labels:\n        if label == '':\n            return False\n        if len(label) > 63:\n            return False\n        if label[0] == '-' or label[-1] == '-':\n            return False\n        for ch in label:\n            if not (ch.isascii() and (ch.isalnum() or ch == '-')):\n                return False\n\n    tld = labels[-1]\n    if not (2 <= len(tld) <= 63):\n        return False\n    if not (tld.isascii() and tld.isalpha()):\n        return False\n\n    return True\n",
      "weight": 5
    },
    {
      "bug_description": "도메인 검증 불충분: 도메인 라벨의 시작/끝 하이픈 및 빈 라벨(연속된 점)을 제대로 거부하지 않아 'user@-example.com', 'user@example..com' 같은 케이스가 통과할 수 있습니다. (equivalence partitioning, boundary conditions on labels)",
      "buggy_code": "def is_valid_email(email: str) -> bool:\n    '''Buggy: domain label rules are incomplete (hyphen/empty label issues).'''\n    if not isinstance(email, str):\n        raise TypeError('email must be a str')\n\n    if email == '':\n        return False\n    if email != email.strip():\n        return False\n    if any(ch.isspace() for ch in email):\n        return False\n    if len(email) > 254:\n        return False\n\n    parts = email.split('@')\n    if len(parts) != 2:\n        return False\n    local, domain = parts\n    if not local or not domain:\n        return False\n    if len(local) > 64:\n        return False\n\n    if not local.isascii() or not domain.isascii():\n        return False\n\n    if local[0] == '.' or local[-1] == '.':\n        return False\n    if '..' in local:\n        return False\n\n    allowed_base = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789')\n    allowed = set(allowed_base)\n    for ch in \"!#$%&'*+/=?^_`{|}~-.\":\n        allowed.add(ch)\n    for ch in local:\n        if ch not in allowed:\n            return False\n\n    # BUG: only checks dot existence; does not validate label boundaries or empty labels.\n    if '.' not in domain:\n        return False\n\n    # BUG: insufficient label validation\n    labels = domain.split('.')\n    for label in labels:\n        # does not reject empty labels and does not check hyphen at start/end\n        if len(label) > 63:\n            return False\n        for ch in label:\n            if not (ch.isascii() and (ch.isalnum() or ch == '-')):\n                return False\n\n    tld = labels[-1]\n    if not (2 <= len(tld) <= 63):\n        return False\n    if not (tld.isascii() and tld.isalpha()):\n        return False\n\n    return True\n",
      "weight": 4
    },
    {
      "bug_description": "예외/입력 처리 정책 위반: non-str 입력에서 TypeError를 발생시키지 않고 문자열로 캐스팅하거나, 앞뒤 공백을 strip하여 ' user@example.com ' 같은 입력을 유효로 처리할 수 있습니다. (error handling, input sanitization expectations)",
      "buggy_code": "def is_valid_email(email: str) -> bool:\n    '''Buggy: does not raise TypeError for non-str and silently strips whitespace.'''\n    # BUG: should raise TypeError for non-str\n    if email is None:\n        return False\n    email = str(email).strip()  # BUG: makes leading/trailing whitespace acceptable\n\n    if email == '':\n        return False\n    if any(ch.isspace() for ch in email):\n        return False\n    if len(email) > 254:\n        return False\n\n    parts = email.split('@')\n    if len(parts) != 2:\n        return False\n    local, domain = parts\n    if not local or not domain:\n        return False\n\n    if len(local) > 64:\n        return False\n\n    if not local.isascii() or not domain.isascii():\n        return False\n\n    if local[0] == '.' or local[-1] == '.':\n        return False\n    if '..' in local:\n        return False\n\n    allowed_base = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789')\n    allowed = set(allowed_base)\n    for ch in \"!#$%&'*+/=?^_`{|}~-.\":\n        allowed.add(ch)\n    for ch in local:\n        if ch not in allowed:\n            return False\n\n    if domain[0] == '.' or domain[-1] == '.':\n        return False\n    if '..' in domain:\n        return False\n\n    labels = domain.split('.')\n    if len(labels) < 2:\n        return False\n\n    for label in labels:\n        if label == '':\n            return False\n        if len(label) > 63:\n            return False\n        if label[0] == '-' or label[-1] == '-':\n            return False\n        for ch in label:\n            if not (ch.isascii() and (ch.isalnum() or ch == '-')):\n                return False\n\n    tld = labels[-1]\n    if not (2 <= len(tld) <= 63):\n        return False\n    if not (tld.isascii() and tld.isalpha()):\n        return False\n\n    return True\n",
      "weight": 3
    }
  ],
  "description_md": "## 문제 설명\n\n당신은 회원가입/계정 찾기 API를 운영하는 팀의 SDET입니다. 서비스에서는 이메일 주소를 사용자 식별자로 사용하며, 잘못된 이메일이 저장되면 다음과 같은 문제가 발생할 수 있습니다:\n\n- 인증 메일 발송 실패로 인한 이탈 증가\n- 고객센터 문의 증가\n- 데이터 정합성 문제 (동일 사용자 중복 생성 등)\n\n이를 방지하기 위해, 아래 함수 `is_valid_email`의 동작을 **pytest 기반 테스트 코드로 검증**해야 합니다.\n\n---\n\n### 함수 역할\n\n- 함수명: `is_valid_email(email: str) -> bool`\n- 입력: 이메일 주소 문자열 `email`\n- 반환: 유효하면 `True`, 유효하지 않으면 `False`\n- 예외: 특정 잘못된 입력 타입에 대해서는 예외를 발생시키도록 설계되어 있습니다(정확한 정책은 docstring 및 테스트 설계로 확인).\n\n---\n\n### 정상 동작 예시\n\n- `is_valid_email('user.name+tag@example.com')` -> `True`\n- `is_valid_email('a..b@example.com')` -> `False`\n\n(위 예시는 일부 규칙을 암시하며, 전체 규칙은 함수 문서와 테스트 설계를 통해 커버해야 합니다.)\n\n---\n\n### 테스트 힌트 (의도적으로 완전한 정답을 직접 제공하지 않음)\n\n테스트는 아래 관점들을 균형 있게 다루는 것이 중요합니다:\n\n1. **Equivalence Partitioning (동치 분할)**\n   - 유효한 이메일 vs 유효하지 않은 이메일 파티션\n   - `@` 개수(0개/1개/2개 이상)\n   - local-part의 점(`.`) 사용 패턴(연속 점, 시작/끝 점 등)\n   - 허용/비허용 특수문자\n   - 도메인에 점이 없는 경우, 라벨이 비어 있는 경우, 하이픈 위치 등\n\n2. **Boundary Value Analysis (경계값 분석)**\n   - 전체 길이, local-part 길이, 도메인 라벨 길이 등의 경계\n   - 최소 길이(비어있음)와 최대 길이 직전/직후\n\n3. **Error Handling (예외 및 오류 처리)**\n   - `None`, 숫자, bytes 등 문자열이 아닌 입력\n   - 공백이 포함되거나 앞뒤 공백이 있는 입력이 어떻게 처리되어야 하는지\n\n---\n\n### 수험자가 할 일\n\n- `pytest`로 **테스트 코드만 작성**하세요. (함수 구현 수정 금지)\n- 최대한 다양한 케이스를 통해, 숨어 있는 버그 구현들을 많이 잡아내는 것이 목표입니다.\n- 테스트는 읽기 쉽고 유지보수 가능하게 작성하는 것을 권장합니다(케이스 분류, 파라미터라이즈 등).\n",
  "initial_test_template": "import pytest\nfrom target import is_valid_email\n\n\ndef test_equivalence_partition_valid_emails():\n    # TODO: 동치 분할 관점에서 '유효한' 이메일 케이스들을 선정하세요.\n    # 예: 대소문자, 점/플러스 등 허용 특수문자 조합, 서브도메인 등\n    pass\n\n\ndef test_equivalence_partition_invalid_formats():\n    # TODO: 동치 분할 관점에서 '유효하지 않은' 포맷들을 선정하세요.\n    # 예: '@'가 없거나 2개 이상, local-part 규칙 위반(연속 점/시작·끝 점),\n    #     도메인 규칙 위반(연속 점, 빈 라벨, 하이픈 위치 등)\n    pass\n\n\ndef test_boundary_value_lengths():\n    # TODO: 경계값 분석: local-part 길이 64 주변, 전체 길이 254 주변,\n    #     도메인 라벨 길이 63 주변 등을 구성해 검증하세요.\n    # 힌트: 문자열을 반복 생성하여 경계 길이 입력을 만들 수 있습니다.\n    pass\n\n\ndef test_error_handling_non_string_inputs():\n    # TODO: error handling: None, int, bytes 등 비문자열 입력에서\n    #     어떤 예외가 발생해야 하는지(또는 발생하지 않아야 하는지) 검증하세요.\n    pass\n",
  "tags": [
    "medium",
    "unit-test",
    "pytest",
    "string",
    "email",
    "boundary value analysis",
    "equivalence partitioning",
    "error handling"
  ],
  "difficulty": "Medium",
  "problem_id": "M01"
}