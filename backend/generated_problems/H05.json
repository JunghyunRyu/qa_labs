{
  "title": "주문 전체 워크플로우 통합 함수 테스트",
  "function_signature": "def process_order_workflow(order: dict, inventory: dict, payment_methods: dict) -> dict:",
  "golden_code": "from copy import deepcopy\n\n\ndef process_order_workflow(order: dict, inventory: dict, payment_methods: dict) -> dict:\n    \"\"\"Process an order through validation, inventory check, payment, and shipping preparation.\n\n    This function simulates an end-to-end e-commerce order workflow by coordinating\n    four conceptual steps:\n\n    1. Order validation (validate_order)\n       - Required keys in `order`: \"id\" (str), \"items\" (list), \"total\" (number),\n         \"payment_method\" (str), \"shipping_address\" (str).\n       - `items` is a list of {\"sku\": str, \"qty\": int, \"unit_price\": number}.\n       - `total` must equal the sum of qty * unit_price for all items.\n       - All quantities must be positive integers.\n\n    2. Inventory check (check_inventory)\n       - `inventory` is a mapping {sku: available_qty (int >= 0)}.\n       - Every item.sku must exist in inventory and have enough quantity.\n\n    3. Payment processing (process_payment)\n       - `payment_methods` is a mapping {payment_method: {\"active\": bool, \"limit\": number}}.\n       - The selected payment method must exist, be active, and have limit >= order.total.\n       - On success, the method's remaining limit is reduced (in a copy, not the input).\n\n    4. Shipping preparation (prepare_shipping)\n       - Returns a generated shipping label id and sets status to \"ready_to_ship\".\n\n    Returns a result dict with at least the following keys on success:\n      {\n        \"order_id\": str,\n        \"status\": \"ready_to_ship\",\n        \"charged_amount\": float,\n        \"shipping_label_id\": str,\n        \"remaining_inventory\": dict,\n        \"payment_state\": dict\n      }\n\n    On failure, returns a dict with:\n      {\n        \"order_id\": str | None,\n        \"status\": \"failed\",\n        \"reason\": str,\n        \"step\": str  # one of: \"validation\", \"inventory\", \"payment\"\n      }\n\n    The function must not mutate the input `order`, `inventory`, or `payment_methods`.\n    It should treat them as read-only and work on copies where state changes are needed.\n    \"\"\"\n\n    # Defensive copy to avoid mutating caller's data\n    order_in = deepcopy(order)\n    inventory_in = deepcopy(inventory)\n    payment_methods_in = deepcopy(payment_methods)\n\n    def validate_order(o: dict) -> tuple[bool, str | None]:\n        # Basic structure validation\n        required_keys = {\"id\", \"items\", \"total\", \"payment_method\", \"shipping_address\"}\n        missing = required_keys - set(o.keys())\n        if missing:\n            return False, f\"missing_fields: {sorted(missing)}\"\n\n        if not isinstance(o[\"id\"], str) or not o[\"id\"]:\n            return False, \"invalid_order_id\"\n\n        if not isinstance(o[\"items\"], list) or len(o[\"items\"]) == 0:\n            return False, \"no_items\"\n\n        # Validate items and compute expected total\n        expected_total = 0.0\n        for idx, item in enumerate(o[\"items\"]):\n            if not isinstance(item, dict):\n                return False, f\"invalid_item_type_at_{idx}\"\n            for key in (\"sku\", \"qty\", \"unit_price\"):\n                if key not in item:\n                    return False, f\"missing_item_field_{key}_at_{idx}\"\n\n            sku = item[\"sku\"]\n            qty = item[\"qty\"]\n            price = item[\"unit_price\"]\n\n            if not isinstance(sku, str) or not sku:\n                return False, f\"invalid_sku_at_{idx}\"\n            if not isinstance(qty, int) or qty <= 0:\n                return False, f\"invalid_qty_at_{idx}\"\n            if not isinstance(price, (int, float)) or price < 0:\n                return False, f\"invalid_price_at_{idx}\"\n\n            expected_total += qty * float(price)\n\n        # Validate total with a small tolerance for floats\n        provided_total = o[\"total\"]\n        if not isinstance(provided_total, (int, float)):\n            return False, \"invalid_total_type\"\n        if abs(float(provided_total) - expected_total) > 0.01:\n            return False, \"total_mismatch\"\n\n        # Basic payment method and address validation\n        if not isinstance(o[\"payment_method\"], str) or not o[\"payment_method\"]:\n            return False, \"invalid_payment_method\"\n        if not isinstance(o[\"shipping_address\"], str) or not o[\"shipping_address\"].strip():\n            return False, \"invalid_shipping_address\"\n\n        return True, None\n\n    def check_inventory(o: dict, inv: dict) -> tuple[bool, str | None, dict | None]:\n        remaining = deepcopy(inv)\n        for idx, item in enumerate(o[\"items\"]):\n            sku = item[\"sku\"]\n            qty = item[\"qty\"]\n            if sku not in remaining:\n                return False, f\"sku_not_found:{sku}\", None\n            available = remaining[sku]\n            if not isinstance(available, int) or available < 0:\n                return False, f\"invalid_inventory_for:{sku}\", None\n            if available < qty:\n                return False, f\"insufficient_inventory_for:{sku}\", None\n            remaining[sku] = available - qty\n        return True, None, remaining\n\n    def process_payment(o: dict, methods: dict) -> tuple[bool, str | None, dict | None, float]:\n        method_key = o[\"payment_method\"]\n        if method_key not in methods:\n            return False, \"payment_method_not_found\", None, 0.0\n        method = methods[method_key]\n        if not isinstance(method, dict):\n            return False, \"invalid_payment_method_config\", None, 0.0\n        active = method.get(\"active\")\n        limit = method.get(\"limit\")\n        if active is not True:\n            return False, \"payment_method_inactive\", None, 0.0\n        if not isinstance(limit, (int, float)) or limit < 0:\n            return False, \"invalid_payment_limit\", None, 0.0\n\n        amount = float(o[\"total\"])\n        if amount > float(limit) + 1e-9:\n            return False, \"insufficient_funds\", None, 0.0\n\n        new_methods = deepcopy(methods)\n        new_methods[method_key][\"limit\"] = float(limit) - amount\n        return True, None, new_methods, amount\n\n    def prepare_shipping(o: dict) -> tuple[str, dict]:\n        # In a real system this would call an external shipping service.\n        # Here we only simulate a deterministic label id.\n        label_id = f\"SHIP-{o['id']}\"\n        return label_id, {\"carrier\": \"FAKE_EXPRESS\", \"priority\": \"standard\"}\n\n    # 1. Validate order\n    ok, reason = validate_order(order_in)\n    if not ok:\n        return {\n            \"order_id\": order_in.get(\"id\"),\n            \"status\": \"failed\",\n            \"reason\": reason,\n            \"step\": \"validation\",\n        }\n\n    # 2. Check inventory\n    inv_ok, inv_reason, remaining_inv = check_inventory(order_in, inventory_in)\n    if not inv_ok:\n        return {\n            \"order_id\": order_in[\"id\"],\n            \"status\": \"failed\",\n            \"reason\": inv_reason,\n            \"step\": \"inventory\",\n        }\n\n    # 3. Process payment\n    pay_ok, pay_reason, new_payment_state, charged_amount = process_payment(\n        order_in, payment_methods_in\n    )\n    if not pay_ok:\n        return {\n            \"order_id\": order_in[\"id\"],\n            \"status\": \"failed\",\n            \"reason\": pay_reason,\n            \"step\": \"payment\",\n        }\n\n    # 4. Prepare shipping\n    shipping_label, shipping_meta = prepare_shipping(order_in)\n\n    return {\n        \"order_id\": order_in[\"id\"],\n        \"status\": \"ready_to_ship\",\n        \"charged_amount\": charged_amount,\n        \"shipping_label_id\": shipping_label,\n        \"shipping\": shipping_meta,\n        \"remaining_inventory\": remaining_inv,\n        \"payment_state\": new_payment_state,\n    }\n",
  "buggy_implementations": [
    {
      "bug_description": "워크플로우 통합 버그: 주문 합계 검증 시 소수점 반올림을 잘못 사용하여 총액이 약간 다른(valid) 케이스가 실패하거나, 반대로 유효하지 않은 합계가 통과할 수 있음. workflow testing 및 multi-function coordination에서 validation 단계에 대한 정밀 검증 필요.",
      "buggy_code": "from copy import deepcopy\n\n\ndef process_order_workflow(order: dict, inventory: dict, payment_methods: dict) -> dict:\n    \"\"\"Buggy: uses naive rounding when validating total, causing subtle workflow failures.\"\"\"\n\n    order_in = deepcopy(order)\n    inventory_in = deepcopy(inventory)\n    payment_methods_in = deepcopy(payment_methods)\n\n    def validate_order(o: dict) -> tuple[bool, str | None]:\n        required_keys = {\"id\", \"items\", \"total\", \"payment_method\", \"shipping_address\"}\n        missing = required_keys - set(o.keys())\n        if missing:\n            return False, f\"missing_fields: {sorted(missing)}\"\n\n        if not isinstance(o[\"items\"], list) or len(o[\"items\"]) == 0:\n            return False, \"no_items\"\n\n        expected_total = 0.0\n        for item in o[\"items\"]:\n            if not isinstance(item, dict):\n                return False, \"invalid_item_type\"\n            sku = item.get(\"sku\")\n            qty = item.get(\"qty\")\n            price = item.get(\"unit_price\")\n            if not isinstance(sku, str) or not sku:\n                return False, \"invalid_sku\"\n            if not isinstance(qty, int) or qty <= 0:\n                return False, \"invalid_qty\"\n            if not isinstance(price, (int, float)) or price < 0:\n                return False, \"invalid_price\"\n            expected_total += qty * float(price)\n\n        provided_total = o[\"total\"]\n        if not isinstance(provided_total, (int, float)):\n            return False, \"invalid_total_type\"\n        # BUG: uses round to 2 decimals and direct equality, making some valid totals fail\n        if round(expected_total, 2) != round(float(provided_total), 2):\n            return False, \"total_mismatch\"\n\n        if not isinstance(o[\"payment_method\"], str) or not o[\"payment_method\"]:\n            return False, \"invalid_payment_method\"\n        if not isinstance(o[\"shipping_address\"], str) or not o[\"shipping_address\"].strip():\n            return False, \"invalid_shipping_address\"\n        return True, None\n\n    def check_inventory(o: dict, inv: dict) -> tuple[bool, str | None, dict | None]:\n        remaining = deepcopy(inv)\n        for item in o[\"items\"]:\n            sku = item[\"sku\"]\n            qty = item[\"qty\"]\n            if sku not in remaining:\n                return False, f\"sku_not_found:{sku}\", None\n            if remaining[sku] < qty:\n                return False, f\"insufficient_inventory_for:{sku}\", None\n            remaining[sku] -= qty\n        return True, None, remaining\n\n    def process_payment(o: dict, methods: dict) -> tuple[bool, str | None, dict | None, float]:\n        method_key = o[\"payment_method\"]\n        if method_key not in methods:\n            return False, \"payment_method_not_found\", None, 0.0\n        method = methods[method_key]\n        if not method.get(\"active\"):\n            return False, \"payment_method_inactive\", None, 0.0\n        limit = method.get(\"limit\", 0)\n        amount = float(o[\"total\"])\n        if amount > float(limit):\n            return False, \"insufficient_funds\", None, 0.0\n        new_methods = deepcopy(methods)\n        new_methods[method_key][\"limit\"] = float(limit) - amount\n        return True, None, new_methods, amount\n\n    def prepare_shipping(o: dict) -> tuple[str, dict]:\n        return f\"SHIP-{o['id']}\", {\"carrier\": \"FAKE_EXPRESS\", \"priority\": \"standard\"}\n\n    ok, reason = validate_order(order_in)\n    if not ok:\n        return {\n            \"order_id\": order_in.get(\"id\"),\n            \"status\": \"failed\",\n            \"reason\": reason,\n            \"step\": \"validation\",\n        }\n\n    inv_ok, inv_reason, remaining_inv = check_inventory(order_in, inventory_in)\n    if not inv_ok:\n        return {\n            \"order_id\": order_in[\"id\"],\n            \"status\": \"failed\",\n            \"reason\": inv_reason,\n            \"step\": \"inventory\",\n        }\n\n    pay_ok, pay_reason, new_payment_state, charged_amount = process_payment(order_in, payment_methods_in)\n    if not pay_ok:\n        return {\n            \"order_id\": order_in[\"id\"],\n            \"status\": \"failed\",\n            \"reason\": pay_reason,\n            \"step\": \"payment\",\n        }\n\n    shipping_label, shipping_meta = prepare_shipping(order_in)\n    return {\n        \"order_id\": order_in[\"id\"],\n        \"status\": \"ready_to_ship\",\n        \"charged_amount\": charged_amount,\n        \"shipping_label_id\": shipping_label,\n        \"shipping\": shipping_meta,\n        \"remaining_inventory\": remaining_inv,\n        \"payment_state\": new_payment_state,\n    }\n",
      "weight": 3
    },
    {
      "bug_description": "통합 단계 누락 버그: 결제 실패 시에도 배송 준비 단계가 실행되어 status가 ready_to_ship으로 표시될 수 있음. workflow testing 및 multi-function coordination을 통해 실패 경로에서 이후 단계가 실행되지 않는지 확인 필요.",
      "buggy_code": "from copy import deepcopy\n\n\ndef process_order_workflow(order: dict, inventory: dict, payment_methods: dict) -> dict:\n    \"\"\"Buggy: prepares shipping even when payment fails, breaking workflow integrity.\"\"\"\n\n    order_in = deepcopy(order)\n    inventory_in = deepcopy(inventory)\n    payment_methods_in = deepcopy(payment_methods)\n\n    def validate_order(o: dict) -> tuple[bool, str | None]:\n        required_keys = {\"id\", \"items\", \"total\", \"payment_method\", \"shipping_address\"}\n        missing = required_keys - set(o.keys())\n        if missing:\n            return False, f\"missing_fields: {sorted(missing)}\"\n        if not isinstance(o[\"items\"], list) or not o[\"items\"]:\n            return False, \"no_items\"\n        total = 0.0\n        for item in o[\"items\"]:\n            total += item[\"qty\"] * float(item[\"unit_price\"])\n        if abs(total - float(o[\"total\"])) > 0.01:\n            return False, \"total_mismatch\"\n        return True, None\n\n    def check_inventory(o: dict, inv: dict) -> tuple[bool, str | None, dict | None]:\n        remaining = deepcopy(inv)\n        for item in o[\"items\"]:\n            sku = item[\"sku\"]\n            qty = item[\"qty\"]\n            if sku not in remaining:\n                return False, f\"sku_not_found:{sku}\", None\n            if remaining[sku] < qty:\n                return False, f\"insufficient_inventory_for:{sku}\", None\n            remaining[sku] -= qty\n        return True, None, remaining\n\n    def process_payment(o: dict, methods: dict) -> tuple[bool, str | None, dict | None, float]:\n        method_key = o[\"payment_method\"]\n        if method_key not in methods:\n            return False, \"payment_method_not_found\", None, 0.0\n        method = methods[method_key]\n        if not isinstance(method, dict):\n            return False, \"invalid_payment_method_config\", None, 0.0\n        if not method.get(\"active\"):\n            return False, \"payment_method_inactive\", None, 0.0\n        limit = method.get(\"limit\", 0)\n        amount = float(o[\"total\"])\n        if amount > float(limit):\n            return False, \"insufficient_funds\", None, 0.0\n        new_methods = deepcopy(methods)\n        new_methods[method_key][\"limit\"] = float(limit) - amount\n        return True, None, new_methods, amount\n\n    def prepare_shipping(o: dict) -> tuple[str, dict]:\n        return f\"SHIP-{o['id']}\", {\"carrier\": \"FAKE_EXPRESS\", \"priority\": \"standard\"}\n\n    ok, reason = validate_order(order_in)\n    if not ok:\n        return {\n            \"order_id\": order_in.get(\"id\"),\n            \"status\": \"failed\",\n            \"reason\": reason,\n            \"step\": \"validation\",\n        }\n\n    inv_ok, inv_reason, remaining_inv = check_inventory(order_in, inventory_in)\n    if not inv_ok:\n        return {\n            \"order_id\": order_in[\"id\"],\n            \"status\": \"failed\",\n            \"reason\": inv_reason,\n            \"step\": \"inventory\",\n        }\n\n    pay_ok, pay_reason, new_payment_state, charged_amount = process_payment(order_in, payment_methods_in)\n\n    # BUG: even if payment fails, proceed to shipping and mark as ready_to_ship\n    shipping_label, shipping_meta = prepare_shipping(order_in)\n\n    if not pay_ok:\n        # Incorrectly returning ready_to_ship but with 0 charged_amount is possible\n        return {\n            \"order_id\": order_in[\"id\"],\n            \"status\": \"ready_to_ship\",  # BUG: should be failed\n            \"charged_amount\": charged_amount,\n            \"shipping_label_id\": shipping_label,\n            \"shipping\": shipping_meta,\n            \"remaining_inventory\": remaining_inv,\n            \"payment_state\": new_payment_state if new_payment_state is not None else payment_methods_in,\n        }\n\n    return {\n        \"order_id\": order_in[\"id\"],\n        \"status\": \"ready_to_ship\",\n        \"charged_amount\": charged_amount,\n        \"shipping_label_id\": shipping_label,\n        \"shipping\": shipping_meta,\n        \"remaining_inventory\": remaining_inv,\n        \"payment_state\": new_payment_state,\n    }\n",
      "weight": 5
    },
    {
      "bug_description": "상태 관리/통합 버그: 결제 처리에서 payment_methods 딕셔너리를 깊은 복사하지 않고 직접 수정하여, 한 주문의 호출이 다음 주문 호출에 영향을 주는 공유 상태(side effect)를 만듦. integration testing과 multi-function coordination 관점에서 여러 번 호출 시 상태 변경을 검증해야 함.",
      "buggy_code": "from copy import deepcopy\n\n\ndef process_order_workflow(order: dict, inventory: dict, payment_methods: dict) -> dict:\n    \"\"\"Buggy: mutates the input payment_methods, causing cross-call interference.\"\"\"\n\n    order_in = deepcopy(order)\n    inventory_in = deepcopy(inventory)\n    # BUG: do not deepcopy payment_methods, use original reference\n    payment_methods_in = payment_methods\n\n    def validate_order(o: dict) -> tuple[bool, str | None]:\n        required_keys = {\"id\", \"items\", \"total\", \"payment_method\", \"shipping_address\"}\n        missing = required_keys - set(o.keys())\n        if missing:\n            return False, f\"missing_fields: {sorted(missing)}\"\n        if not isinstance(o[\"items\"], list) or not o[\"items\"]:\n            return False, \"no_items\"\n        expected = 0.0\n        for item in o[\"items\"]:\n            expected += item[\"qty\"] * float(item[\"unit_price\"])\n        if abs(expected - float(o[\"total\"])) > 0.01:\n            return False, \"total_mismatch\"\n        return True, None\n\n    def check_inventory(o: dict, inv: dict) -> tuple[bool, str | None, dict | None]:\n        remaining = deepcopy(inv)\n        for item in o[\"items\"]:\n            sku = item[\"sku\"]\n            qty = item[\"qty\"]\n            if sku not in remaining:\n                return False, f\"sku_not_found:{sku}\", None\n            if remaining[sku] < qty:\n                return False, f\"insufficient_inventory_for:{sku}\", None\n            remaining[sku] -= qty\n        return True, None, remaining\n\n    def process_payment(o: dict, methods: dict) -> tuple[bool, str | None, dict | None, float]:\n        method_key = o[\"payment_method\"]\n        if method_key not in methods:\n            return False, \"payment_method_not_found\", None, 0.0\n        method = methods[method_key]\n        if not method.get(\"active\"):\n            return False, \"payment_method_inactive\", None, 0.0\n        limit = method.get(\"limit\", 0)\n        amount = float(o[\"total\"])\n        if amount > float(limit):\n            return False, \"insufficient_funds\", None, 0.0\n        # BUG: mutate methods in-place instead of copying\n        methods[method_key][\"limit\"] = float(limit) - amount\n        return True, None, methods, amount\n\n    def prepare_shipping(o: dict) -> tuple[str, dict]:\n        return f\"SHIP-{o['id']}\", {\"carrier\": \"FAKE_EXPRESS\", \"priority\": \"standard\"}\n\n    ok, reason = validate_order(order_in)\n    if not ok:\n        return {\n            \"order_id\": order_in.get(\"id\"),\n            \"status\": \"failed\",\n            \"reason\": reason,\n            \"step\": \"validation\",\n        }\n\n    inv_ok, inv_reason, remaining_inv = check_inventory(order_in, inventory_in)\n    if not inv_ok:\n        return {\n            \"order_id\": order_in[\"id\"],\n            \"status\": \"failed\",\n            \"reason\": inv_reason,\n            \"step\": \"inventory\",\n        }\n\n    pay_ok, pay_reason, new_payment_state, charged_amount = process_payment(order_in, payment_methods_in)\n    if not pay_ok:\n        return {\n            \"order_id\": order_in[\"id\"],\n            \"status\": \"failed\",\n            \"reason\": pay_reason,\n            \"step\": \"payment\",\n        }\n\n    shipping_label, shipping_meta = prepare_shipping(order_in)\n    return {\n        \"order_id\": order_in[\"id\"],\n        \"status\": \"ready_to_ship\",\n        \"charged_amount\": charged_amount,\n        \"shipping_label_id\": shipping_label,\n        \"shipping\": shipping_meta,\n        \"remaining_inventory\": remaining_inv,\n        \"payment_state\": new_payment_state,\n    }\n",
      "weight": 4
    },
    {
      "bug_description": "단계 간 데이터 전달 오류: 재고 체크 단계에서 남은 재고를 계산하지만, 성공 경로에서 remaining_inventory 대신 원래 inventory를 반환하여, 워크플로우 전체의 상태가 일관되지 않음. workflow/integration testing으로 재고 감소가 제대로 반영되는지 확인해야 함.",
      "buggy_code": "from copy import deepcopy\n\n\ndef process_order_workflow(order: dict, inventory: dict, payment_methods: dict) -> dict:\n    \"\"\"Buggy: ignores updated inventory and returns the original one in the final result.\"\"\"\n\n    order_in = deepcopy(order)\n    inventory_in = deepcopy(inventory)\n    payment_methods_in = deepcopy(payment_methods)\n\n    def validate_order(o: dict) -> tuple[bool, str | None]:\n        required_keys = {\"id\", \"items\", \"total\", \"payment_method\", \"shipping_address\"}\n        missing = required_keys - set(o.keys())\n        if missing:\n            return False, f\"missing_fields: {sorted(missing)}\"\n        if not isinstance(o[\"items\"], list) or not o[\"items\"]:\n            return False, \"no_items\"\n        total = 0.0\n        for item in o[\"items\"]:\n            total += item[\"qty\"] * float(item[\"unit_price\"])\n        if abs(total - float(o[\"total\"])) > 0.01:\n            return False, \"total_mismatch\"\n        return True, None\n\n    def check_inventory(o: dict, inv: dict) -> tuple[bool, str | None, dict | None]:\n        remaining = deepcopy(inv)\n        for item in o[\"items\"]:\n            sku = item[\"sku\"]\n            qty = item[\"qty\"]\n            if sku not in remaining:\n                return False, f\"sku_not_found:{sku}\", None\n            if remaining[sku] < qty:\n                return False, f\"insufficient_inventory_for:{sku}\", None\n            remaining[sku] -= qty\n        return True, None, remaining\n\n    def process_payment(o: dict, methods: dict) -> tuple[bool, str | None, dict | None, float]:\n        method_key = o[\"payment_method\"]\n        if method_key not in methods:\n            return False, \"payment_method_not_found\", None, 0.0\n        method = methods[method_key]\n        if not isinstance(method, dict):\n            return False, \"invalid_payment_method_config\", None, 0.0\n        if not method.get(\"active\"):\n            return False, \"payment_method_inactive\", None, 0.0\n        limit = method.get(\"limit\", 0)\n        amount = float(o[\"total\"])\n        if amount > float(limit):\n            return False, \"insufficient_funds\", None, 0.0\n        new_methods = deepcopy(methods)\n        new_methods[method_key][\"limit\"] = float(limit) - amount\n        return True, None, new_methods, amount\n\n    def prepare_shipping(o: dict) -> tuple[str, dict]:\n        return f\"SHIP-{o['id']}\", {\"carrier\": \"FAKE_EXPRESS\", \"priority\": \"standard\"}\n\n    ok, reason = validate_order(order_in)\n    if not ok:\n        return {\n            \"order_id\": order_in.get(\"id\"),\n            \"status\": \"failed\",\n            \"reason\": reason,\n            \"step\": \"validation\",\n        }\n\n    inv_ok, inv_reason, remaining_inv = check_inventory(order_in, inventory_in)\n    if not inv_ok:\n        return {\n            \"order_id\": order_in[\"id\"],\n            \"status\": \"failed\",\n            \"reason\": inv_reason,\n            \"step\": \"inventory\",\n        }\n\n    pay_ok, pay_reason, new_payment_state, charged_amount = process_payment(order_in, payment_methods_in)\n    if not pay_ok:\n        return {\n            \"order_id\": order_in[\"id\"],\n            \"status\": \"failed\",\n            \"reason\": pay_reason,\n            \"step\": \"payment\",\n        }\n\n    shipping_label, shipping_meta = prepare_shipping(order_in)\n\n    # BUG: returns original inventory_in instead of remaining_inv\n    return {\n        \"order_id\": order_in[\"id\"],\n        \"status\": \"ready_to_ship\",\n        \"charged_amount\": charged_amount,\n        \"shipping_label_id\": shipping_label,\n        \"shipping\": shipping_meta,\n        \"remaining_inventory\": inventory_in,  # BUG\n        \"payment_state\": new_payment_state,\n    }\n",
      "weight": 3
    }
  ],
  "description_md": "## 문제 설명\n\n한 전자상거래 서비스에서 주문이 접수되면 다음과 같은 워크플로우를 거칩니다.\n\n1. **주문 검증 (validate_order)**  \n   - 주문 구조 및 필수 필드 검증  \n   - 주문 항목 합계와 total 금액 일치 여부 확인\n2. **재고 확인 (check_inventory)**  \n   - 각 상품 SKU에 대해 재고가 충분한지 확인  \n   - 재고가 충분하면 남은 재고를 계산\n3. **결제 처리 (process_payment)**  \n   - 결제 수단이 유효하고 활성(active) 상태인지 확인  \n   - 한 결제 수단에 대해 사용 가능한 한도(limit)를 넘지 않는지 검증  \n   - 결제 성공 시 남은 한도를 갱신\n4. **배송 준비 (prepare_shipping)**  \n   - 배송 라벨 ID를 생성하고, 주문 상태를 `ready_to_ship`으로 설정\n\n이 모든 단계를 하나의 함수 `process_order_workflow`가 통합하여 처리합니다.\n테스트 대상은 **이 단일 통합 함수**이며, 내부적으로는 위 4단계가 순서대로 실행된다고 가정할 수 있습니다.\n\n### 함수 설명\n\n```python\nprocess_order_workflow(order: dict, inventory: dict, payment_methods: dict) -> dict\n```\n\n- `order`\n  - 필수 키: `\"id\"`, `\"items\"`, `\"total\"`, `\"payment_method\"`, `\"shipping_address\"`\n  - `items`: `[{\"sku\": str, \"qty\": int, \"unit_price\": number}, ...]`\n  - `total`: 모든 `qty * unit_price`의 합과 일치해야 합니다 (부동소수점 오차는 소량 허용)\n- `inventory`\n  - `{sku: available_quantity}` 형태의 딕셔너리, 수량은 0 이상의 정수\n- `payment_methods`\n  - `{method_name: {\"active\": bool, \"limit\": number}}` 형태의 딕셔너리\n\n#### 성공 시 반환 예시\n\n```python\norder = {\n    \"id\": \"ORD-1\",\n    \"items\": [\n        {\"sku\": \"A\", \"qty\": 2, \"unit_price\": 10.0},\n        {\"sku\": \"B\", \"qty\": 1, \"unit_price\": 5.0},\n    ],\n    \"total\": 25.0,\n    \"payment_method\": \"card\",\n    \"shipping_address\": \"Seoul\"\n}\n\ninventory = {\"A\": 10, \"B\": 5}\npayment_methods = {\"card\": {\"active\": True, \"limit\": 100.0}}\n\nresult = process_order_workflow(order, inventory, payment_methods)\n# result 예시 구조\n# {\n#   \"order_id\": \"ORD-1\",\n#   \"status\": \"ready_to_ship\",\n#   \"charged_amount\": 25.0,\n#   \"shipping_label_id\": \"SHIP-ORD-1\",\n#   \"remaining_inventory\": {\"A\": 8, \"B\": 4},\n#   \"payment_state\": {\"card\": {\"active\": True, \"limit\": 75.0}}\n# }\n```\n\n#### 실패 시 반환 예시\n\n- 재고 부족 등으로 실패하는 경우:\n\n```python\n{\n  \"order_id\": \"ORD-1\",\n  \"status\": \"failed\",\n  \"reason\": \"insufficient_inventory_for:A\",  # 예시\n  \"step\": \"inventory\"  # \"validation\" / \"inventory\" / \"payment\" 중 하나\n}\n```\n\n### 테스트 시 고려해야 할 사항 (힌트)\n\n이 문제는 개별 함수가 아니라 **전체 워크플로우를 하나의 단위로 테스트**하는 것이 핵심입니다.\n\n- **Workflow testing**  \n  - 유효한 주문이 들어왔을 때, 검증 → 재고 확인 → 결제 → 배송 준비까지 **모든 단계가 순서대로** 잘 실행되고, 각 단계의 산출물이 최종 결과에 반영되는지 확인하세요.\n  - 특정 단계(예: 검증, 재고, 결제)에서 실패하는 경우, **그 이후 단계가 실행되지 않고**, 적절한 `status`, `step`, `reason`이 반환되는지 확인해 보세요.\n\n- **Integration testing**  \n  - 재고 감소(`remaining_inventory`)와 결제 한도 감소(`payment_state`)가 **서로 일관된 상태로** 반환되는지, 그리고 **입력으로 전달한 dict들이 변경되지 않는지(불변성)**를 확인해 보세요.\n  - 동일한 `payment_methods`를 사용해 여러 번 `process_order_workflow`를 호출할 때, 한 번의 호출이 다른 호출에 영향을 주지 않아야 합니다 (공유 상태/side-effect 여부).\n\n- **Multi-function coordination**  \n  - `total`이 경계값(아주 작은 소수 차이 등)일 때도 합계 검증이 올바르게 작동하는지 확인해 보세요.\n  - 재고는 충분하지만 결제 한도가 부족한 경우, 재고는 감소하지 않아야 합니다.\n  - 재고는 부족하지만 결제 한도는 충분한 경우, 결제는 시도되지 않아야 합니다.\n\n### 수험자가 해야 할 일\n\n- 제공된 `process_order_workflow`에 대해 **pytest 기반 테스트 코드**를 작성하세요.\n- 여러 개의 버그 구현이 존재하므로, 가능한 한 **다양한 시나리오(성공/실패 경로, 여러 번 호출, 데이터 불변성 등)**를 설계하여 버그 구현들을 최대한 많이 탐지해야 합니다.\n- 특히, 단일 단계(unit)만이 아니라 **단계 간 상태 전달과 전체 플로우의 일관성**을 검증하는 테스트를 중심으로 작성해 보세요.\n",
  "initial_test_template": "import pytest\nfrom target import process_order_workflow\n\n\n# 기본 성공 플로우 테스트 (정상 시 전체 워크플로우가 잘 통합되는지)\ndef test_happy_path_workflow():\n    # TODO: 유효한 order/inventory/payment_methods를 구성하고\n    # - status == \"ready_to_ship\"\n    # - remaining_inventory / payment_state가 기대대로 변경되는지\n    # - 입력 dict들이 변하지 않는지(불변성) 등을 검증하세요.\n    pass\n\n\n# 각 단계에서 실패하는 통합 테스트 (validation / inventory / payment 단계별 실패 경로)\ndef test_failure_paths_per_step():\n    # TODO: \n    # - 잘못된 total로 validation 단계에서 실패\n    # - 재고 부족으로 inventory 단계에서 실패\n    # - 결제 한도 부족으로 payment 단계에서 실패\n    # 각각에 대해 status, step, reason이 올바른지 검증하세요.\n    pass\n\n\n# 여러 번 호출 시 상태 공유/side-effect 여부 테스트\ndef test_multiple_calls_no_cross_talk():\n    # TODO:\n    # - 같은 payment_methods와 inventory를 사용해 여러 번 호출\n    # - 한 호출의 결과가 다음 호출에 영향을 주지 않는지 확인 (특히 결제 한도, 재고 등)\n    # - workflow/integration 관점에서 상태가 독립적인지 검증하세요.\n    pass\n\n\n# 복합 워크플로우/경계 테스트: 소수 total, 여러 SKU, 부분 실패 조합 등\ndef test_complex_workflow_scenarios():\n    # TODO:\n    # - total이 소수점 경계에 있는 케이스\n    # - 일부 SKU만 재고 부족, 일부는 충분한 케이스\n    # - 결제 수단이 비활성/존재하지 않는 경우 등\n    # 통합적으로 결과가 일관적인지 검증하세요.\n    pass\n",
  "tags": [
    "hard",
    "workflow testing",
    "integration testing",
    "multi-function coordination",
    "e-commerce",
    "dict",
    "state-management",
    "pytest"
  ],
  "difficulty": "Hard"
}