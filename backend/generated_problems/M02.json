{
  "title": "할인 계산기 조합 테스트",
  "function_signature": "def calculate_final_price(base_price: float, discount_rate: float, has_coupon: bool, coupon_amount: float | None = None) -> float:",
  "golden_code": "from typing import Optional\n\n\ndef calculate_final_price(base_price: float, discount_rate: float, has_coupon: bool, coupon_amount: Optional[float] = None) -> float:\n    \"\"\"Calculate the final price after applying percentage discount and optional coupon.\n\n    Business rules\n    -------------\n    - `base_price` is the original item price and must be >= 0.\n    - `discount_rate` is a percentage expressed as 0.0 ~ 1.0 (e.g. 0.2 == 20% off).\n    - If `has_coupon` is True, then `coupon_amount` must be provided and >= 0.\n    - Apply percentage discount first, then subtract coupon.\n    - The final price is never negative; clamp to 0.0.\n\n    Parameters\n    ----------\n    base_price: float\n        Original price of the item.\n    discount_rate: float\n        Percentage discount in [0.0, 1.0].\n    has_coupon: bool\n        Whether a fixed-amount coupon is applied.\n    coupon_amount: Optional[float]\n        Fixed amount discount if `has_coupon` is True; ignored otherwise.\n\n    Returns\n    -------\n    float\n        Final price after discounts, rounded to 2 decimal places.\n\n    Raises\n    ------\n    ValueError\n        - If base_price is negative.\n        - If discount_rate is not in [0.0, 1.0].\n        - If has_coupon is True but coupon_amount is None or negative.\n    \"\"\"\n    # Validate inputs\n    if base_price < 0:\n        raise ValueError(\"base_price must be non-negative\")\n    if not (0.0 <= discount_rate <= 1.0):\n        raise ValueError(\"discount_rate must be between 0.0 and 1.0\")\n\n    if has_coupon:\n        if coupon_amount is None:\n            raise ValueError(\"coupon_amount must be provided when has_coupon is True\")\n        if coupon_amount < 0:\n            raise ValueError(\"coupon_amount must be non-negative\")\n    else:\n        # Ignore coupon_amount if coupon is not used\n        coupon_amount = 0.0\n\n    # Apply percentage discount first\n    price_after_percentage = base_price * (1.0 - discount_rate)\n\n    # Apply coupon (fixed amount)\n    final_price = price_after_percentage - (coupon_amount or 0.0)\n\n    # Clamp to zero (no negative prices)\n    if final_price < 0.0:\n        final_price = 0.0\n\n    # Round to 2 decimal places to simulate typical currency handling\n    return round(final_price, 2)\n",
  "buggy_implementations": [
    {
      "bug_description": "쿠폰이 없는 경우(coupon=False)에도 coupon_amount를 그대로 사용하여, has_coupon과 coupon_amount 조합에 따라 잘못된 결과가 나옴. 예: has_coupon=False, coupon_amount>0 인 조합.",
      "buggy_code": "from typing import Optional\n\n\ndef calculate_final_price(base_price: float, discount_rate: float, has_coupon: bool, coupon_amount: Optional[float] = None) -> float:\n    \"\"\"Buggy: incorrectly uses coupon_amount even when has_coupon is False.\"\"\"\n    if base_price < 0:\n        raise ValueError(\"base_price must be non-negative\")\n    if not (0.0 <= discount_rate <= 1.0):\n        raise ValueError(\"discount_rate must be between 0.0 and 1.0\")\n\n    # Only partial validation of coupon\n    if has_coupon:\n        if coupon_amount is None:\n            raise ValueError(\"coupon_amount must be provided when has_coupon is True\")\n        if coupon_amount < 0:\n            raise ValueError(\"coupon_amount must be non-negative\")\n\n    # Apply discount\n    price_after_percentage = base_price * (1.0 - discount_rate)\n\n    # BUG: subtract coupon_amount even when has_coupon is False\n    # Also treats None as 0 via `or 0.0`, which can hide missing coupon\n    final_price = price_after_percentage - (coupon_amount or 0.0)\n\n    if final_price < 0.0:\n        final_price = 0.0\n\n    return round(final_price, 2)\n",
      "weight": 4
    },
    {
      "bug_description": "할인율 범위 검증에서 상한을 1.0 초과로 허용하여 100% 초과 할인율(예: 1.2)이 통과하고, 음수 가격 보정으로 0원 처리됨. 특정 조합에서 논리적으로 있어서는 안 되는 결과가 나옴.",
      "buggy_code": "from typing import Optional\n\n\ndef calculate_final_price(base_price: float, discount_rate: float, has_coupon: bool, coupon_amount: Optional[float] = None) -> float:\n    \"\"\"Buggy: accepts discount_rate > 1.0 (more than 100% discount).\"\"\"\n    if base_price < 0:\n        raise ValueError(\"base_price must be non-negative\")\n\n    # BUG: upper bound allows discount_rate up to 2.0 instead of 1.0\n    if not (0.0 <= discount_rate <= 2.0):\n        raise ValueError(\"discount_rate must be between 0.0 and 1.0\")\n\n    if has_coupon:\n        if coupon_amount is None:\n            raise ValueError(\"coupon_amount must be provided when has_coupon is True\")\n        if coupon_amount < 0:\n            raise ValueError(\"coupon_amount must be non-negative\")\n    else:\n        coupon_amount = 0.0\n\n    price_after_percentage = base_price * (1.0 - discount_rate)\n\n    final_price = price_after_percentage - (coupon_amount or 0.0)\n\n    # Clamp negative values to 0, which hides the >100% discount issue\n    if final_price < 0.0:\n        final_price = 0.0\n\n    return round(final_price, 2)\n",
      "weight": 3
    },
    {
      "bug_description": "쿠폰을 먼저 적용한 뒤 퍼센트 할인을 적용하는 순서 오류. 할인율과 쿠폰 조합에 따라 골든 구현과 다른 결과가 나옴.",
      "buggy_code": "from typing import Optional\n\n\ndef calculate_final_price(base_price: float, discount_rate: float, has_coupon: bool, coupon_amount: Optional[float] = None) -> float:\n    \"\"\"Buggy: applies coupon before percentage discount (wrong order).\"\"\"\n    if base_price < 0:\n        raise ValueError(\"base_price must be non-negative\")\n    if not (0.0 <= discount_rate <= 1.0):\n        raise ValueError(\"discount_rate must be between 0.0 and 1.0\")\n\n    if has_coupon:\n        if coupon_amount is None:\n            raise ValueError(\"coupon_amount must be provided when has_coupon is True\")\n        if coupon_amount < 0:\n            raise ValueError(\"coupon_amount must be non-negative\")\n    else:\n        coupon_amount = 0.0\n\n    # BUG: apply coupon first\n    intermediate_price = base_price - (coupon_amount or 0.0)\n    if intermediate_price < 0.0:\n        intermediate_price = 0.0\n\n    # Then apply percentage discount\n    final_price = intermediate_price * (1.0 - discount_rate)\n\n    if final_price < 0.0:\n        final_price = 0.0\n\n    return round(final_price, 2)\n",
      "weight": 5
    },
    {
      "bug_description": "금액 계산 후 반올림을 하지 않고 그대로 반환. 조합에 따라 부동소수점 오차가 드러나며, currency(소수 둘째 자리) 기준 사양 위반.",
      "buggy_code": "from typing import Optional\n\n\ndef calculate_final_price(base_price: float, discount_rate: float, has_coupon: bool, coupon_amount: Optional[float] = None) -> float:\n    \"\"\"Buggy: does not round to 2 decimal places.\"\"\"\n    if base_price < 0:\n        raise ValueError(\"base_price must be non-negative\")\n    if not (0.0 <= discount_rate <= 1.0):\n        raise ValueError(\"discount_rate must be between 0.0 and 1.0\")\n\n    if has_coupon:\n        if coupon_amount is None:\n            raise ValueError(\"coupon_amount must be provided when has_coupon is True\")\n        if coupon_amount < 0:\n            raise ValueError(\"coupon_amount must be non-negative\")\n    else:\n        coupon_amount = 0.0\n\n    price_after_percentage = base_price * (1.0 - discount_rate)\n    final_price = price_after_percentage - (coupon_amount or 0.0)\n    if final_price < 0.0:\n        final_price = 0.0\n\n    # BUG: missing rounding, returns raw float\n    return final_price\n",
      "weight": 2
    }
  ],
  "description_md": "## 문제 설명\n\n온라인 쇼핑몰에서 상품 가격에 여러 종류의 할인이 동시에 적용될 수 있습니다. 예를 들어, 시즌 세일로 퍼센트 할인(예: 20%)이 적용된 상태에서, 추가로 정액 쿠폰(예: 5,000원)을 사용할 수도 있습니다.\n\n이 문제에서는 이러한 시나리오를 단일 함수로 캡슐화한 `calculate_final_price` 함수를 테스트해야 합니다. 다양한 가격, 할인율, 쿠폰 사용 여부 조합을 설계하여, 버그가 있는 구현들을 효과적으로 검출하는 것이 목표입니다.\n\n### 함수 설명\n\n```python\ncalculate_final_price(base_price: float, discount_rate: float, has_coupon: bool, coupon_amount: float | None = None) -> float\n```\n\n- `base_price`: 상품의 원래 가격 (0 이상)\n- `discount_rate`: 퍼센트 할인율 (0.0 ~ 1.0 범위, 예: 0.2 == 20% 할인)\n- `has_coupon`: 정액 쿠폰을 사용하는지 여부\n- `coupon_amount`: 쿠폰 금액 (`has_coupon`이 True일 때만 의미 있음, 0 이상)\n\n비즈니스 규칙(골든 구현 기준):\n1. 입력 값에 대한 기본 검증을 수행합니다.\n   - 가격은 음수가 될 수 없습니다.\n   - 할인율은 0.0 이상 1.0 이하 범위여야 합니다.\n   - 쿠폰을 사용한다고 표시한 경우, 쿠폰 금액은 반드시 제공되고 0 이상이어야 합니다.\n2. **퍼센트 할인**을 먼저 적용한 후, **정액 쿠폰**을 차감합니다.\n3. 최종 가격은 0원 미만이 될 수 없으므로, 0으로 클램핑합니다.\n4. 결과는 통화 처리 관례에 따라 **소수 둘째 자리까지 반올림**하여 반환합니다.\n\n### 동작 예시\n\n- 예시 1\n  - 입력: `base_price=100.0`, `discount_rate=0.2`, `has_coupon=False`, `coupon_amount=None`\n  - 과정: 100 * (1 - 0.2) = 80.0\n  - 결과: `80.0`\n\n- 예시 2\n  - 입력: `base_price=200.0`, `discount_rate=0.25`, `has_coupon=True`, `coupon_amount=30.0`\n  - 과정: 200 * (1 - 0.25) = 150.0 → 150.0 - 30.0 = 120.0\n  - 결과: `120.0`\n\n### 테스트에서 고려해야 할 포인트 (힌트)\n\n이 문제는 특히 다음과 같은 **조합 테스트(combinatorial testing)** 능력을 평가하기 위해 설계되었습니다.\n\n- 여러 파라미터(`base_price`, `discount_rate`, `has_coupon`, `coupon_amount`)의 **조합**에 따라 동작이 달라집니다.\n  - 예: 쿠폰을 사용하지만 금액이 0일 때, 사용하지 않는데 쿠폰 금액이 들어왔을 때 등.\n- 할인율 경계값(0%, 100%)과 그 주변 값 조합을 어떻게 테스트할지 고민해 보세요.\n- 쿠폰 적용 순서(퍼센트 할인 후 쿠폰 vs 쿠폰 후 퍼센트)가 결과에 어떤 영향을 주는지, 다양한 금액/비율 조합으로 비교해 보세요.\n- 통화 금액 특성상 **반올림 처리**가 중요한데, 부동소수점 연산으로 인해 특정 조합에서 차이가 발생할 수 있습니다.\n\n### 수험자 과제\n\n1. 제공된 `calculate_final_price` 함수에 대해, `pytest` 기반의 단위 테스트를 작성하세요.\n2. 다양한 입력 조합을 설계하여, 숨겨진 버그 구현들을 최대한 많이 검출하는 것이 목표입니다.\n   - 파라미터 조합 설계(예: pairwise 이상)를 통해 최소한의 테스트로 최대한 다양한 경우를 커버해 보세요.\n3. 정상 동작 케이스뿐만 아니라, 경계값 및 조합에 따라 미묘하게 달라질 수 있는 케이스도 포함해야 합니다.\n\n테스트 코드는 골든 구현(정상 동작 코드)을 기준으로 기대 결과를 정의해야 하며, 버그 구현들에서는 하나 이상 테스트가 실패하도록 설계하는 것이 이상적입니다.\n",
  "initial_test_template": "import pytest\n\nfrom target import calculate_final_price\n\n\n# 기본적인 조합 테스트: 쿠폰 사용 여부(has_coupon)와 할인율(discount_rate) 조합 설계\n# TODO: 여러 discount_rate 값(0.0, 중간 값, 1.0)을 has_coupon True/False와 조합해 테스트하세요.\ndef test_basic_combinations():\n    pass\n\n\n# 경계값 & 조합 테스트: 가격, 할인율, 쿠폰 금액의 경계-조합\n# TODO: base_price가 0일 때, 할인율이 0 또는 1일 때, 큰 쿠폰 금액 등 조합을 설계하세요.\ndef test_boundary_combinations():\n    pass\n\n\n# 순서/로직 관련 조합 테스트: 퍼센트 할인과 쿠폰 순서에 민감한 사례\n# TODO: 같은 입력에 대해 \"퍼센트 먼저\"와 \"쿠폰 먼저\" 결과가 확연히 달라지는 조합을 찾아 기대값을 명시하세요.\ndef test_discount_and_coupon_order_sensitive_cases():\n    pass\n\n\n# 부동소수 & 반올림 관련 조합 테스트\n# TODO: 소수점이 있는 가격과 할인율 조합으로, 반올림(소수 둘째 자리)이 중요한 케이스를 추가하세요.\ndef test_rounding_combinations():\n    pass\n",
  "tags": [
    "medium",
    "qa",
    "testing",
    "unit-test",
    "python",
    "combinatorial testing",
    "discount logic",
    "multi-parameter",
    "e-commerce",
    "pricing"
  ],
  "difficulty": "Medium"
}