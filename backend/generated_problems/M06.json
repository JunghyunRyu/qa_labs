{
  "title": "로그 분석 및 알람 판정 함수 테스트",
  "function_signature": "def analyze_logs_and_check_alert(\n    logs: list[str],\n    alert_rules: dict,\n    time_window_seconds: int = 60\n) -> dict:",
  "golden_code": "from datetime import datetime\nfrom typing import Optional\n\n\ndef analyze_logs_and_check_alert(\n    logs: list[str],\n    alert_rules: dict,\n    time_window_seconds: int = 60\n) -> dict:\n    '''\n    로그를 분석하고 알람 규칙에 따라 알람 트리거 여부를 판정한다.\n\n    Parameters:\n    - logs: 로그 문자열 리스트. 형식: \"YYYY-MM-DD HH:MM:SS [LEVEL] message\"\n    - alert_rules: 알람 규칙 딕셔너리\n        - error_count_threshold: 에러 개수 임계값 (선택)\n        - error_rate_threshold: 에러율 임계값 (0.0~1.0, 선택)\n        - consecutive_errors_threshold: 연속 에러 임계값 (선택)\n    - time_window_seconds: 분석할 시간 윈도우 (초)\n\n    Returns:\n    {\n        \"total_logs\": int,\n        \"error_count\": int,\n        \"error_rate\": float,\n        \"max_consecutive_errors\": int,\n        \"alert_triggered\": bool,\n        \"triggered_rules\": list[str]\n    }\n\n    로그 형식: \"2024-01-15 10:30:45 [ERROR] Connection failed\"\n    레벨: INFO, WARNING, ERROR, CRITICAL (CRITICAL도 에러로 취급)\n    '''\n    if not logs:\n        return {\n            \"total_logs\": 0,\n            \"error_count\": 0,\n            \"error_rate\": 0.0,\n            \"max_consecutive_errors\": 0,\n            \"alert_triggered\": False,\n            \"triggered_rules\": []\n        }\n\n    # 로그 파싱 및 시간순 정렬\n    parsed_logs = []\n    for log in logs:\n        try:\n            # 형식: \"YYYY-MM-DD HH:MM:SS [LEVEL] message\"\n            timestamp_str = log[:19]\n            level_start = log.find('[')\n            level_end = log.find(']')\n            if level_start == -1 or level_end == -1:\n                continue\n            level = log[level_start+1:level_end]\n            timestamp = datetime.strptime(timestamp_str, \"%Y-%m-%d %H:%M:%S\")\n            parsed_logs.append({\"timestamp\": timestamp, \"level\": level, \"raw\": log})\n        except (ValueError, IndexError):\n            # 파싱 실패한 로그는 무시\n            continue\n\n    if not parsed_logs:\n        return {\n            \"total_logs\": 0,\n            \"error_count\": 0,\n            \"error_rate\": 0.0,\n            \"max_consecutive_errors\": 0,\n            \"alert_triggered\": False,\n            \"triggered_rules\": []\n        }\n\n    # 시간순 정렬\n    parsed_logs.sort(key=lambda x: x[\"timestamp\"])\n\n    # 시간 윈도우 필터링 (가장 최근 로그 기준)\n    latest_time = parsed_logs[-1][\"timestamp\"]\n    window_start = latest_time.timestamp() - time_window_seconds\n    filtered_logs = [\n        log for log in parsed_logs\n        if log[\"timestamp\"].timestamp() > window_start\n    ]\n\n    # 통계 계산\n    total_logs = len(filtered_logs)\n    error_levels = {\"ERROR\", \"CRITICAL\"}\n    errors = [log for log in filtered_logs if log[\"level\"] in error_levels]\n    error_count = len(errors)\n    error_rate = error_count / total_logs if total_logs > 0 else 0.0\n\n    # 연속 에러 계산\n    max_consecutive = 0\n    current_consecutive = 0\n    for log in filtered_logs:\n        if log[\"level\"] in error_levels:\n            current_consecutive += 1\n            max_consecutive = max(max_consecutive, current_consecutive)\n        else:\n            current_consecutive = 0\n\n    # 알람 규칙 검사\n    triggered_rules = []\n\n    if \"error_count_threshold\" in alert_rules:\n        if error_count >= alert_rules[\"error_count_threshold\"]:\n            triggered_rules.append(\"error_count_threshold\")\n\n    if \"error_rate_threshold\" in alert_rules:\n        if error_rate >= alert_rules[\"error_rate_threshold\"]:\n            triggered_rules.append(\"error_rate_threshold\")\n\n    if \"consecutive_errors_threshold\" in alert_rules:\n        if max_consecutive >= alert_rules[\"consecutive_errors_threshold\"]:\n            triggered_rules.append(\"consecutive_errors_threshold\")\n\n    return {\n        \"total_logs\": total_logs,\n        \"error_count\": error_count,\n        \"error_rate\": round(error_rate, 4),\n        \"max_consecutive_errors\": max_consecutive,\n        \"alert_triggered\": len(triggered_rules) > 0,\n        \"triggered_rules\": triggered_rules\n    }",
  "buggy_implementations": [
    {
      "bug_description": "시간 윈도우 경계 조건에서 '>' 대신 '>='를 사용하여 경계에 있는 로그가 제외된다.",
      "buggy_code": "from datetime import datetime\nfrom typing import Optional\n\n\ndef analyze_logs_and_check_alert(\n    logs: list[str],\n    alert_rules: dict,\n    time_window_seconds: int = 60\n) -> dict:\n    '''\n    로그를 분석하고 알람 규칙에 따라 알람 트리거 여부를 판정한다.\n    '''\n    if not logs:\n        return {\n            \"total_logs\": 0,\n            \"error_count\": 0,\n            \"error_rate\": 0.0,\n            \"max_consecutive_errors\": 0,\n            \"alert_triggered\": False,\n            \"triggered_rules\": []\n        }\n\n    parsed_logs = []\n    for log in logs:\n        try:\n            timestamp_str = log[:19]\n            level_start = log.find('[')\n            level_end = log.find(']')\n            if level_start == -1 or level_end == -1:\n                continue\n            level = log[level_start+1:level_end]\n            timestamp = datetime.strptime(timestamp_str, \"%Y-%m-%d %H:%M:%S\")\n            parsed_logs.append({\"timestamp\": timestamp, \"level\": level, \"raw\": log})\n        except (ValueError, IndexError):\n            continue\n\n    if not parsed_logs:\n        return {\n            \"total_logs\": 0,\n            \"error_count\": 0,\n            \"error_rate\": 0.0,\n            \"max_consecutive_errors\": 0,\n            \"alert_triggered\": False,\n            \"triggered_rules\": []\n        }\n\n    parsed_logs.sort(key=lambda x: x[\"timestamp\"])\n    latest_time = parsed_logs[-1][\"timestamp\"]\n    window_start = latest_time.timestamp() - time_window_seconds\n    # BUG: > 대신 >= 사용하여 경계 로그 제외\n    filtered_logs = [\n        log for log in parsed_logs\n        if log[\"timestamp\"].timestamp() >= window_start\n    ]\n\n    total_logs = len(filtered_logs)\n    error_levels = {\"ERROR\", \"CRITICAL\"}\n    errors = [log for log in filtered_logs if log[\"level\"] in error_levels]\n    error_count = len(errors)\n    error_rate = error_count / total_logs if total_logs > 0 else 0.0\n\n    max_consecutive = 0\n    current_consecutive = 0\n    for log in filtered_logs:\n        if log[\"level\"] in error_levels:\n            current_consecutive += 1\n            max_consecutive = max(max_consecutive, current_consecutive)\n        else:\n            current_consecutive = 0\n\n    triggered_rules = []\n    if \"error_count_threshold\" in alert_rules:\n        if error_count >= alert_rules[\"error_count_threshold\"]:\n            triggered_rules.append(\"error_count_threshold\")\n    if \"error_rate_threshold\" in alert_rules:\n        if error_rate >= alert_rules[\"error_rate_threshold\"]:\n            triggered_rules.append(\"error_rate_threshold\")\n    if \"consecutive_errors_threshold\" in alert_rules:\n        if max_consecutive >= alert_rules[\"consecutive_errors_threshold\"]:\n            triggered_rules.append(\"consecutive_errors_threshold\")\n\n    return {\n        \"total_logs\": total_logs,\n        \"error_count\": error_count,\n        \"error_rate\": round(error_rate, 4),\n        \"max_consecutive_errors\": max_consecutive,\n        \"alert_triggered\": len(triggered_rules) > 0,\n        \"triggered_rules\": triggered_rules\n    }",
      "weight": 4
    },
    {
      "bug_description": "연속 에러 계산 전에 시간순 정렬을 하지 않아 입력 순서에 따라 결과가 달라진다.",
      "buggy_code": "from datetime import datetime\nfrom typing import Optional\n\n\ndef analyze_logs_and_check_alert(\n    logs: list[str],\n    alert_rules: dict,\n    time_window_seconds: int = 60\n) -> dict:\n    '''\n    로그를 분석하고 알람 규칙에 따라 알람 트리거 여부를 판정한다.\n    '''\n    if not logs:\n        return {\n            \"total_logs\": 0,\n            \"error_count\": 0,\n            \"error_rate\": 0.0,\n            \"max_consecutive_errors\": 0,\n            \"alert_triggered\": False,\n            \"triggered_rules\": []\n        }\n\n    parsed_logs = []\n    for log in logs:\n        try:\n            timestamp_str = log[:19]\n            level_start = log.find('[')\n            level_end = log.find(']')\n            if level_start == -1 or level_end == -1:\n                continue\n            level = log[level_start+1:level_end]\n            timestamp = datetime.strptime(timestamp_str, \"%Y-%m-%d %H:%M:%S\")\n            parsed_logs.append({\"timestamp\": timestamp, \"level\": level, \"raw\": log})\n        except (ValueError, IndexError):\n            continue\n\n    if not parsed_logs:\n        return {\n            \"total_logs\": 0,\n            \"error_count\": 0,\n            \"error_rate\": 0.0,\n            \"max_consecutive_errors\": 0,\n            \"alert_triggered\": False,\n            \"triggered_rules\": []\n        }\n\n    # BUG: 정렬하지 않고 입력 순서대로 처리\n    # parsed_logs.sort(key=lambda x: x[\"timestamp\"])\n    latest_time = max(parsed_logs, key=lambda x: x[\"timestamp\"])[\"timestamp\"]\n    window_start = latest_time.timestamp() - time_window_seconds\n    filtered_logs = [\n        log for log in parsed_logs\n        if log[\"timestamp\"].timestamp() > window_start\n    ]\n\n    total_logs = len(filtered_logs)\n    error_levels = {\"ERROR\", \"CRITICAL\"}\n    errors = [log for log in filtered_logs if log[\"level\"] in error_levels]\n    error_count = len(errors)\n    error_rate = error_count / total_logs if total_logs > 0 else 0.0\n\n    max_consecutive = 0\n    current_consecutive = 0\n    for log in filtered_logs:\n        if log[\"level\"] in error_levels:\n            current_consecutive += 1\n            max_consecutive = max(max_consecutive, current_consecutive)\n        else:\n            current_consecutive = 0\n\n    triggered_rules = []\n    if \"error_count_threshold\" in alert_rules:\n        if error_count >= alert_rules[\"error_count_threshold\"]:\n            triggered_rules.append(\"error_count_threshold\")\n    if \"error_rate_threshold\" in alert_rules:\n        if error_rate >= alert_rules[\"error_rate_threshold\"]:\n            triggered_rules.append(\"error_rate_threshold\")\n    if \"consecutive_errors_threshold\" in alert_rules:\n        if max_consecutive >= alert_rules[\"consecutive_errors_threshold\"]:\n            triggered_rules.append(\"consecutive_errors_threshold\")\n\n    return {\n        \"total_logs\": total_logs,\n        \"error_count\": error_count,\n        \"error_rate\": round(error_rate, 4),\n        \"max_consecutive_errors\": max_consecutive,\n        \"alert_triggered\": len(triggered_rules) > 0,\n        \"triggered_rules\": triggered_rules\n    }",
      "weight": 5
    },
    {
      "bug_description": "임계값 비교에서 '>=' 대신 '>'를 사용하여 정확히 임계값과 같은 경우 알람이 트리거되지 않는다.",
      "buggy_code": "from datetime import datetime\nfrom typing import Optional\n\n\ndef analyze_logs_and_check_alert(\n    logs: list[str],\n    alert_rules: dict,\n    time_window_seconds: int = 60\n) -> dict:\n    '''\n    로그를 분석하고 알람 규칙에 따라 알람 트리거 여부를 판정한다.\n    '''\n    if not logs:\n        return {\n            \"total_logs\": 0,\n            \"error_count\": 0,\n            \"error_rate\": 0.0,\n            \"max_consecutive_errors\": 0,\n            \"alert_triggered\": False,\n            \"triggered_rules\": []\n        }\n\n    parsed_logs = []\n    for log in logs:\n        try:\n            timestamp_str = log[:19]\n            level_start = log.find('[')\n            level_end = log.find(']')\n            if level_start == -1 or level_end == -1:\n                continue\n            level = log[level_start+1:level_end]\n            timestamp = datetime.strptime(timestamp_str, \"%Y-%m-%d %H:%M:%S\")\n            parsed_logs.append({\"timestamp\": timestamp, \"level\": level, \"raw\": log})\n        except (ValueError, IndexError):\n            continue\n\n    if not parsed_logs:\n        return {\n            \"total_logs\": 0,\n            \"error_count\": 0,\n            \"error_rate\": 0.0,\n            \"max_consecutive_errors\": 0,\n            \"alert_triggered\": False,\n            \"triggered_rules\": []\n        }\n\n    parsed_logs.sort(key=lambda x: x[\"timestamp\"])\n    latest_time = parsed_logs[-1][\"timestamp\"]\n    window_start = latest_time.timestamp() - time_window_seconds\n    filtered_logs = [\n        log for log in parsed_logs\n        if log[\"timestamp\"].timestamp() > window_start\n    ]\n\n    total_logs = len(filtered_logs)\n    error_levels = {\"ERROR\", \"CRITICAL\"}\n    errors = [log for log in filtered_logs if log[\"level\"] in error_levels]\n    error_count = len(errors)\n    error_rate = error_count / total_logs if total_logs > 0 else 0.0\n\n    max_consecutive = 0\n    current_consecutive = 0\n    for log in filtered_logs:\n        if log[\"level\"] in error_levels:\n            current_consecutive += 1\n            max_consecutive = max(max_consecutive, current_consecutive)\n        else:\n            current_consecutive = 0\n\n    triggered_rules = []\n    # BUG: >= 대신 > 사용 - 정확히 임계값일 때 트리거 안됨\n    if \"error_count_threshold\" in alert_rules:\n        if error_count > alert_rules[\"error_count_threshold\"]:\n            triggered_rules.append(\"error_count_threshold\")\n    if \"error_rate_threshold\" in alert_rules:\n        if error_rate > alert_rules[\"error_rate_threshold\"]:\n            triggered_rules.append(\"error_rate_threshold\")\n    if \"consecutive_errors_threshold\" in alert_rules:\n        if max_consecutive > alert_rules[\"consecutive_errors_threshold\"]:\n            triggered_rules.append(\"consecutive_errors_threshold\")\n\n    return {\n        \"total_logs\": total_logs,\n        \"error_count\": error_count,\n        \"error_rate\": round(error_rate, 4),\n        \"max_consecutive_errors\": max_consecutive,\n        \"alert_triggered\": len(triggered_rules) > 0,\n        \"triggered_rules\": triggered_rules\n    }",
      "weight": 4
    },
    {
      "bug_description": "잘못된 형식의 로그가 있으면 예외를 발생시켜 전체 분석이 실패한다.",
      "buggy_code": "from datetime import datetime\nfrom typing import Optional\n\n\ndef analyze_logs_and_check_alert(\n    logs: list[str],\n    alert_rules: dict,\n    time_window_seconds: int = 60\n) -> dict:\n    '''\n    로그를 분석하고 알람 규칙에 따라 알람 트리거 여부를 판정한다.\n    '''\n    if not logs:\n        return {\n            \"total_logs\": 0,\n            \"error_count\": 0,\n            \"error_rate\": 0.0,\n            \"max_consecutive_errors\": 0,\n            \"alert_triggered\": False,\n            \"triggered_rules\": []\n        }\n\n    parsed_logs = []\n    for log in logs:\n        # BUG: 예외 처리 없이 파싱 - 잘못된 로그가 있으면 전체 실패\n        timestamp_str = log[:19]\n        level_start = log.find('[')\n        level_end = log.find(']')\n        if level_start == -1 or level_end == -1:\n            raise ValueError(f\"Invalid log format: {log}\")\n        level = log[level_start+1:level_end]\n        timestamp = datetime.strptime(timestamp_str, \"%Y-%m-%d %H:%M:%S\")\n        parsed_logs.append({\"timestamp\": timestamp, \"level\": level, \"raw\": log})\n\n    if not parsed_logs:\n        return {\n            \"total_logs\": 0,\n            \"error_count\": 0,\n            \"error_rate\": 0.0,\n            \"max_consecutive_errors\": 0,\n            \"alert_triggered\": False,\n            \"triggered_rules\": []\n        }\n\n    parsed_logs.sort(key=lambda x: x[\"timestamp\"])\n    latest_time = parsed_logs[-1][\"timestamp\"]\n    window_start = latest_time.timestamp() - time_window_seconds\n    filtered_logs = [\n        log for log in parsed_logs\n        if log[\"timestamp\"].timestamp() > window_start\n    ]\n\n    total_logs = len(filtered_logs)\n    error_levels = {\"ERROR\", \"CRITICAL\"}\n    errors = [log for log in filtered_logs if log[\"level\"] in error_levels]\n    error_count = len(errors)\n    error_rate = error_count / total_logs if total_logs > 0 else 0.0\n\n    max_consecutive = 0\n    current_consecutive = 0\n    for log in filtered_logs:\n        if log[\"level\"] in error_levels:\n            current_consecutive += 1\n            max_consecutive = max(max_consecutive, current_consecutive)\n        else:\n            current_consecutive = 0\n\n    triggered_rules = []\n    if \"error_count_threshold\" in alert_rules:\n        if error_count >= alert_rules[\"error_count_threshold\"]:\n            triggered_rules.append(\"error_count_threshold\")\n    if \"error_rate_threshold\" in alert_rules:\n        if error_rate >= alert_rules[\"error_rate_threshold\"]:\n            triggered_rules.append(\"error_rate_threshold\")\n    if \"consecutive_errors_threshold\" in alert_rules:\n        if max_consecutive >= alert_rules[\"consecutive_errors_threshold\"]:\n            triggered_rules.append(\"consecutive_errors_threshold\")\n\n    return {\n        \"total_logs\": total_logs,\n        \"error_count\": error_count,\n        \"error_rate\": round(error_rate, 4),\n        \"max_consecutive_errors\": max_consecutive,\n        \"alert_triggered\": len(triggered_rules) > 0,\n        \"triggered_rules\": triggered_rules\n    }",
      "weight": 3
    },
    {
      "bug_description": "빈 로그 리스트에서 0 나누기 오류가 발생하여 error_rate 계산이 실패한다.",
      "buggy_code": "from datetime import datetime\nfrom typing import Optional\n\n\ndef analyze_logs_and_check_alert(\n    logs: list[str],\n    alert_rules: dict,\n    time_window_seconds: int = 60\n) -> dict:\n    '''\n    로그를 분석하고 알람 규칙에 따라 알람 트리거 여부를 판정한다.\n    '''\n    # BUG: 빈 로그 처리 누락\n    parsed_logs = []\n    for log in logs:\n        try:\n            timestamp_str = log[:19]\n            level_start = log.find('[')\n            level_end = log.find(']')\n            if level_start == -1 or level_end == -1:\n                continue\n            level = log[level_start+1:level_end]\n            timestamp = datetime.strptime(timestamp_str, \"%Y-%m-%d %H:%M:%S\")\n            parsed_logs.append({\"timestamp\": timestamp, \"level\": level, \"raw\": log})\n        except (ValueError, IndexError):\n            continue\n\n    if not parsed_logs:\n        # BUG: error_rate 계산에서 0 나누기 방지 안됨\n        total_logs = 0\n        error_count = 0\n        error_rate = error_count / total_logs  # ZeroDivisionError!\n        return {\n            \"total_logs\": total_logs,\n            \"error_count\": error_count,\n            \"error_rate\": error_rate,\n            \"max_consecutive_errors\": 0,\n            \"alert_triggered\": False,\n            \"triggered_rules\": []\n        }\n\n    parsed_logs.sort(key=lambda x: x[\"timestamp\"])\n    latest_time = parsed_logs[-1][\"timestamp\"]\n    window_start = latest_time.timestamp() - time_window_seconds\n    filtered_logs = [\n        log for log in parsed_logs\n        if log[\"timestamp\"].timestamp() > window_start\n    ]\n\n    total_logs = len(filtered_logs)\n    error_levels = {\"ERROR\", \"CRITICAL\"}\n    errors = [log for log in filtered_logs if log[\"level\"] in error_levels]\n    error_count = len(errors)\n    error_rate = error_count / total_logs if total_logs > 0 else 0.0\n\n    max_consecutive = 0\n    current_consecutive = 0\n    for log in filtered_logs:\n        if log[\"level\"] in error_levels:\n            current_consecutive += 1\n            max_consecutive = max(max_consecutive, current_consecutive)\n        else:\n            current_consecutive = 0\n\n    triggered_rules = []\n    if \"error_count_threshold\" in alert_rules:\n        if error_count >= alert_rules[\"error_count_threshold\"]:\n            triggered_rules.append(\"error_count_threshold\")\n    if \"error_rate_threshold\" in alert_rules:\n        if error_rate >= alert_rules[\"error_rate_threshold\"]:\n            triggered_rules.append(\"error_rate_threshold\")\n    if \"consecutive_errors_threshold\" in alert_rules:\n        if max_consecutive >= alert_rules[\"consecutive_errors_threshold\"]:\n            triggered_rules.append(\"consecutive_errors_threshold\")\n\n    return {\n        \"total_logs\": total_logs,\n        \"error_count\": error_count,\n        \"error_rate\": round(error_rate, 4),\n        \"max_consecutive_errors\": max_consecutive,\n        \"alert_triggered\": len(triggered_rules) > 0,\n        \"triggered_rules\": triggered_rules\n    }",
      "weight": 3
    }
  ],
  "description_md": "## 문제 설명\n\n운영 환경에서 **로그 모니터링**은 시스템 건강 상태를 파악하고 문제를 조기에 감지하는 핵심 활동입니다. 이 문제에서는 로그를 분석하고 정의된 알람 규칙에 따라 알람을 트리거해야 하는지 판정하는 `analyze_logs_and_check_alert` 함수를 테스트합니다.\n\n### 함수 시그니처\n\n```python\ndef analyze_logs_and_check_alert(\n    logs: list[str],\n    alert_rules: dict,\n    time_window_seconds: int = 60\n) -> dict:\n```\n\n### 로그 형식\n\n```\nYYYY-MM-DD HH:MM:SS [LEVEL] message\n```\n\n- 예: `\"2024-01-15 10:30:45 [ERROR] Connection failed\"`\n- 레벨: `INFO`, `WARNING`, `ERROR`, `CRITICAL`\n- `ERROR`와 `CRITICAL`은 에러로 취급\n\n### 알람 규칙 (alert_rules)\n\n```python\n{\n    \"error_count_threshold\": 5,       # 에러 개수 >= 5이면 알람\n    \"error_rate_threshold\": 0.3,      # 에러율 >= 30%이면 알람\n    \"consecutive_errors_threshold\": 3  # 연속 에러 >= 3이면 알람\n}\n```\n\n각 규칙은 선택적이며, 설정된 규칙 중 하나라도 충족하면 알람이 트리거됩니다.\n\n### 반환값\n\n```python\n{\n    \"total_logs\": int,              # 윈도우 내 총 로그 수\n    \"error_count\": int,             # 에러 로그 수\n    \"error_rate\": float,            # 에러율 (0.0~1.0)\n    \"max_consecutive_errors\": int,  # 최대 연속 에러 수\n    \"alert_triggered\": bool,        # 알람 트리거 여부\n    \"triggered_rules\": list[str]    # 트리거된 규칙 이름 목록\n}\n```\n\n### 예시\n\n```python\nlogs = [\n    \"2024-01-15 10:30:00 [INFO] Started\",\n    \"2024-01-15 10:30:10 [ERROR] Failed\",\n    \"2024-01-15 10:30:20 [ERROR] Failed\",\n    \"2024-01-15 10:30:30 [ERROR] Failed\",\n    \"2024-01-15 10:30:40 [INFO] Recovered\",\n]\n\nrules = {\"consecutive_errors_threshold\": 3}\nresult = analyze_logs_and_check_alert(logs, rules, time_window_seconds=60)\n# max_consecutive_errors=3, alert_triggered=True\n```\n\n### 테스트 작성 시 고려사항\n\n1. **로그 파싱**: 다양한 형식의 로그 처리 (정상, 비정상 형식)\n2. **시간 윈도우**: 경계값 (정확히 윈도우 시작 시간의 로그)\n3. **통계 계산**: 에러 개수, 에러율, 연속 에러의 정확성\n4. **임계값 경계**: 정확히 임계값과 같은 경우\n5. **시간순 정렬**: 입력 순서와 무관하게 시간순으로 연속 에러 계산\n6. **엣지 케이스**: 빈 로그, 모든 로그가 에러, 모든 로그가 정상 등\n\n### 여러분의 과제\n\n`analyze_logs_and_check_alert` 함수의 여러 구현이 준비되어 있으며, 일부에는 의도적인 버그가 있습니다.\n\npytest를 사용해 테스트 케이스를 작성하여:\n\n- 올바른 구현은 모든 테스트를 통과하고,\n- 버그가 있는 구현들은 하나 이상 테스트에서 실패하도록\n\n테스트 스위트를 설계해 보세요. 이 문제는 문자열 파싱, 통계 계산, 경계값 분석 능력을 평가합니다.\n",
  "initial_test_template": "import pytest\nfrom target import analyze_logs_and_check_alert\n\n\n# 기본 동작 테스트\n\ndef test_empty_logs():\n    # TODO: 빈 로그 리스트 처리\n    pass\n\n\ndef test_all_info_logs():\n    # TODO: 모든 로그가 INFO일 때 에러 개수 0\n    pass\n\n\ndef test_all_error_logs():\n    # TODO: 모든 로그가 ERROR일 때 에러율 100%\n    pass\n\n\n# 통계 계산 테스트\n\ndef test_error_count_calculation():\n    # TODO: 에러 개수가 정확하게 계산되는지 확인\n    pass\n\n\ndef test_error_rate_calculation():\n    # TODO: 에러율이 정확하게 계산되는지 확인\n    pass\n\n\ndef test_consecutive_errors_calculation():\n    # TODO: 연속 에러가 정확하게 계산되는지 확인\n    # 힌트: 입력 순서와 시간순이 다른 경우 테스트\n    pass\n\n\n# 알람 규칙 테스트\n\ndef test_threshold_boundary_equal():\n    # TODO: 정확히 임계값과 같은 경우 알람 트리거\n    pass\n\n\ndef test_threshold_boundary_below():\n    # TODO: 임계값보다 1 작은 경우 알람 미트리거\n    pass\n\n\n# 엣지 케이스 테스트\n\ndef test_malformed_log_handling():\n    # TODO: 잘못된 형식의 로그가 있을 때 정상 처리\n    pass\n\n\ndef test_time_window_boundary():\n    # TODO: 시간 윈도우 경계에 있는 로그 처리\n    pass\n",
  "tags": [
    "medium",
    "python",
    "pytest",
    "unit-test",
    "log-analysis",
    "parsing",
    "statistics",
    "boundary-value",
    "monitoring"
  ],
  "difficulty": "Medium"
}
