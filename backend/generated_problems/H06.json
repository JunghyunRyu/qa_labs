{
  "title": "Retry/Backoff API 클라이언트 함수 테스트",
  "function_signature": "def fetch_with_retry(\n    request_fn: Callable[[], dict],\n    max_retries: int = 3,\n    base_delay_ms: int = 100,\n    backoff_multiplier: float = 2.0,\n    sleep_fn: Callable[[float], None] | None = None\n) -> dict:",
  "golden_code": "from typing import Callable\nimport time\n\n\ndef fetch_with_retry(\n    request_fn: Callable[[], dict],\n    max_retries: int = 3,\n    base_delay_ms: int = 100,\n    backoff_multiplier: float = 2.0,\n    sleep_fn: Callable[[float], None] | None = None\n) -> dict:\n    '''\n    API 호출을 시도하고 실패 시 지수 백오프로 재시도하는 함수.\n\n    Parameters:\n    - request_fn: API 호출을 수행하는 콜러블. 성공 시 {\"success\": True, \"data\": ...} 반환,\n                  실패 시 {\"success\": False, \"error\": ...} 반환 또는 예외 발생.\n    - max_retries: 최대 재시도 횟수 (기본값 3). 총 시도 횟수는 1 + max_retries.\n    - base_delay_ms: 기본 대기 시간 (밀리초, 기본값 100).\n    - backoff_multiplier: 지수 백오프 배율 (기본값 2.0).\n    - sleep_fn: 대기 함수. None이면 time.sleep 사용. 테스트 시 모킹용.\n\n    Returns:\n    - 성공 시: {\"success\": True, \"data\": ..., \"attempts\": N}\n    - 모든 시도 실패 시: {\"success\": False, \"error\": ..., \"attempts\": N}\n\n    Backoff 계산: delay = base_delay_ms * (backoff_multiplier ** attempt)\n    - attempt=0: 100ms, attempt=1: 200ms, attempt=2: 400ms ...\n    '''\n    if sleep_fn is None:\n        sleep_fn = time.sleep\n\n    last_error = None\n    attempts = 0\n\n    for attempt in range(max_retries + 1):\n        attempts += 1\n        try:\n            result = request_fn()\n            if isinstance(result, dict) and result.get(\"success\") is True:\n                return {\"success\": True, \"data\": result.get(\"data\"), \"attempts\": attempts}\n            else:\n                last_error = result.get(\"error\", \"Unknown error\") if isinstance(result, dict) else \"Invalid response\"\n        except Exception as e:\n            last_error = str(e)\n\n        # 마지막 시도 후에는 sleep하지 않음\n        if attempt < max_retries:\n            delay_seconds = (base_delay_ms * (backoff_multiplier ** attempt)) / 1000.0\n            sleep_fn(delay_seconds)\n\n    return {\"success\": False, \"error\": last_error, \"attempts\": attempts}",
  "buggy_implementations": [
    {
      "bug_description": "지수 백오프 계산에서 attempt 대신 attempt+1을 사용하여 대기 시간이 예상보다 길다.",
      "buggy_code": "from typing import Callable\nimport time\n\n\ndef fetch_with_retry(\n    request_fn: Callable[[], dict],\n    max_retries: int = 3,\n    base_delay_ms: int = 100,\n    backoff_multiplier: float = 2.0,\n    sleep_fn: Callable[[float], None] | None = None\n) -> dict:\n    '''\n    API 호출을 시도하고 실패 시 지수 백오프로 재시도하는 함수.\n    '''\n    if sleep_fn is None:\n        sleep_fn = time.sleep\n\n    last_error = None\n    attempts = 0\n\n    for attempt in range(max_retries + 1):\n        attempts += 1\n        try:\n            result = request_fn()\n            if isinstance(result, dict) and result.get(\"success\") is True:\n                return {\"success\": True, \"data\": result.get(\"data\"), \"attempts\": attempts}\n            else:\n                last_error = result.get(\"error\", \"Unknown error\") if isinstance(result, dict) else \"Invalid response\"\n        except Exception as e:\n            last_error = str(e)\n\n        if attempt < max_retries:\n            # BUG: attempt + 1 대신 attempt를 사용해야 함 (off-by-one)\n            delay_seconds = (base_delay_ms * (backoff_multiplier ** (attempt + 1))) / 1000.0\n            sleep_fn(delay_seconds)\n\n    return {\"success\": False, \"error\": last_error, \"attempts\": attempts}",
      "weight": 4
    },
    {
      "bug_description": "success 필드의 타입을 엄격하게 검사하지 않아 truthy 값(예: 1, \"true\")도 성공으로 처리한다.",
      "buggy_code": "from typing import Callable\nimport time\n\n\ndef fetch_with_retry(\n    request_fn: Callable[[], dict],\n    max_retries: int = 3,\n    base_delay_ms: int = 100,\n    backoff_multiplier: float = 2.0,\n    sleep_fn: Callable[[float], None] | None = None\n) -> dict:\n    '''\n    API 호출을 시도하고 실패 시 지수 백오프로 재시도하는 함수.\n    '''\n    if sleep_fn is None:\n        sleep_fn = time.sleep\n\n    last_error = None\n    attempts = 0\n\n    for attempt in range(max_retries + 1):\n        attempts += 1\n        try:\n            result = request_fn()\n            # BUG: result.get(\"success\") is True 대신 truthy 체크\n            if isinstance(result, dict) and result.get(\"success\"):\n                return {\"success\": True, \"data\": result.get(\"data\"), \"attempts\": attempts}\n            else:\n                last_error = result.get(\"error\", \"Unknown error\") if isinstance(result, dict) else \"Invalid response\"\n        except Exception as e:\n            last_error = str(e)\n\n        if attempt < max_retries:\n            delay_seconds = (base_delay_ms * (backoff_multiplier ** attempt)) / 1000.0\n            sleep_fn(delay_seconds)\n\n    return {\"success\": False, \"error\": last_error, \"attempts\": attempts}",
      "weight": 3
    },
    {
      "bug_description": "마지막 시도 후에도 불필요한 sleep을 수행하여 성능이 저하된다.",
      "buggy_code": "from typing import Callable\nimport time\n\n\ndef fetch_with_retry(\n    request_fn: Callable[[], dict],\n    max_retries: int = 3,\n    base_delay_ms: int = 100,\n    backoff_multiplier: float = 2.0,\n    sleep_fn: Callable[[float], None] | None = None\n) -> dict:\n    '''\n    API 호출을 시도하고 실패 시 지수 백오프로 재시도하는 함수.\n    '''\n    if sleep_fn is None:\n        sleep_fn = time.sleep\n\n    last_error = None\n    attempts = 0\n\n    for attempt in range(max_retries + 1):\n        attempts += 1\n        try:\n            result = request_fn()\n            if isinstance(result, dict) and result.get(\"success\") is True:\n                return {\"success\": True, \"data\": result.get(\"data\"), \"attempts\": attempts}\n            else:\n                last_error = result.get(\"error\", \"Unknown error\") if isinstance(result, dict) else \"Invalid response\"\n        except Exception as e:\n            last_error = str(e)\n\n        # BUG: 마지막 시도 후에도 sleep 수행 (불필요한 대기)\n        delay_seconds = (base_delay_ms * (backoff_multiplier ** attempt)) / 1000.0\n        sleep_fn(delay_seconds)\n\n    return {\"success\": False, \"error\": last_error, \"attempts\": attempts}",
      "weight": 3
    },
    {
      "bug_description": "max_retries=0일 때 첫 번째 시도조차 하지 않고 바로 실패를 반환한다.",
      "buggy_code": "from typing import Callable\nimport time\n\n\ndef fetch_with_retry(\n    request_fn: Callable[[], dict],\n    max_retries: int = 3,\n    base_delay_ms: int = 100,\n    backoff_multiplier: float = 2.0,\n    sleep_fn: Callable[[float], None] | None = None\n) -> dict:\n    '''\n    API 호출을 시도하고 실패 시 지수 백오프로 재시도하는 함수.\n    '''\n    if sleep_fn is None:\n        sleep_fn = time.sleep\n\n    last_error = None\n    attempts = 0\n\n    # BUG: range(max_retries + 1) 대신 range(max_retries)를 사용\n    # max_retries=0이면 루프가 전혀 실행되지 않음\n    for attempt in range(max_retries):\n        attempts += 1\n        try:\n            result = request_fn()\n            if isinstance(result, dict) and result.get(\"success\") is True:\n                return {\"success\": True, \"data\": result.get(\"data\"), \"attempts\": attempts}\n            else:\n                last_error = result.get(\"error\", \"Unknown error\") if isinstance(result, dict) else \"Invalid response\"\n        except Exception as e:\n            last_error = str(e)\n\n        if attempt < max_retries - 1:\n            delay_seconds = (base_delay_ms * (backoff_multiplier ** attempt)) / 1000.0\n            sleep_fn(delay_seconds)\n\n    return {\"success\": False, \"error\": last_error or \"No attempts made\", \"attempts\": attempts}",
      "weight": 5
    },
    {
      "bug_description": "sleep_fn이 None일 때 기본 sleep 함수를 설정하지 않아 재시도 시 대기 없이 즉시 호출한다.",
      "buggy_code": "from typing import Callable\nimport time\n\n\ndef fetch_with_retry(\n    request_fn: Callable[[], dict],\n    max_retries: int = 3,\n    base_delay_ms: int = 100,\n    backoff_multiplier: float = 2.0,\n    sleep_fn: Callable[[float], None] | None = None\n) -> dict:\n    '''\n    API 호출을 시도하고 실패 시 지수 백오프로 재시도하는 함수.\n    '''\n    # BUG: sleep_fn이 None일 때 time.sleep으로 대체하지 않음\n    last_error = None\n    attempts = 0\n\n    for attempt in range(max_retries + 1):\n        attempts += 1\n        try:\n            result = request_fn()\n            if isinstance(result, dict) and result.get(\"success\") is True:\n                return {\"success\": True, \"data\": result.get(\"data\"), \"attempts\": attempts}\n            else:\n                last_error = result.get(\"error\", \"Unknown error\") if isinstance(result, dict) else \"Invalid response\"\n        except Exception as e:\n            last_error = str(e)\n\n        if attempt < max_retries:\n            delay_seconds = (base_delay_ms * (backoff_multiplier ** attempt)) / 1000.0\n            # BUG: sleep_fn이 None이면 아무것도 안 함 (대기 누락)\n            if sleep_fn is not None:\n                sleep_fn(delay_seconds)\n\n    return {\"success\": False, \"error\": last_error, \"attempts\": attempts}",
      "weight": 4
    }
  ],
  "description_md": "## 문제 설명\n\n현대 분산 시스템에서 API 호출은 일시적인 네트워크 오류나 서버 과부하로 인해 실패할 수 있습니다. 이런 상황에서 단순히 실패를 반환하는 대신, **지수 백오프(Exponential Backoff)**를 사용하여 점진적으로 대기 시간을 늘리며 재시도하는 것이 일반적인 패턴입니다.\n\n이 문제에서는 `fetch_with_retry` 함수에 대한 테스트를 작성합니다.\n\n### 함수 동작\n\n```python\ndef fetch_with_retry(\n    request_fn: Callable[[], dict],\n    max_retries: int = 3,\n    base_delay_ms: int = 100,\n    backoff_multiplier: float = 2.0,\n    sleep_fn: Callable[[float], None] | None = None\n) -> dict:\n```\n\n- `request_fn`: API 호출 함수. 성공 시 `{\"success\": True, \"data\": ...}`, 실패 시 `{\"success\": False, \"error\": ...}` 반환.\n- `max_retries`: 최대 재시도 횟수. 총 시도 횟수는 `1 + max_retries`.\n- `base_delay_ms`: 기본 대기 시간 (밀리초).\n- `backoff_multiplier`: 지수 백오프 배율.\n- `sleep_fn`: 테스트 시 시간을 제어하기 위한 주입 가능한 대기 함수.\n\n### 백오프 계산\n\n```\ndelay = base_delay_ms * (backoff_multiplier ** attempt)\n```\n\n- attempt=0: 100ms\n- attempt=1: 200ms\n- attempt=2: 400ms\n- ...\n\n### 반환값\n\n- 성공: `{\"success\": True, \"data\": ..., \"attempts\": N}`\n- 실패: `{\"success\": False, \"error\": ..., \"attempts\": N}`\n\n### 예시\n\n```python\n# 첫 번째 시도에서 성공\ndef always_succeed():\n    return {\"success\": True, \"data\": \"result\"}\n\nresult = fetch_with_retry(always_succeed)\n# {\"success\": True, \"data\": \"result\", \"attempts\": 1}\n\n# 2번 실패 후 3번째에 성공 (max_retries=3)\ncall_count = 0\ndef succeed_on_third():\n    global call_count\n    call_count += 1\n    if call_count < 3:\n        return {\"success\": False, \"error\": \"temporary failure\"}\n    return {\"success\": True, \"data\": \"finally!\"}\n\nresult = fetch_with_retry(succeed_on_third)\n# {\"success\": True, \"data\": \"finally!\", \"attempts\": 3}\n```\n\n### 테스트 작성 시 고려사항\n\n1. **Mock 객체 활용**: `request_fn`을 모킹하여 호출 횟수와 순서를 검증하세요.\n2. **시간 제어**: `sleep_fn`을 주입하여 실제 대기 없이 호출된 대기 시간을 검증하세요.\n3. **경계값 테스트**: `max_retries=0` (재시도 없음), 첫 시도 성공, 마지막 시도 성공 등.\n4. **응답 타입 검증**: `{\"success\": 1}` vs `{\"success\": True}` 구분.\n5. **성능 검증**: 마지막 시도 후 불필요한 sleep이 없어야 함.\n\n### 여러분의 과제\n\n`fetch_with_retry` 함수의 여러 구현이 준비되어 있으며, 일부에는 의도적인 버그가 있습니다.\n\npytest를 사용해 테스트 케이스를 작성하여:\n\n- 올바른 구현은 모든 테스트를 통과하고,\n- 버그가 있는 구현들은 하나 이상 테스트에서 실패하도록\n\n테스트 스위트를 설계해 보세요. 이 문제는 Mock 활용, 의존성 주입, 시간 제어 등 고급 테스트 기법을 평가합니다.\n",
  "initial_test_template": "import pytest\nfrom target import fetch_with_retry\n\n\n# 기본 동작 테스트\n\ndef test_first_attempt_success():\n    # TODO: 첫 번째 시도에서 성공하는 케이스 테스트\n    # - request_fn이 즉시 성공 응답 반환\n    # - attempts가 1인지 확인\n    pass\n\n\ndef test_retry_then_success():\n    # TODO: N번 실패 후 성공하는 케이스 테스트\n    # - request_fn의 호출 횟수 검증\n    # - 최종 attempts 값 검증\n    pass\n\n\ndef test_all_retries_exhausted():\n    # TODO: 모든 재시도가 실패하는 케이스 테스트\n    # - max_retries + 1 번 호출되는지 확인\n    # - success=False 반환 확인\n    pass\n\n\n# 백오프 및 타이밍 테스트\n\ndef test_exponential_backoff_timing():\n    # TODO: sleep_fn을 주입하여 백오프 시간 검증\n    # - attempt=0: 100ms, attempt=1: 200ms 등\n    pass\n\n\ndef test_no_sleep_after_last_attempt():\n    # TODO: 마지막 시도 후에는 sleep이 호출되지 않아야 함\n    pass\n\n\n# 경계값 및 엣지 케이스\n\ndef test_max_retries_zero():\n    # TODO: max_retries=0일 때 첫 시도만 수행\n    pass\n\n\ndef test_success_type_strict_check():\n    # TODO: {\"success\": 1}은 성공으로 처리되면 안 됨\n    # - success 필드가 정확히 True인 경우만 성공\n    pass\n",
  "tags": [
    "hard",
    "python",
    "pytest",
    "unit-test",
    "mock",
    "retry",
    "backoff",
    "api",
    "dependency-injection",
    "time-control"
  ],
  "difficulty": "Hard"
}
