{
  "function_signature": "def is_valid_email(email: str) -> bool:",
  "golden_code": "def is_valid_email(email: str) -> bool:\n    '''\n    Validate a user-facing email address for a sign-up form.\n\n    This is not a full RFC 5322 validator. It enforces a common subset of rules:\n\n    Rules:\n    - The input must be a non-empty string.\n    - It must contain exactly one '@' symbol.\n    - The local part (before '@') and the domain part (after '@') must both be non-empty.\n    - No spaces are allowed anywhere in the address.\n    - The local part may contain letters, digits, '.', '_', '-', and '+'.\n    - The domain part may contain letters, digits, '.', and '-'.\n    - The domain must contain at least one '.' that is not at the start or end.\n    - No consecutive dots ('..') are allowed in either part.\n    - The top-level domain (text after the final '.') must be at least 2 characters long.\n    '''\n    if not isinstance(email, str):\n        return False\n    if not email or ' ' in email:\n        return False\n    if email.count('@') != 1:\n        return False\n    local, domain = email.split('@')\n    if not local or not domain:\n        return False\n    allowed_local = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._+-')\n    allowed_domain = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-')\n    if any(ch not in allowed_local for ch in local):\n        return False\n    if any(ch not in allowed_domain for ch in domain):\n        return False\n    if '..' in local or '..' in domain:\n        return False\n    if '.' not in domain:\n        return False\n    if domain.startswith('.') or domain.endswith('.'):\n        return False\n    labels = domain.split('.')\n    if any(not label for label in labels):\n        return False\n    if len(labels[-1]) < 2:\n        return False\n    return True",
  "buggy_implementations": [
    {
      "bug_description": "이메일에 '@' 가 두 개 이상 있거나 도메인에 허용되지 않은 특수문자가 포함되어도 유효하다고 판단한다.",
      "buggy_code": "def is_valid_email(email: str) -> bool:\n    '''\n    Validate a user-facing email address for a sign-up form.\n\n    This implementation is intentionally slightly different from production code.\n    It still aims to enforce a common subset of rules.\n    '''\n    if not isinstance(email, str):\n        return False\n    if not email or ' ' in email:\n        return False\n    # BUG: only checks that there is at least one '@', not exactly one.\n    if '@' not in email:\n        return False\n    local, domain = email.split('@', 1)\n    if not local or not domain:\n        return False\n    allowed_local = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._+-')\n    # BUG: domain characters are not restricted.\n    if any(ch not in allowed_local for ch in local):\n        return False\n    if '..' in local or '..' in domain:\n        return False\n    if '.' not in domain:\n        return False\n    if domain.startswith('.') or domain.endswith('.'):\n        return False\n    labels = domain.split('.')\n    if any(not label for label in labels):\n        return False\n    if len(labels[-1]) < 2:\n        return False\n    return True",
      "weight": 4
    },
    {
      "bug_description": "도메인 부분에 점(.)이 전혀 없는 주소(예: 'user@localhost')를 잘못 유효하다고 판단한다.",
      "buggy_code": "def is_valid_email(email: str) -> bool:\n    '''\n    Validate a user-facing email address for a sign-up form.\n\n    Variant with a subtle difference in domain validation.\n    '''\n    if not isinstance(email, str):\n        return False\n    if not email or ' ' in email:\n        return False\n    if email.count('@') != 1:\n        return False\n    local, domain = email.split('@')\n    if not local or not domain:\n        return False\n    allowed_local = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._+-')\n    allowed_domain = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-')\n    if any(ch not in allowed_local for ch in local):\n        return False\n    if any(ch not in allowed_domain for ch in domain):\n        return False\n    if '..' in local or '..' in domain:\n        return False\n    # BUG: does not enforce that the domain contains at least one dot.\n    # if '.' not in domain:\n    #     return False\n    if domain.startswith('.') or domain.endswith('.'):\n        return False\n    labels = domain.split('.')\n    if any(not label for label in labels):\n        return False\n    if len(labels[-1]) < 2:\n        return False\n    return True",
      "weight": 3
    },
    {
      "bug_description": "로컬 부분이 비어 있는 주소(예: '@example.com')를 허용한다.",
      "buggy_code": "def is_valid_email(email: str) -> bool:\n    '''\n    Validate a user-facing email address for a sign-up form.\n\n    Variant with a subtle difference in how empty parts are handled.\n    '''\n    if not isinstance(email, str):\n        return False\n    if not email or ' ' in email:\n        return False\n    if email.count('@') != 1:\n        return False\n    local, domain = email.split('@')\n    # BUG: does not check that the local part is non-empty.\n    if not domain:\n        return False\n    allowed_local = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._+-')\n    allowed_domain = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-')\n    if any(ch not in allowed_local for ch in local):\n        return False\n    if any(ch not in allowed_domain for ch in domain):\n        return False\n    if '..' in local or '..' in domain:\n        return False\n    if '.' not in domain:\n        return False\n    if domain.startswith('.') or domain.endswith('.'):\n        return False\n    labels = domain.split('.')\n    if any(not label for label in labels):\n        return False\n    if len(labels[-1]) < 2:\n        return False\n    return True",
      "weight": 2
    },
    {
      "bug_description": "로컬 부분에 연속된 점이 있는 주소(예: 'first..last@example.com')를 허용한다.",
      "buggy_code": "def is_valid_email(email: str) -> bool:\n    '''\n    Validate a user-facing email address for a sign-up form.\n\n    Variant with a subtle difference in how consecutive dots are treated.\n    '''\n    if not isinstance(email, str):\n        return False\n    if not email or ' ' in email:\n        return False\n    if email.count('@') != 1:\n        return False\n    local, domain = email.split('@')\n    if not local or not domain:\n        return False\n    allowed_local = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._+-')\n    allowed_domain = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-')\n    if any(ch not in allowed_local for ch in local):\n        return False\n    if any(ch not in allowed_domain for ch in domain):\n        return False\n    # BUG: only checks for consecutive dots in the domain, not in the local part.\n    if '..' in domain:\n        return False\n    if '.' not in domain:\n        return False\n    if domain.startswith('.') or domain.endswith('.'):\n        return False\n    labels = domain.split('.')\n    if any(not label for label in labels):\n        return False\n    if len(labels[-1]) < 2:\n        return False\n    return True",
      "weight": 3
    }
  ],
  "description_md": "## 문제 설명\n\n회원 가입, 비밀번호 재설정 등 사용자 계정 관련 기능에서는 사용자가 입력한 이메일 주소가 기본적인 형식을 만족하는지 빠르게 검증해야 합니다. 이 문제에서는 간단한 이메일 형식 검증 함수 `is_valid_email` 에 대한 테스트를 작성합니다.\n\n함수는 다음과 같은 규칙을 따르는 것으로 가정합니다 (RFC 전체를 구현하는 것은 아님):\n\n- 입력은 공백이 없는, 빈 문자열이 아닌 이메일 주소 문자열입니다.\n- 정확히 하나의 '@' 기호가 있어야 합니다.\n- '@' 앞(local part)과 뒤(domain part)는 모두 비어 있지 않아야 합니다.\n- local part 에는 알파벳, 숫자, '.', '_', '-', '+' 만 허용됩니다.\n- domain part 에는 알파벳, 숫자, '.', '-' 만 허용됩니다.\n- domain 에는 적어도 하나의 '.' 가 포함되어야 하며, 맨 앞과 맨 뒤에는 올 수 없습니다.\n- local 과 domain 어느 쪽이든 연속된 두 개의 점('..')은 허용되지 않습니다.\n- 마지막 점 이후의 문자열(TLD)은 최소 2 글자 이상이어야 합니다.\n\n함수는 위 규칙을 모두 만족하면 `True`, 그렇지 않으면 `False` 를 반환합니다.\n\n### 예시\n\n- `is_valid_email('user@example.com')` -> `True`\n- `is_valid_email('first.last+tag@sub.domain.co')` -> `True`\n- `is_valid_email('invalid@@example.com')` -> `False`\n- `is_valid_email('user@localhost')` -> `False`\n\n### 테스트에서 고려할 점\n\n- 가장 단순한 정상 케이스부터 복잡한 케이스까지, 다양한 문자열을 사용해 보세요.\n- '@' 가 없거나 여러 개 있는 경우, local/domain 이 비어 있는 경우 등 형식 위반 케이스를 나눠 보세요.\n- domain 에 점이 없는 경우, 점이 연속된 경우, 맨 앞/맨 뒤에 점이 오는 경우 등을 구분해서 테스트해 보세요.\n- 허용되지 않은 문자(공백, 특수문자 등)가 포함된 경우를 테스트해 보세요.\n- 최소한의 길이(TLD 길이 2 글자 등)와 같이 경계값에 해당하는 문자열도 포함해 보세요.\n\n### 여러분의 과제\n\n이미 `is_valid_email` 함수의 여러 구현이 준비되어 있으며, 그 중에는 의도적으로 버그가 심어져 있는 버전도 있습니다.\n\npytest 를 사용해 충분히 다양한 테스트 케이스를 작성하여:\n\n- 올바른 구현은 모든 테스트를 통과하고,\n- 버그가 있는 구현들은 하나 이상 테스트에서 실패하도록\n\n테스트 스위트를 설계해 보세요. 이 문제는 문자열 처리(string manipulation)와 형식 검증(format validation) 능력을 평가하기 위한 것입니다.\n",
  "initial_test_template": "import pytest\nfrom target import is_valid_email\n\n\n# 기본적인 포맷 검증 테스트들\n\ndef test_simple_valid_emails():\n    # TODO: 가장 기본적인 정상 케이스 몇 가지를 테스트하세요.\n    # 예: 알파벳과 숫자만 포함된 이메일, 서브도메인이 있는 이메일 등\n    pass\n\n\ndef test_invalid_format_variations():\n    # TODO: '@' 개수, local/domain 비어 있음, domain 에 점이 없는 경우 등을 테스트하세요.\n    pass\n\n\ndef test_boundary_and_special_characters():\n    # TODO: 연속된 점, 허용/비허용 문자, TLD 길이 1/2 글자 등 경계값을 테스트하세요.\n    pass\n",
  "tags": [
    "easy",
    "python",
    "pytest",
    "unit-test",
    "string",
    "validation",
    "email",
    "string manipulation",
    "format validation"
  ],
  "difficulty": "Easy"
}