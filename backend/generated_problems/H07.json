{
  "title": "Rate Limiter (토큰 버킷) 클래스 테스트",
  "function_signature": "class TokenBucketRateLimiter:\n    def __init__(self, capacity: int, refill_rate: float, time_fn: Callable[[], float] | None = None):\n    def try_acquire(self, tokens: int = 1) -> bool:\n    def get_available_tokens(self) -> float:",
  "golden_code": "from typing import Callable\nimport time\n\n\nclass TokenBucketRateLimiter:\n    '''\n    토큰 버킷 알고리즘 기반 Rate Limiter.\n\n    Parameters:\n    - capacity: 버킷의 최대 토큰 수\n    - refill_rate: 초당 리필되는 토큰 수\n    - time_fn: 현재 시간(초)을 반환하는 함수. None이면 time.time() 사용.\n\n    토큰 버킷 알고리즘:\n    - 버킷은 최대 capacity개의 토큰을 담을 수 있음\n    - 시간이 지남에 따라 refill_rate 속도로 토큰이 리필됨\n    - 요청 시 필요한 토큰을 소비, 부족하면 요청 거부\n    - 초기 상태에서 버킷은 가득 참 (capacity개의 토큰)\n    '''\n\n    def __init__(self, capacity: int, refill_rate: float, time_fn: Callable[[], float] | None = None):\n        self.capacity = capacity\n        self.refill_rate = refill_rate\n        self.time_fn = time_fn if time_fn is not None else time.time\n        self.tokens = float(capacity)  # 초기에는 가득 참\n        self.last_refill_time = self.time_fn()\n\n    def _refill(self) -> None:\n        '''시간 경과에 따라 토큰을 리필한다.'''\n        now = self.time_fn()\n        elapsed = now - self.last_refill_time\n        if elapsed > 0:\n            self.tokens = min(self.capacity, self.tokens + elapsed * self.refill_rate)\n            self.last_refill_time = now\n\n    def try_acquire(self, tokens: int = 1) -> bool:\n        '''\n        토큰 획득을 시도한다.\n\n        Parameters:\n        - tokens: 획득하려는 토큰 수 (기본값 1)\n\n        Returns:\n        - True: 토큰 획득 성공 (토큰 차감됨)\n        - False: 토큰 부족으로 획득 실패 (토큰 변화 없음)\n\n        주의: tokens가 capacity보다 크면 항상 False 반환 (예외 아님)\n        '''\n        self._refill()\n        if tokens > self.capacity:\n            return False\n        if self.tokens >= tokens:\n            self.tokens -= tokens\n            return True\n        return False\n\n    def get_available_tokens(self) -> float:\n        '''현재 사용 가능한 토큰 수를 반환한다.'''\n        self._refill()\n        return self.tokens",
  "buggy_implementations": [
    {
      "bug_description": "시간이 역행하는 경우(음수 elapsed)를 처리하지 않아 토큰이 감소할 수 있다.",
      "buggy_code": "from typing import Callable\nimport time\n\n\nclass TokenBucketRateLimiter:\n    '''\n    토큰 버킷 알고리즘 기반 Rate Limiter.\n    '''\n\n    def __init__(self, capacity: int, refill_rate: float, time_fn: Callable[[], float] | None = None):\n        self.capacity = capacity\n        self.refill_rate = refill_rate\n        self.time_fn = time_fn if time_fn is not None else time.time\n        self.tokens = float(capacity)\n        self.last_refill_time = self.time_fn()\n\n    def _refill(self) -> None:\n        now = self.time_fn()\n        elapsed = now - self.last_refill_time\n        # BUG: elapsed가 음수여도 그대로 계산하여 토큰이 감소함\n        self.tokens = min(self.capacity, self.tokens + elapsed * self.refill_rate)\n        self.last_refill_time = now\n\n    def try_acquire(self, tokens: int = 1) -> bool:\n        self._refill()\n        if tokens > self.capacity:\n            return False\n        if self.tokens >= tokens:\n            self.tokens -= tokens\n            return True\n        return False\n\n    def get_available_tokens(self) -> float:\n        self._refill()\n        return self.tokens",
      "weight": 4
    },
    {
      "bug_description": "try_acquire에서 _refill을 호출하지 않아 시간이 지나도 토큰이 리필되지 않는다.",
      "buggy_code": "from typing import Callable\nimport time\n\n\nclass TokenBucketRateLimiter:\n    '''\n    토큰 버킷 알고리즘 기반 Rate Limiter.\n    '''\n\n    def __init__(self, capacity: int, refill_rate: float, time_fn: Callable[[], float] | None = None):\n        self.capacity = capacity\n        self.refill_rate = refill_rate\n        self.time_fn = time_fn if time_fn is not None else time.time\n        self.tokens = float(capacity)\n        self.last_refill_time = self.time_fn()\n\n    def _refill(self) -> None:\n        now = self.time_fn()\n        elapsed = now - self.last_refill_time\n        if elapsed > 0:\n            self.tokens = min(self.capacity, self.tokens + elapsed * self.refill_rate)\n            self.last_refill_time = now\n\n    def try_acquire(self, tokens: int = 1) -> bool:\n        # BUG: _refill() 호출 누락 - 시간이 지나도 토큰이 리필되지 않음\n        if tokens > self.capacity:\n            return False\n        if self.tokens >= tokens:\n            self.tokens -= tokens\n            return True\n        return False\n\n    def get_available_tokens(self) -> float:\n        self._refill()\n        return self.tokens",
      "weight": 5
    },
    {
      "bug_description": "리필 시 capacity 상한을 적용하지 않아 토큰이 무한히 축적될 수 있다.",
      "buggy_code": "from typing import Callable\nimport time\n\n\nclass TokenBucketRateLimiter:\n    '''\n    토큰 버킷 알고리즘 기반 Rate Limiter.\n    '''\n\n    def __init__(self, capacity: int, refill_rate: float, time_fn: Callable[[], float] | None = None):\n        self.capacity = capacity\n        self.refill_rate = refill_rate\n        self.time_fn = time_fn if time_fn is not None else time.time\n        self.tokens = float(capacity)\n        self.last_refill_time = self.time_fn()\n\n    def _refill(self) -> None:\n        now = self.time_fn()\n        elapsed = now - self.last_refill_time\n        if elapsed > 0:\n            # BUG: min(self.capacity, ...) 누락 - capacity 초과 가능\n            self.tokens = self.tokens + elapsed * self.refill_rate\n            self.last_refill_time = now\n\n    def try_acquire(self, tokens: int = 1) -> bool:\n        self._refill()\n        if tokens > self.capacity:\n            return False\n        if self.tokens >= tokens:\n            self.tokens -= tokens\n            return True\n        return False\n\n    def get_available_tokens(self) -> float:\n        self._refill()\n        return self.tokens",
      "weight": 4
    },
    {
      "bug_description": "초기 토큰을 0으로 설정하여 생성 직후 요청이 모두 거부된다.",
      "buggy_code": "from typing import Callable\nimport time\n\n\nclass TokenBucketRateLimiter:\n    '''\n    토큰 버킷 알고리즘 기반 Rate Limiter.\n    '''\n\n    def __init__(self, capacity: int, refill_rate: float, time_fn: Callable[[], float] | None = None):\n        self.capacity = capacity\n        self.refill_rate = refill_rate\n        self.time_fn = time_fn if time_fn is not None else time.time\n        # BUG: 초기 토큰이 0 (capacity로 시작해야 함)\n        self.tokens = 0.0\n        self.last_refill_time = self.time_fn()\n\n    def _refill(self) -> None:\n        now = self.time_fn()\n        elapsed = now - self.last_refill_time\n        if elapsed > 0:\n            self.tokens = min(self.capacity, self.tokens + elapsed * self.refill_rate)\n            self.last_refill_time = now\n\n    def try_acquire(self, tokens: int = 1) -> bool:\n        self._refill()\n        if tokens > self.capacity:\n            return False\n        if self.tokens >= tokens:\n            self.tokens -= tokens\n            return True\n        return False\n\n    def get_available_tokens(self) -> float:\n        self._refill()\n        return self.tokens",
      "weight": 3
    },
    {
      "bug_description": "요청 토큰이 capacity를 초과하면 False 대신 예외를 발생시킨다.",
      "buggy_code": "from typing import Callable\nimport time\n\n\nclass TokenBucketRateLimiter:\n    '''\n    토큰 버킷 알고리즘 기반 Rate Limiter.\n    '''\n\n    def __init__(self, capacity: int, refill_rate: float, time_fn: Callable[[], float] | None = None):\n        self.capacity = capacity\n        self.refill_rate = refill_rate\n        self.time_fn = time_fn if time_fn is not None else time.time\n        self.tokens = float(capacity)\n        self.last_refill_time = self.time_fn()\n\n    def _refill(self) -> None:\n        now = self.time_fn()\n        elapsed = now - self.last_refill_time\n        if elapsed > 0:\n            self.tokens = min(self.capacity, self.tokens + elapsed * self.refill_rate)\n            self.last_refill_time = now\n\n    def try_acquire(self, tokens: int = 1) -> bool:\n        self._refill()\n        # BUG: capacity 초과 시 False 대신 예외 발생\n        if tokens > self.capacity:\n            raise ValueError(f\"Requested tokens ({tokens}) exceeds capacity ({self.capacity})\")\n        if self.tokens >= tokens:\n            self.tokens -= tokens\n            return True\n        return False\n\n    def get_available_tokens(self) -> float:\n        self._refill()\n        return self.tokens",
      "weight": 3
    }
  ],
  "description_md": "## 문제 설명\n\nAPI 서버에서 남용(Abuse)을 방지하거나 과부하를 막기 위해 **Rate Limiting**을 구현합니다. 가장 널리 사용되는 알고리즘 중 하나가 **토큰 버킷(Token Bucket)** 알고리즘입니다.\n\n이 문제에서는 `TokenBucketRateLimiter` 클래스에 대한 테스트를 작성합니다.\n\n### 토큰 버킷 알고리즘\n\n1. **버킷**: 최대 `capacity`개의 토큰을 담을 수 있는 가상의 버킷\n2. **리필**: 시간이 지남에 따라 `refill_rate`(토큰/초) 속도로 토큰이 채워짐\n3. **소비**: 요청마다 필요한 토큰을 버킷에서 소비\n4. **거부**: 토큰이 부족하면 요청 거부\n\n### 클래스 인터페이스\n\n```python\nclass TokenBucketRateLimiter:\n    def __init__(self, capacity: int, refill_rate: float, time_fn: Callable[[], float] | None = None):\n        '''초기화. 버킷은 capacity만큼 가득 찬 상태로 시작.'''\n\n    def try_acquire(self, tokens: int = 1) -> bool:\n        '''토큰 획득 시도. 성공 시 True, 실패 시 False.'''\n\n    def get_available_tokens(self) -> float:\n        '''현재 사용 가능한 토큰 수 반환.'''\n```\n\n### 주요 동작 규칙\n\n- 초기 생성 시 버킷은 `capacity`개의 토큰으로 가득 참\n- 리필 시 토큰은 `capacity`를 초과할 수 없음\n- 요청 토큰이 `capacity`보다 크면 항상 `False` 반환 (예외 아님)\n- `time_fn`을 주입하여 테스트 시 시간을 제어할 수 있음\n\n### 예시\n\n```python\n# capacity=10, refill_rate=2.0 (초당 2토큰 리필)\nlimiter = TokenBucketRateLimiter(capacity=10, refill_rate=2.0)\n\n# 초기 상태: 10개 토큰\nassert limiter.try_acquire(5) == True   # 5개 소비 → 남은 5개\nassert limiter.try_acquire(5) == True   # 5개 소비 → 남은 0개\nassert limiter.try_acquire(1) == False  # 토큰 부족\n\n# 2초 경과 후 (4개 리필)\n# → 4개 토큰 보유\nassert limiter.try_acquire(4) == True\nassert limiter.try_acquire(1) == False\n```\n\n### 테스트 작성 시 고려사항\n\n1. **시간 모킹**: `time_fn`을 주입하여 시간 경과를 시뮬레이션하세요.\n2. **초기 상태**: 생성 직후 버킷이 가득 차 있는지 확인하세요.\n3. **리필 로직**: 시간 경과에 따라 정확한 양이 리필되는지 검증하세요.\n4. **상한 검증**: 리필 시 capacity를 초과하지 않는지 확인하세요.\n5. **버스트 요청**: 연속된 요청이 정확하게 처리되는지 테스트하세요.\n6. **경계값**: `tokens > capacity` 요청, 정확히 남은 토큰만큼 요청 등.\n\n### 여러분의 과제\n\n`TokenBucketRateLimiter` 클래스의 여러 구현이 준비되어 있으며, 일부에는 의도적인 버그가 있습니다.\n\npytest를 사용해 테스트 케이스를 작성하여:\n\n- 올바른 구현은 모든 테스트를 통과하고,\n- 버그가 있는 구현들은 하나 이상 테스트에서 실패하도록\n\n테스트 스위트를 설계해 보세요. 이 문제는 상태 관리, 시간 의존적 로직, 경계값 테스트 능력을 평가합니다.\n",
  "initial_test_template": "import pytest\nfrom target import TokenBucketRateLimiter\n\n\n# 초기 상태 테스트\n\ndef test_initial_tokens_full():\n    # TODO: 생성 직후 토큰이 capacity만큼 있는지 확인\n    pass\n\n\ndef test_acquire_immediately_after_creation():\n    # TODO: 생성 직후 capacity만큼 토큰을 소비할 수 있는지 확인\n    pass\n\n\n# 토큰 소비 테스트\n\ndef test_acquire_reduces_tokens():\n    # TODO: try_acquire 후 토큰이 정확히 감소하는지 확인\n    pass\n\n\ndef test_acquire_fails_when_insufficient():\n    # TODO: 토큰이 부족할 때 False 반환 및 토큰 변화 없음 확인\n    pass\n\n\n# 리필 로직 테스트\n\ndef test_refill_over_time():\n    # TODO: time_fn을 모킹하여 시간 경과 후 리필 검증\n    pass\n\n\ndef test_refill_capped_at_capacity():\n    # TODO: 리필 시 capacity를 초과하지 않는지 확인\n    pass\n\n\n# 경계값 테스트\n\ndef test_request_exceeds_capacity():\n    # TODO: tokens > capacity 요청 시 False 반환 (예외 아님)\n    pass\n\n\ndef test_exact_token_consumption():\n    # TODO: 정확히 남은 토큰만큼 요청 시 성공 후 0개 남음\n    pass\n",
  "tags": [
    "hard",
    "python",
    "pytest",
    "unit-test",
    "rate-limiter",
    "token-bucket",
    "state-management",
    "time-mock",
    "boundary-value"
  ],
  "difficulty": "Hard"
}
