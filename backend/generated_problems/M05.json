{
  "title": "예약 날짜 범위 검증 함수 테스트",
  "function_signature": "def is_reservation_allowed(start_date: str, end_date: str, today: str | None = None) -> bool:",
  "golden_code": "from __future__ import annotations\nfrom datetime import datetime, date, timedelta\n\n\ndef is_reservation_allowed(start_date: str, end_date: str, today: str | None = None) -> bool:\n    \"\"\"Validate whether a reservation date range is allowed.\n\n    Business rules:\n    - Dates are given as ISO strings \"YYYY-MM-DD\".\n    - `start_date` and `end_date` are inclusive.\n    - If `today` is None, the current local date (date.today()) is used.\n    - Reservations cannot start in the past relative to `today`.\n      * start_date < today  -> not allowed\n      * start_date == today -> allowed\n    - Reservations cannot end before they start (end_date < start_date -> not allowed).\n    - Reservations too far in the future are not allowed.\n      * The last day of the reservation (end_date) must be\n        within 365 days (inclusive) from `today`.\n    - Returns True if all conditions are satisfied, otherwise False.\n\n    Raises:\n        ValueError: If any of the date strings are not valid ISO dates.\n    \"\"\"\n\n    def parse_iso(d: str) -> date:\n        try:\n            return datetime.strptime(d, \"%Y-%m-%d\").date()\n        except ValueError as exc:\n            # Normalize error type so callers/tests have predictable behavior\n            raise ValueError(f\"Invalid date format: {d!r}. Expected 'YYYY-MM-DD'.\") from exc\n\n    start = parse_iso(start_date)\n    end = parse_iso(end_date)\n\n    if today is None:\n        today_date = date.today()\n    else:\n        today_date = parse_iso(today)\n\n    # 1) Start date cannot be in the past\n    if start < today_date:\n        return False\n\n    # 2) End date cannot be before start date\n    if end < start:\n        return False\n\n    # 3) End date must not be more than 365 days in the future from today\n    max_allowed_end = today_date + timedelta(days=365)\n    if end > max_allowed_end:\n        return False\n\n    return True\n",
  "buggy_implementations": [
    {
      "bug_description": "경계값 오류: 오늘보다 정확히 365일 후에 끝나는 예약을 허용하지 않고 False를 반환함 (end_date == today+365 를 잘못 처리).",
      "buggy_code": "from __future__ import annotations\nfrom datetime import datetime, date, timedelta\n\n\ndef is_reservation_allowed(start_date: str, end_date: str, today: str | None = None) -> bool:\n    \"\"\"BUGGY: Treats an end date exactly 365 days after today as invalid.\n\n    Same spec as golden implementation, but introduces an off-by-one error\n    on the upper boundary of the allowed future range.\n    \"\"\"\n\n    def parse_iso(d: str) -> date:\n        try:\n            return datetime.strptime(d, \"%Y-%m-%d\").date()\n        except ValueError as exc:\n            raise ValueError(f\"Invalid date format: {d!r}. Expected 'YYYY-MM-DD'.\") from exc\n\n    start = parse_iso(start_date)\n    end = parse_iso(end_date)\n\n    if today is None:\n        today_date = date.today()\n    else:\n        today_date = parse_iso(today)\n\n    if start < today_date:\n        return False\n\n    if end < start:\n        return False\n\n    # BUG: uses \">=\" instead of \">\" so exactly 365 days is rejected\n    max_allowed_end = today_date + timedelta(days=365)\n    if end >= max_allowed_end:\n        return False\n\n    return True\n",
      "weight": 4
    },
    {
      "bug_description": "비즈니스 로직 누락: 시작일이 과거여도 종료일이 미래라면 허용함. start_date < today 인 케이스를 제대로 차단하지 못함.",
      "buggy_code": "from __future__ import annotations\nfrom datetime import datetime, date, timedelta\n\n\ndef is_reservation_allowed(start_date: str, end_date: str, today: str | None = None) -> bool:\n    \"\"\"BUGGY: Only checks that the *end* date is not in the past.\n\n    Allows ranges where the start_date is already in the past\n    as long as end_date is on or after today.\n    \"\"\"\n\n    def parse_iso(d: str) -> date:\n        try:\n            return datetime.strptime(d, \"%Y-%m-%d\").date()\n        except ValueError as exc:\n            raise ValueError(f\"Invalid date format: {d!r}. Expected 'YYYY-MM-DD'.\") from exc\n\n    start = parse_iso(start_date)\n    end = parse_iso(end_date)\n\n    if today is None:\n        today_date = date.today()\n    else:\n        today_date = parse_iso(today)\n\n    # BUG: only end date checked against past, start date may be before today\n    if end < today_date:\n        return False\n\n    if end < start:\n        return False\n\n    max_allowed_end = today_date + timedelta(days=365)\n    if end > max_allowed_end:\n        return False\n\n    return True\n",
      "weight": 5
    },
    {
      "bug_description": "형식 검증 오류: 잘못된 날짜 형식이나 존재하지 않는 날짜에서 ValueError 대신 None을 반환하여 조용히 실패함.",
      "buggy_code": "from __future__ import annotations\nfrom datetime import datetime, date, timedelta\n\n\ndef is_reservation_allowed(start_date: str, end_date: str, today: str | None = None) -> bool:\n    \"\"\"BUGGY: Swallows parsing errors and returns False instead of raising.\n\n    Violates the contract that invalid date strings should raise ValueError.\n    \"\"\"\n\n    def parse_iso(d: str) -> date | None:\n        try:\n            return datetime.strptime(d, \"%Y-%m-%d\").date()\n        except ValueError:\n            # BUG: Return None instead of raising\n            return None\n\n    start = parse_iso(start_date)\n    end = parse_iso(end_date)\n\n    if today is None:\n        today_date = date.today()\n    else:\n        today_date = parse_iso(today)\n\n    # BUG: If any parse failed, just return False instead of raising\n    if start is None or end is None or today_date is None:\n        return False\n\n    if start < today_date:\n        return False\n\n    if end < start:\n        return False\n\n    max_allowed_end = today_date + timedelta(days=365)\n    if end > max_allowed_end:\n        return False\n\n    return True\n",
      "weight": 3
    },
    {
      "bug_description": "복합 조건 실수: 종료일이 시작일보다 빠른 경우를 허용함. end_date == start_date 는 허용해야 하지만, end_date < start_date 도 통과시킴.",
      "buggy_code": "from __future__ import annotations\nfrom datetime import datetime, date, timedelta\n\n\ndef is_reservation_allowed(start_date: str, end_date: str, today: str | None = None) -> bool:\n    \"\"\"BUGGY: Does not correctly reject end_date earlier than start_date.\n\n    Uses a non-strict check and thus never rejects when end < start.\n    \"\"\"\n\n    def parse_iso(d: str) -> date:\n        try:\n            return datetime.strptime(d, \"%Y-%m-%d\").date()\n        except ValueError as exc:\n            raise ValueError(f\"Invalid date format: {d!r}. Expected 'YYYY-MM-DD'.\") from exc\n\n    start = parse_iso(start_date)\n    end = parse_iso(end_date)\n\n    if today is None:\n        today_date = date.today()\n    else:\n        today_date = parse_iso(today)\n\n    if start < today_date:\n        return False\n\n    # BUG: condition is reversed; only rejects when end > start (which is valid)\n    if end > start:\n        # Intentionally wrong: should be checking end < start\n        pass\n\n    max_allowed_end = today_date + timedelta(days=365)\n    if end > max_allowed_end:\n        return False\n\n    return True\n",
      "weight": 4
    }
  ],
  "description_md": "## 문제 설명\n\n한 호텔 예약 시스템에서, 사용자가 입력한 체크인 날짜와 체크아웃 날짜가 유효한지 검사하는 핵심 함수가 있습니다. 이 함수는 **과거 날짜 예약 방지**, **너무 먼 미래 예약 제한**, **시작일/종료일 관계 검증** 등 여러 비즈니스 규칙을 한 번에 처리합니다. 실제 서비스 품질에 직접적인 영향을 주는 부분이기 때문에, 다양한 날짜 케이스에 대해 신뢰할 수 있는 자동화 테스트가 매우 중요합니다.\n\n### 대상 함수\n\n```python\nis_reservation_allowed(start_date: str, end_date: str, today: str | None = None) -> bool\n```\n\n- `start_date`: 체크인 날짜, 문자열 형식 \"YYYY-MM-DD\"\n- `end_date`: 체크아웃(마지막 이용일) 날짜, 문자열 형식 \"YYYY-MM-DD\"\n- `today`: 기준이 되는 오늘 날짜, 문자열 형식 \"YYYY-MM-DD\" 또는 `None`\n  - 테스트 재현성을 위해, 일반적으로 테스트에서는 명시적으로 값을 넣어 사용하는 것을 권장합니다.\n  - `None` 인 경우 `date.today()`를 사용합니다.\n\n### 비즈니스 규칙 요약\n\n1. 날짜 형식은 ISO 형식 \"YYYY-MM-DD\" 여야 하며, 잘못된 형식이나 존재하지 않는 날짜(예: `2023-02-30`)는 `ValueError`를 발생시켜야 합니다.\n2. `start_date`와 `end_date`는 **포함 범위**입니다. (양 끝 날짜 모두 예약에 포함됨)\n3. `start_date`는 `today`보다 과거일 수 없습니다.\n   - `start_date < today` → 예약 불가 (`False`)\n   - `start_date == today` → 허용 가능 (조건 만족 시 `True`)\n4. `end_date`는 `start_date`보다 빠를 수 없습니다.\n   - `end_date < start_date` → 예약 불가\n   - `end_date == start_date` → 1일짜리 예약으로 허용 가능 (다른 조건이 모두 만족한다면)\n5. 너무 먼 미래의 예약은 제한합니다.\n   - `end_date`는 `today`로부터 **365일 이내(포함)** 여야 합니다.\n\n위 모든 조건을 만족하면 `True`, 그렇지 않으면 `False`를 반환해야 합니다.\n\n### 정상 동작 예시\n\n가독성을 위해, 아래 예시에서는 `today = \"2024-01-01\"` 이라고 가정합니다.\n\n- 예시 1: 오늘 시작, 3일 예약\n  - 입력: `start_date=\"2024-01-01\"`, `end_date=\"2024-01-03\"`, `today=\"2024-01-01\"`\n  - 결과: `True`\n\n- 예시 2: 과거 시작일\n  - 입력: `start_date=\"2023-12-31\"`, `end_date=\"2024-01-02\"`, `today=\"2024-01-01\"`\n  - 결과: `False` (시작일이 과거이기 때문)\n\n### 테스트에서 고민해야 할 포인트\n\n이 문제는 특히 다음과 같은 스킬을 평가하기 위해 설계되었습니다.\n\n- **Date validation (날짜 검증)**\n  - 유효/무효 날짜 형식, 존재하지 않는 날짜, 경계 날짜(`2024-02-29` 등) 처리\n  - 잘못된 형식에서 예외가 제대로 발생하는지\n- **Business logic (비즈니스 로직 검증)**\n  - 과거/미래 날짜 조합, 오늘 날짜 포함 여부, 1일 예약, 며칠짜리 예약 등 다양한 시나리오\n  - 과거 시작 + 미래 종료, 먼 미래 종료일 등 현실적인 예약 케이스\n- **Complex conditions (복합 조건 테스트)**\n  - 여러 조건이 동시에 얽힌 케이스: 시작일/종료일/오늘이 서로 다른 위치에 있을 때\n  - `365일` 제한과 오늘/시작일/종료일 관계가 섞인 복잡한 경계값\n\n다음과 같은 테스트 아이디어를 고려해 보세요.\n\n- `start_date`와 `end_date`가 모두 오늘인 경우, 오늘과 내일인 경우 등 최소 단위 예약\n- `start_date`가 오늘보다 **하루 전**인 경우, 정확히 오늘인 경우, 하루 후인 경우\n- `end_date`가 `today + 365일` 인 경우와 `today + 366일` 인 경우 비교\n- `end_date`가 `start_date`보다 하루 빠른 경우, 같은 경우, 여러 날 뒤인 경우\n- 완전히 잘못된 형식 (`\"2024/01/01\"`, `\"2024-13-01\"`, `\"abc\"`) 에서 예외 발생 여부\n\n### 당신의 할 일\n\n- 제공되는 `is_reservation_allowed` 함수는 여러 **버그가 포함된 구현들** 중 하나와 연결되어 테스트됩니다.\n- 당신은 **pytest 기반 테스트 코드**를 작성하여, 이 버그 구현들을 최대한 많이 탐지해야 합니다.\n- 테스트는 다음을 만족하는 것이 좋습니다.\n  - 명확한 **경계값 테스트** (오늘, 오늘±1일, today+365, today+366 등)\n  - 잘못된 날짜 형식/존재하지 않는 날짜에 대한 **예외 검증**\n  - 다양한 비즈니스 시나리오(과거 시작, 미래 종료, 짧은 예약/긴 예약 등)에 대한 **조합 테스트**\n  - 조건이 하나만 실패할 때, 여러 조건이 동시에 섞여 있을 때 모두 검증\n\n목표는 단순히 몇 개의 예시만 통과하는 것이 아니라, **다양한 날짜 조합과 복합 조건을 체계적으로 테스트**하여 숨겨진 버그 구현들을 찾아내는 것입니다.\n",
  "initial_test_template": "import pytest\nfrom target import is_reservation_allowed\n\n# 힌트: 가능한 한 today를 명시적으로 지정하여 재현 가능한 테스트를 작성하세요.\n# 예: today = \"2024-01-01\"\n\n\ndef test_valid_same_day_reservation():\n    \"\"\"TODO: today와 같은 날짜에 시작해서 같은 날짜에 끝나는 1일 예약이 허용되는지 확인하세요.\"\"\"\n    # 예: start == end == today 인 케이스\n    # assert is_reservation_allowed(...)\n    pass\n\n\ndef test_past_start_date_rejected():\n    \"\"\"TODO: start_date가 today보다 하루 혹은 며칠 이전인 경우 예약이 거부되는지 테스트하세요.\"\"\"\n    # date validation + business logic 조합\n    pass\n\n\ndef test_far_future_end_date_boundary():\n    \"\"\"TODO: end_date가 today + 365일일 때와 today + 366일일 때의 동작을 비교하는 경계값 테스트를 작성하세요.\"\"\"\n    # complex conditions: today, start, end 세 날짜가 모두 맞물리는 케이스 포함\n    pass\n\n\ndef test_invalid_date_format_raises_value_error():\n    \"\"\"TODO: 잘못된 날짜 형식이나 존재하지 않는 날짜에서 ValueError가 발생하는지 테스트하세요.\"\"\"\n    # 예: \"2024/01/01\", \"2024-13-01\", \"2024-02-30\" 등\n    pass\n",
  "tags": [
    "medium",
    "qa",
    "testing",
    "unit-test",
    "date validation",
    "business logic",
    "complex conditions",
    "datetime",
    "boundary"
  ],
  "difficulty": "Medium"
}