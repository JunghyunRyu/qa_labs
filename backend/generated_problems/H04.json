{
  "title": "계층형 예외 처리 주문 처리 함수 테스트",
  "function_signature": "def process_order(request: dict, user_db: dict, inventory_db: dict) -> dict:",
  "golden_code": "from typing import Any, Dict\n\n\nclass ValidationError(ValueError):\n    \"\"\"Raised when the incoming request payload fails validation.\n\n    - Includes a short, stable message intended for clients.\n    - Does not expose internal details or stack traces.\n    \"\"\"\n\n\nclass NotFoundError(LookupError):\n    \"\"\"Raised when a required entity (user or item) cannot be found.\"\"\"\n\n\nclass BusinessRuleError(RuntimeError):\n    \"\"\"Raised when business rules (e.g. insufficient balance/stock) are violated.\"\"\"\n\n\ndef process_order(request: dict, user_db: dict, inventory_db: dict) -> dict:\n    \"\"\"Process a purchase order with layered validation and error handling.\n\n    The order processing pipeline has four conceptual layers:\n\n    1. Input validation (user input):\n       - `request` must be a dict with keys: \"user_id\", \"item_id\", \"quantity\", \"currency\".\n       - `user_id` and `item_id` must be non-empty strings.\n       - `quantity` must be an int > 0.\n       - `currency` must be one of {\"USD\", \"EUR\", \"KRW\"}.\n       - On any violation, raise ValidationError with a short message.\n\n    2. Data lookup (database-ish):\n       - `user_db` and `inventory_db` are simple dicts used as in-memory stores.\n       - Look up user by `user_id` and item by `item_id`.\n       - If either is missing, raise NotFoundError with message\n         \"user not found\" or \"item not found\".\n\n    3. Business rules:\n       - User must be `active` (truthy field on user record); otherwise raise\n         BusinessRuleError(\"user is not active\").\n       - `quantity` cannot exceed item's `stock` (int >= 0); otherwise raise\n         BusinessRuleError(\"insufficient stock\").\n       - Total price is `item[\"price\"] * quantity`.\n       - User must have `balance` >= total price; otherwise raise\n         BusinessRuleError(\"insufficient balance\").\n\n    4. Result:\n       - This function is pure: it MUST NOT mutate `user_db` or `inventory_db`.\n       - It returns a summary dict with keys:\n         {\n           \"user_id\": str,\n           \"item_id\": str,\n           \"quantity\": int,\n           \"currency\": str,\n           \"total_price\": float,\n           \"status\": \"approved\"\n         }\n\n    All non-programmer errors should be normalized to these custom exceptions:\n    - ValidationError for bad input.\n    - NotFoundError for missing user/item.\n    - BusinessRuleError for all business rule violations.\n\n    Any unexpected internal issue (e.g. missing fields in user_db records) should\n    *propagate* as the original Python exception (KeyError, TypeError, etc.) and\n    MUST NOT be converted into the custom exceptions. This is important so that\n    tests can distinguish validation/business issues from true internal bugs.\n    \"\"\"\n\n    # 1. Input validation\n    if not isinstance(request, dict):\n        raise ValidationError(\"request must be a dict\")\n\n    required_keys = {\"user_id\", \"item_id\", \"quantity\", \"currency\"}\n    missing = required_keys - set(request.keys())\n    if missing:\n        # Don't leak which key specifically; just signal invalid payload.\n        raise ValidationError(\"missing required fields\")\n\n    user_id = request.get(\"user_id\")\n    item_id = request.get(\"item_id\")\n    quantity = request.get(\"quantity\")\n    currency = request.get(\"currency\")\n\n    if not isinstance(user_id, str) or not user_id.strip():\n        raise ValidationError(\"invalid user_id\")\n    if not isinstance(item_id, str) or not item_id.strip():\n        raise ValidationError(\"invalid item_id\")\n\n    if not isinstance(quantity, int):\n        raise ValidationError(\"quantity must be an int\")\n    if quantity <= 0:\n        raise ValidationError(\"quantity must be positive\")\n\n    allowed_currencies = {\"USD\", \"EUR\", \"KRW\"}\n    if currency not in allowed_currencies:\n        raise ValidationError(\"unsupported currency\")\n\n    # 2. Data lookup\n    if user_id not in user_db:\n        raise NotFoundError(\"user not found\")\n    if item_id not in inventory_db:\n        raise NotFoundError(\"item not found\")\n\n    user = user_db[user_id]\n    item = inventory_db[item_id]\n\n    # 3. Business rules\n    # We intentionally rely on KeyError/TypeError to propagate for bad schemas.\n    if not user.get(\"active\", False):\n        raise BusinessRuleError(\"user is not active\")\n\n    stock = item[\"stock\"]\n    price = item[\"price\"]\n\n    if not isinstance(stock, int) or stock < 0:\n        # This indicates a data integrity/internal issue; let it propagate.\n        raise ValueError(\"invalid stock value\")\n    if not isinstance(price, (int, float)) or price < 0:\n        raise ValueError(\"invalid price value\")\n\n    if quantity > stock:\n        raise BusinessRuleError(\"insufficient stock\")\n\n    total_price = float(price) * quantity\n\n    balance = user[\"balance\"]\n    if not isinstance(balance, (int, float)):\n        raise ValueError(\"invalid balance value\")\n\n    if balance < total_price:\n        raise BusinessRuleError(\"insufficient balance\")\n\n    # 4. Build result without mutating inputs\n    result: Dict[str, Any] = {\n        \"user_id\": user_id,\n        \"item_id\": item_id,\n        \"quantity\": quantity,\n        \"currency\": currency,\n        \"total_price\": total_price,\n        \"status\": \"approved\",\n    }\n    return result\n",
  "buggy_implementations": [
    {
      "bug_description": "입력 검증 단계에서 quantity==0을 허용하고, 음수일 때만 ValidationError를 발생시켜 경계값 테스트에서 실패한다.",
      "buggy_code": "from typing import Any, Dict\n\n\nclass ValidationError(ValueError):\n    pass\n\n\nclass NotFoundError(LookupError):\n    pass\n\n\nclass BusinessRuleError(RuntimeError):\n    pass\n\n\ndef process_order(request: dict, user_db: dict, inventory_db: dict) -> dict:\n    if not isinstance(request, dict):\n        raise ValidationError(\"request must be a dict\")\n\n    required_keys = {\"user_id\", \"item_id\", \"quantity\", \"currency\"}\n    missing = required_keys - set(request.keys())\n    if missing:\n        raise ValidationError(\"missing required fields\")\n\n    user_id = request.get(\"user_id\")\n    item_id = request.get(\"item_id\")\n    quantity = request.get(\"quantity\")\n    currency = request.get(\"currency\")\n\n    if not isinstance(user_id, str) or not user_id.strip():\n        raise ValidationError(\"invalid user_id\")\n    if not isinstance(item_id, str) or not item_id.strip():\n        raise ValidationError(\"invalid item_id\")\n\n    if not isinstance(quantity, int):\n        raise ValidationError(\"quantity must be an int\")\n    # BUG: quantity == 0 을 허용함 (양수만 허용해야 함)\n    if quantity < 0:\n        raise ValidationError(\"quantity must be positive\")\n\n    allowed_currencies = {\"USD\", \"EUR\", \"KRW\"}\n    if currency not in allowed_currencies:\n        raise ValidationError(\"unsupported currency\")\n\n    if user_id not in user_db:\n        raise NotFoundError(\"user not found\")\n    if item_id not in inventory_db:\n        raise NotFoundError(\"item not found\")\n\n    user = user_db[user_id]\n    item = inventory_db[item_id]\n\n    if not user.get(\"active\", False):\n        raise BusinessRuleError(\"user is not active\")\n\n    stock = item[\"stock\"]\n    price = item[\"price\"]\n\n    if not isinstance(stock, int) or stock < 0:\n        raise ValueError(\"invalid stock value\")\n    if not isinstance(price, (int, float)) or price < 0:\n        raise ValueError(\"invalid price value\")\n\n    # quantity == 0 인 경우 비즈니스 규칙 위반이어야 하지만, 통과해버림\n    if quantity > stock:\n        raise BusinessRuleError(\"insufficient stock\")\n\n    total_price = float(price) * quantity\n\n    balance = user[\"balance\"]\n    if not isinstance(balance, (int, float)):\n        raise ValueError(\"invalid balance value\")\n\n    if balance < total_price:\n        raise BusinessRuleError(\"insufficient balance\")\n\n    return {\n        \"user_id\": user_id,\n        \"item_id\": item_id,\n        \"quantity\": quantity,\n        \"currency\": currency,\n        \"total_price\": total_price,\n        \"status\": \"approved\",\n    }\n",
      "weight": 3
    },
    {
      "bug_description": "데이터 조회 단계에서 존재하지 않는 user_id/item_id에 대해 NotFoundError 대신 ValidationError를 던져 계층형 예외 구분 테스트에서 실패한다.",
      "buggy_code": "from typing import Any, Dict\n\n\nclass ValidationError(ValueError):\n    pass\n\n\nclass NotFoundError(LookupError):\n    pass\n\n\nclass BusinessRuleError(RuntimeError):\n    pass\n\n\ndef process_order(request: dict, user_db: dict, inventory_db: dict) -> dict:\n    if not isinstance(request, dict):\n        raise ValidationError(\"request must be a dict\")\n\n    required_keys = {\"user_id\", \"item_id\", \"quantity\", \"currency\"}\n    missing = required_keys - set(request.keys())\n    if missing:\n        raise ValidationError(\"missing required fields\")\n\n    user_id = request.get(\"user_id\")\n    item_id = request.get(\"item_id\")\n    quantity = request.get(\"quantity\")\n    currency = request.get(\"currency\")\n\n    if not isinstance(user_id, str) or not user_id.strip():\n        raise ValidationError(\"invalid user_id\")\n    if not isinstance(item_id, str) or not item_id.strip():\n        raise ValidationError(\"invalid item_id\")\n\n    if not isinstance(quantity, int):\n        raise ValidationError(\"quantity must be an int\")\n    if quantity <= 0:\n        raise ValidationError(\"quantity must be positive\")\n\n    allowed_currencies = {\"USD\", \"EUR\", \"KRW\"}\n    if currency not in allowed_currencies:\n        raise ValidationError(\"unsupported currency\")\n\n    # BUG: 존재하지 않는 경우 ValidationError 로 매핑 (계층 잘못)\n    if user_id not in user_db:\n        raise ValidationError(\"user not found\")\n    if item_id not in inventory_db:\n        raise ValidationError(\"item not found\")\n\n    user = user_db[user_id]\n    item = inventory_db[item_id]\n\n    if not user.get(\"active\", False):\n        raise BusinessRuleError(\"user is not active\")\n\n    stock = item[\"stock\"]\n    price = item[\"price\"]\n\n    if not isinstance(stock, int) or stock < 0:\n        raise ValueError(\"invalid stock value\")\n    if not isinstance(price, (int, float)) or price < 0:\n        raise ValueError(\"invalid price value\")\n\n    if quantity > stock:\n        raise BusinessRuleError(\"insufficient stock\")\n\n    total_price = float(price) * quantity\n\n    balance = user[\"balance\"]\n    if not isinstance(balance, (int, float)):\n        raise ValueError(\"invalid balance value\")\n\n    if balance < total_price:\n        raise BusinessRuleError(\"insufficient balance\")\n\n    return {\n        \"user_id\": user_id,\n        \"item_id\": item_id,\n        \"quantity\": quantity,\n        \"currency\": currency,\n        \"total_price\": total_price,\n        \"status\": \"approved\",\n    }\n",
      "weight": 4
    },
    {
      "bug_description": "비즈니스 규칙 위반 중 재고 부족과 잔액 부족을 NotFoundError로 잘못 매핑하여 예외 체인 구분이 무너진다.",
      "buggy_code": "from typing import Any, Dict\n\n\nclass ValidationError(ValueError):\n    pass\n\n\nclass NotFoundError(LookupError):\n    pass\n\n\nclass BusinessRuleError(RuntimeError):\n    pass\n\n\ndef process_order(request: dict, user_db: dict, inventory_db: dict) -> dict:\n    if not isinstance(request, dict):\n        raise ValidationError(\"request must be a dict\")\n\n    required_keys = {\"user_id\", \"item_id\", \"quantity\", \"currency\"}\n    missing = required_keys - set(request.keys())\n    if missing:\n        raise ValidationError(\"missing required fields\")\n\n    user_id = request.get(\"user_id\")\n    item_id = request.get(\"item_id\")\n    quantity = request.get(\"quantity\")\n    currency = request.get(\"currency\")\n\n    if not isinstance(user_id, str) or not user_id.strip():\n        raise ValidationError(\"invalid user_id\")\n    if not isinstance(item_id, str) or not item_id.strip():\n        raise ValidationError(\"invalid item_id\")\n\n    if not isinstance(quantity, int):\n        raise ValidationError(\"quantity must be an int\")\n    if quantity <= 0:\n        raise ValidationError(\"quantity must be positive\")\n\n    allowed_currencies = {\"USD\", \"EUR\", \"KRW\"}\n    if currency not in allowed_currencies:\n        raise ValidationError(\"unsupported currency\")\n\n    if user_id not in user_db:\n        raise NotFoundError(\"user not found\")\n    if item_id not in inventory_db:\n        raise NotFoundError(\"item not found\")\n\n    user = user_db[user_id]\n    item = inventory_db[item_id]\n\n    if not user.get(\"active\", False):\n        raise BusinessRuleError(\"user is not active\")\n\n    stock = item[\"stock\"]\n    price = item[\"price\"]\n\n    if not isinstance(stock, int) or stock < 0:\n        raise ValueError(\"invalid stock value\")\n    if not isinstance(price, (int, float)) or price < 0:\n        raise ValueError(\"invalid price value\")\n\n    # BUG: 재고 부족 시 BusinessRuleError 대신 NotFoundError 사용\n    if quantity > stock:\n        raise NotFoundError(\"insufficient stock\")\n\n    total_price = float(price) * quantity\n\n    balance = user[\"balance\"]\n    if not isinstance(balance, (int, float)):\n        raise ValueError(\"invalid balance value\")\n\n    # BUG: 잔액 부족도 NotFoundError 로 잘못 매핑\n    if balance < total_price:\n        raise NotFoundError(\"insufficient balance\")\n\n    return {\n        \"user_id\": user_id,\n        \"item_id\": item_id,\n        \"quantity\": quantity,\n        \"currency\": currency,\n        \"total_price\": total_price,\n        \"status\": \"approved\",\n    }\n",
      "weight": 5
    },
    {
      "bug_description": "내부 데이터 이상(예: user['balance'] 타입 불일치)을 ValidationError로 삼켜버려, 원래 의도한 내부 예외 전파가 이루어지지 않는다.",
      "buggy_code": "from typing import Any, Dict\n\n\nclass ValidationError(ValueError):\n    pass\n\n\nclass NotFoundError(LookupError):\n    pass\n\n\nclass BusinessRuleError(RuntimeError):\n    pass\n\n\ndef process_order(request: dict, user_db: dict, inventory_db: dict) -> dict:\n    if not isinstance(request, dict):\n        raise ValidationError(\"request must be a dict\")\n\n    required_keys = {\"user_id\", \"item_id\", \"quantity\", \"currency\"}\n    missing = required_keys - set(request.keys())\n    if missing:\n        raise ValidationError(\"missing required fields\")\n\n    user_id = request.get(\"user_id\")\n    item_id = request.get(\"item_id\")\n    quantity = request.get(\"quantity\")\n    currency = request.get(\"currency\")\n\n    if not isinstance(user_id, str) or not user_id.strip():\n        raise ValidationError(\"invalid user_id\")\n    if not isinstance(item_id, str) or not item_id.strip():\n        raise ValidationError(\"invalid item_id\")\n\n    if not isinstance(quantity, int):\n        raise ValidationError(\"quantity must be an int\")\n    if quantity <= 0:\n        raise ValidationError(\"quantity must be positive\")\n\n    allowed_currencies = {\"USD\", \"EUR\", \"KRW\"}\n    if currency not in allowed_currencies:\n        raise ValidationError(\"unsupported currency\")\n\n    if user_id not in user_db:\n        raise NotFoundError(\"user not found\")\n    if item_id not in inventory_db:\n        raise NotFoundError(\"item not found\")\n\n    user = user_db[user_id]\n    item = inventory_db[item_id]\n\n    if not user.get(\"active\", False):\n        raise BusinessRuleError(\"user is not active\")\n\n    stock = item[\"stock\"]\n    price = item[\"price\"]\n\n    # BUG: 내부 데이터 이상을 ValidationError 로 변환하여 외부 입력 문제처럼 보이게 함\n    try:\n        if not isinstance(stock, int) or stock < 0:\n            raise ValueError(\"invalid stock value\")\n        if not isinstance(price, (int, float)) or price < 0:\n            raise ValueError(\"invalid price value\")\n    except ValueError as e:\n        raise ValidationError(str(e))\n\n    if quantity > stock:\n        raise BusinessRuleError(\"insufficient stock\")\n\n    total_price = float(price) * quantity\n\n    balance = user.get(\"balance\")\n    try:\n        if not isinstance(balance, (int, float)):\n            raise ValueError(\"invalid balance value\")\n    except ValueError as e:\n        raise ValidationError(str(e))\n\n    if balance < total_price:\n        raise BusinessRuleError(\"insufficient balance\")\n\n    return {\n        \"user_id\": user_id,\n        \"item_id\": item_id,\n        \"quantity\": quantity,\n        \"currency\": currency,\n        \"total_price\": total_price,\n        \"status\": \"approved\",\n    }\n",
      "weight": 4
    },
    {
      "bug_description": "성공 경로에서 inventory_db의 stock을 감소시키는 부수효과가 있어, 다중 호출/상태 의존 테스트에서 실패한다.",
      "buggy_code": "from typing import Any, Dict\n\n\nclass ValidationError(ValueError):\n    pass\n\n\nclass NotFoundError(LookupError):\n    pass\n\n\nclass BusinessRuleError(RuntimeError):\n    pass\n\n\ndef process_order(request: dict, user_db: dict, inventory_db: dict) -> dict:\n    if not isinstance(request, dict):\n        raise ValidationError(\"request must be a dict\")\n\n    required_keys = {\"user_id\", \"item_id\", \"quantity\", \"currency\"}\n    missing = required_keys - set(request.keys())\n    if missing:\n        raise ValidationError(\"missing required fields\")\n\n    user_id = request.get(\"user_id\")\n    item_id = request.get(\"item_id\")\n    quantity = request.get(\"quantity\")\n    currency = request.get(\"currency\")\n\n    if not isinstance(user_id, str) or not user_id.strip():\n        raise ValidationError(\"invalid user_id\")\n    if not isinstance(item_id, str) or not item_id.strip():\n        raise ValidationError(\"invalid item_id\")\n\n    if not isinstance(quantity, int):\n        raise ValidationError(\"quantity must be an int\")\n    if quantity <= 0:\n        raise ValidationError(\"quantity must be positive\")\n\n    allowed_currencies = {\"USD\", \"EUR\", \"KRW\"}\n    if currency not in allowed_currencies:\n        raise ValidationError(\"unsupported currency\")\n\n    if user_id not in user_db:\n        raise NotFoundError(\"user not found\")\n    if item_id not in inventory_db:\n        raise NotFoundError(\"item not found\")\n\n    user = user_db[user_id]\n    item = inventory_db[item_id]\n\n    if not user.get(\"active\", False):\n        raise BusinessRuleError(\"user is not active\")\n\n    stock = item[\"stock\"]\n    price = item[\"price\"]\n\n    if not isinstance(stock, int) or stock < 0:\n        raise ValueError(\"invalid stock value\")\n    if not isinstance(price, (int, float)) or price < 0:\n        raise ValueError(\"invalid price value\")\n\n    if quantity > stock:\n        raise BusinessRuleError(\"insufficient stock\")\n\n    total_price = float(price) * quantity\n\n    balance = user[\"balance\"]\n    if not isinstance(balance, (int, float)):\n        raise ValueError(\"invalid balance value\")\n\n    if balance < total_price:\n        raise BusinessRuleError(\"insufficient balance\")\n\n    # BUG: 순수 함수가 아니게 inventory_db 를 직접 수정함\n    inventory_db[item_id][\"stock\"] = stock - quantity\n\n    return {\n        \"user_id\": user_id,\n        \"item_id\": item_id,\n        \"quantity\": quantity,\n        \"currency\": currency,\n        \"total_price\": total_price,\n        \"status\": \"approved\",\n    }\n",
      "weight": 2
    }
  ],
  "description_md": "## 문제 설명\n\n한 온라인 쇼핑 서비스에서 주문을 처리하는 핵심 함수가 있습니다. 이 함수는 다음과 같이 여러 계층을 거치면서 예외를 처리합니다.\n\n1. **사용자 입력 검증**: 클라이언트에서 들어온 주문 요청(request)을 검증합니다.\n2. **데이터베이스 조회**: 메모리 상의 user_db, inventory_db에서 사용자와 상품 정보를 조회합니다.\n3. **비즈니스 로직 실행**: 사용자 활성 여부, 재고, 잔액 등 비즈니스 규칙을 적용합니다.\n4. **결과 반환**: 최종 승인된 주문 요약 정보를 반환합니다.\n\n각 단계에서 잘못된 입력이나 데이터 이상, 규칙 위반이 발생할 수 있으며, 이때 **적절한 예외 타입**과 **예외 전파 방식**이 매우 중요합니다.\n\n### 함수 설명\n\n`process_order(request: dict, user_db: dict, inventory_db: dict) -> dict`\n\n- `request`: 주문 요청 정보가 담긴 dict\n  - 필수 키: `\"user_id\"`, `\"item_id\"`, `\"quantity\"`, `\"currency\"`\n- `user_db`: 사용자 정보를 담은 dict (user_id -> 사용자 레코드)\n- `inventory_db`: 상품 정보를 담은 dict (item_id -> 상품 레코드)\n\n정상 처리되면 다음과 같은 dict를 반환합니다:\n\n```text\n{\n  \"user_id\": <str>,\n  \"item_id\": <str>,\n  \"quantity\": <int>,\n  \"currency\": <str>,\n  \"total_price\": <float>,\n  \"status\": \"approved\",\n}\n```\n\n### 정상 동작 예시\n\n```python\nuser_db = {\n    \"u1\": {\"active\": True, \"balance\": 100.0},\n}\n\ninventory_db = {\n    \"item1\": {\"stock\": 10, \"price\": 5.0},\n}\n\nrequest = {\"user_id\": \"u1\", \"item_id\": \"item1\", \"quantity\": 2, \"currency\": \"USD\"}\n\nresult = process_order(request, user_db, inventory_db)\n# result:\n# {\n#   \"user_id\": \"u1\",\n#   \"item_id\": \"item1\",\n#   \"quantity\": 2,\n#   \"currency\": \"USD\",\n#   \"total_price\": 10.0,\n#   \"status\": \"approved\",\n# }\n```\n\n또 다른 예시:\n\n- 존재하지 않는 사용자 ID로 호출하면 `NotFoundError`가 발생해야 합니다.\n- 재고보다 많은 수량을 주문하면 `BusinessRuleError`가 발생해야 합니다.\n\n### 예외/경계 상황 힌트\n\n테스트를 설계할 때 다음과 같은 관점을 고려해 보세요.\n\n- **입력 검증 계층 (exception handling, multi-layer validation)**\n  - 잘못된 타입의 `request` (dict가 아닌 경우)\n  - 필수 키 누락\n  - `quantity`가 0이거나 음수인 경우\n  - 지원하지 않는 통화 코드\n- **데이터베이스 조회 계층 (error propagation)**\n  - 존재하지 않는 `user_id` / `item_id`\n  - 해당 상황에서 정확한 예외 타입이 사용되는지\n- **비즈니스 규칙 계층 (exception handling)**\n  - 비활성 사용자\n  - 재고 부족, 잔액 부족 상황\n  - 모든 비즈니스 규칙 위반이 동일한 예외 타입으로 처리되는지\n- **내부 데이터 이상 / 예외 전파 (error propagation)**\n  - user_db나 inventory_db에 잘못된 스키마(필드 누락, 타입 이상)가 들어온 경우\n  - 이런 내부 오류가 적절히 전파되는지, 혹은 잘못된 예외로 감춰지는지\n- **부수 효과 여부**\n  - 함수는 설명상 입력 DB들을 변경하지 않는 순수 함수여야 합니다. 여러 번 연속 호출 시 상태가 변하지 않는지 확인해 보세요.\n\n### 수험자가 해야 할 일\n\n- 제공된 `process_order` 함수에 대해 **pytest 기반 단위 테스트 코드**를 작성하세요.\n- 여러 가지 입력/상태 조합을 통해 **예외 처리**, **예외 타입 구분**, **다계층 입력 검증 및 비즈니스 규칙 적용**을 엄격하게 검증해야 합니다.\n- 의도적으로 버그가 심어진 여러 구현들 중 최대한 많은 버그를 찾아낼 수 있도록, 다음을 확인하는 테스트를 설계하세요.\n  - 올바른 입력에 대해 기대한 결과 dict가 반환되는지\n  - 각 계층에서 발생하는 오류가 올바른 커스텀 예외 타입으로 표현되는지\n  - 내부 데이터 이상이 발생했을 때, 예외가 적절히 전파되는지\n  - 함수 호출 시 user_db, inventory_db가 예상치 못하게 변경되지 않는지\n\n여러 입력 케이스와 상태 조합을 설계하여, **exception handling**, **error propagation**, **multi-layer validation** 역량을 충분히 드러낼 수 있는 테스트 코드를 작성해 보세요.\n",
  "initial_test_template": "import pytest\nfrom target import process_order, ValidationError, NotFoundError, BusinessRuleError\n\n\n# 공통으로 사용할 예시 DB 픽스처\n@pytest.fixture\ndef sample_user_db():\n    return {\n        \"u_active\": {\"active\": True, \"balance\": 100.0},\n        \"u_inactive\": {\"active\": False, \"balance\": 100.0},\n    }\n\n\n@pytest.fixture\ndef sample_inventory_db():\n    return {\n        \"item_ok\": {\"stock\": 10, \"price\": 5.0},\n        \"item_low\": {\"stock\": 1, \"price\": 50.0},\n    }\n\n\ndef test_happy_path_approved(sample_user_db, sample_inventory_db):\n    # TODO: 정상 주문이 승인되고, 반환 결과가 예상 dict와 일치하는지 확인\n    # TODO: user_db, inventory_db가 변경되지 않았는지도 검증 (부수 효과 방지)\n    pass\n\n\ndef test_input_validation_errors(sample_user_db, sample_inventory_db):\n    # TODO: request가 dict가 아닌 경우, quantity가 0/음수/비정상 타입인 경우 등\n    #       ValidationError가 발생하는 다양한 케이스를 파라미터라이즈하여 테스트\n    pass\n\n\ndef test_not_found_and_business_rule_errors(sample_user_db, sample_inventory_db):\n    # TODO: 존재하지 않는 user_id/item_id -> NotFoundError\n    # TODO: 비활성 사용자, 재고 부족, 잔액 부족 -> BusinessRuleError\n    #       각 케이스에서 예외 타입과 메시지를 구분해서 검증\n    pass\n\n\ndef test_internal_data_anomalies_and_propagation(sample_user_db, sample_inventory_db):\n    # TODO: user_db/inventory_db에 잘못된 스키마(필드 누락, 타입 이상)를 주입\n    #       커스텀 예외로 삼켜지지 않고 원래의 예외(KeyError, ValueError 등)가\n    #       전파되는지 확인\n    pass\n\n",
  "tags": [
    "hard",
    "exception handling",
    "error propagation",
    "multi-layer validation",
    "qa",
    "testing",
    "unit-test",
    "business-logic",
    "dictionary"
  ],
  "difficulty": "Hard"
}