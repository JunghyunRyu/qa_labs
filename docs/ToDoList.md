## 0. 메타 / 정리

- [ ] 이 TODO를 Git 저장소에 `docs/todo.md` 등으로 커밋
- [ ] 큰 단위로 Milestone 나누기
  - [ ] v0.1 – 내부용 MVP (기본 채점 파이프라인 완성)
  - [ ] v0.2 – 보안/로그/기본 운영 안정화
  - [ ] v0.3 – AI-Assist 모드 1차 도입
  - [ ] v0.4 – 외부 베타/지인 테스트
  - [ ] v1.0 – 회사/교육용으로 보여줄 수 있는 수준

---

## 1. 인프라 / 배포 / 채점 파이프라인

### 1-1. Docker / Celery / Judge 환경

- [ ] `docker-compose.prod.yml` 수정
  - [ ] `celery_worker` 서비스에 Docker 소켓 마운트
    - [ ] `volumes: - /var/run/docker.sock:/var/run/docker.sock`
    - [ ] `environment: DOCKER_HOST=unix:///var/run/docker.sock`
  - [ ] 필요하다면 `backend`에도 동일하게 설정
- [ ] Python docker client 설정 점검
  - [ ] 코드에서 `docker.from_env()` 사용 여부 확인
  - [ ] `base_url`이 `http+docker://...` 같이 이상하게 설정된 부분 제거/수정
- [ ] 컨테이너 재배포
  - [ ] `docker-compose -f docker-compose.prod.yml down`
  - [ ] `docker-compose -f docker-compose.prod.yml up -d --build`
- [ ] 채점 파이프라인 동작 확인
  - [ ] 문제 1개 이상 등록 (이미 있음: `normalize-whitespace`)
  - [ ] `/api/v1/submissions` 로 제출 생성 → `PENDING` 확인
  - [ ] Celery 로그 확인 (`docker-compose logs celery_worker | tail -n 100`)
  - [ ] submission 상태 흐름 확인: `PENDING → RUNNING → COMPLETED/FAILED`
  - [ ] judge 컨테이너가 실제 Docker 상에서 생성/종료 되는지 확인

### 1-2. DB / enum / 마이그레이션 정리

- [ ] `difficulty` enum 값 정리 (예: `Easy`, `Medium`, `Hard` 고정)
- [ ] Alembic 마이그레이션 스크립트 재점검
- [ ] `problems`, `buggy_implementations`, `submissions` 스키마 최종 확정
- [ ] 테스트 데이터 세트 몇 개 추가

---

## 2. 기능 / 제품 레벨 TODO (MVP 기준)

### 2-1. 기본 UI & 플로우 (실서버 기준)

- [ ] **한 사이클이 끝까지 도는 기본 플로우 구현**
  - [ ] 문제 목록 페이지
  - [ ] 문제 상세 페이지 (설명, 요구사항, 예제)
  - [ ] 코드 제출 UI (에디터 or 텍스트 영역)
  - [ ] 제출 후 상태/결과 조회 페이지
- [ ] 로컬/실서버 차이 정리
  - [ ] 로컬: UI + 디버깅용
  - [ ] 실서버: 최소 UI라도 구축 (지금은 UI 없음 → 추가 필요)

### 2-2. 채점 로직 최소 구현

- [ ] Celery Task에서
  - [ ] submission 가져오기
  - [ ] 도커 컨테이너 생성 → 코드 실행 → pytest(or 다른 runner) 실행
  - [ ] 결과 파싱 후 `status`, `score`, `logs` 업데이트
- [ ] 실패/타임아웃/에러 핸들링
  - [ ] 타임아웃 설정
  - [ ] 컨테이너 강제 종료 로직
  - [ ] 에러 로그 저장 (내부 전용)

---

## 3. 보안 / 운영 안정성 TODO

### 3-1. API / 인프라 보안

- [ ] 관리/위험 API 보호
  - [ ] `/api/admin/...` 엔드포인트 인증/권한 필터 적용
  - [ ] 필요 시, admin API는 내부에서만 사용하도록 IP 제한
- [ ] DB/Redis/Postgres 포트 점검
  - [ ] 외부에서 직접 접근 불가 상태인지 확인
  - [ ] 도커 네트워크 내부에서만 접근하도록 설정
- [ ] 에러/예외 노출 방지
  - [ ] 스택 트레이스가 그대로 응답에 노출되지 않도록 설정
  - [ ] 500 에러 공통 처리 페이지/JSON 메시지

### 3-2. 베타 전용 안내 및 안전장치

- [ ] 메인 페이지/푸터에 베타 안내 문구 추가
  - [ ] “현재 베타 버전입니다. 테스트용으로만 사용해 주세요.”
  - [ ] “민감 정보/실제 고객 데이터는 절대 입력하지 마세요.”
- [ ] rate limit / basic throttling 고려 (나중용)
- [ ] 로그/모니터링
  - [ ] 간단한 request 로그/채점 실패 로그 남기기

---

## 4. AI 시대용 컨셉/기능 TODO (AI-Assist 모드)

### 4-1. 철학 및 모드 구분

- [ ] 시험 모드 정책 정리
  - [ ] `AI-Free 모드`: 전통 코딩 테스트 (AI 사용 금지/제한 컨셉)
  - [ ] `AI-Assist 모드`: AI 사용 전제로 프롬프트/활용능력까지 평가
- [ ] 문제 메타데이터에 플래그 추가
  - [ ] `ai_assist: true/false`
  - [ ] `time_limit`, `randomized_params` 등 옵션 필드 설계

### 4-2. AI-Assist MVP 기능

- [ ] 제출 폼에 “AI 사용 내역” 필드 추가
  - [ ] 텍스트 영역: `ai_usage_notes` (어떤 프롬프트/도움 받았는지)
  - [ ] AI-Assist 모드일 때는 **필수 입력**으로 변경
- [ ] 데이터 저장
  - [ ] submission 레코드에 `ai_usage_notes` 칼럼 추가
  - [ ] 나중에 리뷰/면접 때 참고 가능하도록 API/관리 화면에서 조회

### 4-3. 향후 확장 아이디어 (기획 TODO)

- [ ] 내부 LLM 패널(내장 AI 창) 설계
  - [ ] 프롬프트/응답 로그를 자동 저장하는 구조 정의
- [ ] 평가 항목 설계 문서화
  - [ ] 프롬프트 품질
  - [ ] AI 답변 검증 태도
  - [ ] 테스트/엣지케이스 설계 능력
  - [ ] 버그 원인 설명력

---

## 5. 문제 설계 / QA 특화 컨텐츠 TODO

### 5-1. “AI만으로는 애매한” QA 문제 템플릿 만들기

- [ ] **Buggy Code Fix + 테스트 작성** 문제 템플릿 1~3개 설계
  - [ ] 요구사항 정리
  - [ ] 버그 포함된 코드 작성
  - [ ] 기대하는 테스트 시나리오 목록
- [ ] **테스트 설계 중심** 문제
  - [ ] 이미 작성된 코드 + 요구사항
  - [ ] 후보자가 pytest 테스트케이스를 직접 작성해야 하는 문제
- [ ] **로그/실패 사례 분석** 문제
  - [ ] 실패 로그/시나리오 제공
  - [ ] 원인 추정 + 필요한 테스트/수정 방향 작성

### 5-2. 문제 메타데이터/뱅크 정리

- [ ] 난이도(`Easy/Medium/Hard`) 재정의
- [ ] 태그 시스템 설계
  - [ ] `api`, `db`, `edge-cases`, `concurrency`, `pytest`, `playwright` 등
- [ ] 블로그/콘텐츠와 재사용 가능하도록 구조 정리

---

## 6. 베타 공개 / 공유 전략 TODO

### 6-1. 외부 베타 준비

- [ ] **MVP 조건 만족 체크**
  - [ ] 실서버에서 UI + “문제 → 제출 → 채점” 한 사이클이 정상 동작
  - [ ] 보안 최소 기준 충족 (admin 보호, DB 외부 노출 없음 등)
  - [ ] 베타 안내문 준비
- [ ] 외부 베타 모집용 글 초안 작성
  - [ ] 한국어 버전
  - [ ] 영어 버전
  - [ ] 타겟: QA 커뮤니티, 개발자 지인, SNS 등

### 6-2. 지인/동료 공유 전략

- [ ] “지인용 안내 문구” 초안 만들기
  - [ ] 이건 **개인 사이드 프로젝트**임을 명확히
  - [ ] 퇴근 후/개인시간에 써보는 전제
  - [ ] 코드/레포는 공유하지 않음
- [ ] 공유 범위 계획
  - [ ] 1차: 회사 밖 QA/개발자 지인
  - [ ] 2차: 신뢰 가능한 회사 동료 1~2명
  - [ ] 3차: 나중에 어느 정도 안정화된 후 팀/팀장에게 소개할 타이밍 설정

---

## 7. 회사/커리어/소유권 전략 TODO

### 7-1. IP/소유권 방어

- [ ] GitHub repo 계속 `private` 유지
- [ ] README 등 문서에 명시
  - [ ] “This is a personal side project, not affiliated with [회사명].”
- [ ] 모든 인프라/계정이 **개인 명의**임을 정리해두는 메모 작성
- [ ] 회사에서 관련 질문 나올 상황 대비 “설명 스크립트” 작성
  - [ ] “회사 리소스 사용 X, 개인 자원으로 만든 프로젝트”
  - [ ] “소유권은 개인이 유지, 회사에는 필요 시 사용권 제공 가능”

### 7-2. 회사와의 협상 포지션 설계

- [ ] “소유권 양도 요구” 시 대비 멘트 정리
  - [ ] 소유권은 유지 + “내부 교육/채용용 사용권” 제안
- [ ] “안 넘기면 나가라” 류의 극단 상황 대비
  - [ ] 그럴 경우 메일로 내용 남기는 템플릿 작성
  - [ ] 내부적으로 플랜 B (이직/사이드 비즈니스 강화) 시나리오 준비

---

## 8. 장기 플랜 / 브랜딩 TODO

- [ ] QA-Arena를 중심으로 한 1~3년 개인 플랜 정리
  - [ ] 기술 스택/제품 로드맵
  - [ ] 블로그/콘텐츠(문제+해설) 운영 계획
  - [ ] 교육/컨설팅/부트캠프 연계 가능성 검토
- [ ] 개인 브랜딩 요소 정리
  - [ ] “AI 시대의 QA 자동화/테스트 플랫폼 엔지니어” 포지셔닝 문구 작성
  - [ ] GitHub/블로그/링크드인 프로필에 녹이기

---
